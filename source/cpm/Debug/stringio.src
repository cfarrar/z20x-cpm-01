; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\stringio.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",10
.DEFINE "uartMode"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "baudRate"
.VALUE 1
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fifoTriggerLevel"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "hwFlowControl"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "swFlowControl"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",9
.DEFINE "pBuffer"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "next_in"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "next_out"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "size"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME1"
;    1	//------------------------------------------------------------------------
;    2	// Copyright (c) 2018, Christopher D. Farrar
;    3	//------------------------------------------------------------------------
;    4	// I here grant permission to any and all to copy and use this software for
;    5	// any purpose as long as my copyright message is retained.
;    6	//----------------------------------------------------------------------------
;    7	#include "ascii.h"
;    8	#include "chario.h"
;    9	#include "stringio.h"
;   10	//------------------------------------------------------------------------
;   11	void consoleStringOut( char *stringP )
;   12	{
_consoleStringOut:
.DEFINE "_consoleStringOut"

.VALUE _consoleStringOut

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "consoleStringOut",12,"_consoleStringOut"

.LINE 12

.DEFINE "stringP"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   13	    while ( *stringP )
.LINE 13

	JR	L_1
L_2:
;   14	    {
;   15	        consoleCharOut( *stringP++ );
.LINE 15

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   16	    }
L_1:
.LINE 16

	LD	HL,(IX+%6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_2
;   17	}
.LINE 17

	LD	SP,IX
	POP	IX
	RET	


;**************************** _consoleStringOut ***************************
;Name                         Addr/Register   Size   Type
;_consoleCharOut                     IMPORT  -----   function
;stringP                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "consoleStringOut",17,"_consoleStringOut"
;   18	//------------------------------------------------------------------------
;   19	unsigned consoleStringIn( char *bufferP, unsigned size )
;   20	{
_consoleStringIn:
.DEFINE "_consoleStringIn"

.VALUE _consoleStringIn

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "consoleStringIn",20,"_consoleStringIn"

.LINE 20

.DEFINE "bufferP"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "textLength"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "characterBuffer"

.CLASS 65

.VALUE -4

.TYPE 2

.ENDEF

.DEFINE "base"

.CLASS 65

.VALUE -7

.TYPE 34

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;   21	    char       *base;
;   22	    char        characterBuffer;
;   23	    unsigned    textLength;
;   24	
;   25	    base = bufferP;
.LINE 25

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF9),BC
;   26	    textLength = 0;
.LINE 26

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
;   27	   *bufferP = '\0';
.LINE 27

	LD	HL,(IX+%6)
	LD	(HL),%0
;   28	
;   29	    for ( ;; )
L_23:
.LINE 29

;   30	    {
;   31	        // get character from serial Port
;   32	        characterBuffer = consoleCharIn();
.LINE 32

	CALL	_consoleCharIn
	LD	(IX+%FFFFFFFC),A
;   33	
;   34	        // make sure 7 bit only
;   35	        characterBuffer &= 0x7F;
.LINE 35

	RES	%7,A
	LD	(IX+%FFFFFFFC),A
;   36	
;   37	        // interpret control characters in input streem
;   38	        if ( characterBuffer < ' ' || characterBuffer == ASCII_DELETE )
.LINE 38

	CP	A,%20
	JP	M,L_21
	LD	A,(IX+%FFFFFFFC)
	CP	A,%7F
	JR	NZ,L_22
L_21:
;   39	        {
;   40	            switch ( characterBuffer )
.LINE 40

	LD	A,(IX+%FFFFFFFC)
	SEXT	HL
	LD	L,(IX+%FFFFFFFC)
	LD	BC,HL
L__5:
	LD	DE,27
	OR	A,A
	SBC	HL,DE
	JR	Z,L_14
	LD	HL,27
	OR	A,A
	SBC	HL,BC
	JR	C,L__7
	LD	DE,24
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_11
	LD	HL,24
	OR	A,A
	SBC	HL,BC
	JR	C,L_17
	LD	DE,8
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	C,L_17
	LD	HL,13
	OR	A,A
	SBC	HL,BC
	JR	C,L_17
	LD	HL,BC
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,L__4-24
	ADD	HL,DE
	LD	HL,(HL)
	JP	(HL)
L__4:
	DW24	L_6	

	DW24	L_17	

	DW24	L_15	

	DW24	L_17	

	DW24	L_17	

	DW24	L_16	

L__7:
	LD	DE,127
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_17
;   41	            {
;   42	
;   43	                case ASCII_DELETE :
.LINE 43

;   44	                case ASCII_BACKSPACE :
L_6:
.LINE 44

;   45	
;   46	                    // delete a character from input bufferP
;   47	                    if ( textLength != 0 )
.LINE 47

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_8
;   48	                    {
;   49	                        consoleCharOut( ASCII_BACKSPACE );
.LINE 49

	LD	BC,8
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   50	                        consoleCharOut( ' ' );
.LINE 50

	LD	BC,32
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   51	                        consoleCharOut( ASCII_BACKSPACE );
.LINE 51

	LD	BC,8
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   52	                     *--bufferP = '\0';
.LINE 52

	LD	BC,(IX+%6)
	DEC	BC
	LD	(IX+%6),BC
	LD	HL,BC
	LD	(HL),%0
;   53	                      --textLength;
.LINE 53

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
;   54	                    }
;   55	                    else
.LINE 55

	JR	L_23
L_8:
;   56	                    {
;   57	                        consoleCharOut( ASCII_BELL );
.LINE 57

	LD	BC,7
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   58	                    }
;   59	                    continue;
.LINE 59

	JR	L_23
;   60	
;   61	                case ASCII_ETXCEL :
;   62	
;   63	                    // delete characters from bufferP until bufferP empty
;   64	                    while ( textLength != 0 )
L_12:
.LINE 64

;   65	                    {
;   66	                        consoleCharOut( ASCII_BACKSPACE );
.LINE 66

	LD	BC,8
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   67	                        consoleCharOut( ' ' );
.LINE 67

	LD	BC,32
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   68	                        consoleCharOut( ASCII_BACKSPACE );
.LINE 68

	LD	BC,8
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   69	                     *--bufferP = '\0';
.LINE 69

	LD	BC,(IX+%6)
	DEC	BC
	LD	(IX+%6),BC
	LD	HL,BC
	LD	(HL),%0
;   70	                      --textLength;
.LINE 70

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
;   71	                    }
L_11:
.LINE 71

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_12
;   72	                    continue;
.LINE 72

	JR	L_23
;   73	
;   74	                case ASCII_ESCAPE :
L_14:
.LINE 74

;   75	
;   76	                    // cancel input and return with empty bufferP
;   77	                   *base = '\0';
.LINE 77

	LD	HL,(IX+%FFFFFFF9)
	LD	(HL),%0
;   78	                    return 0;
.LINE 78

	OR	A,A
	SBC	HL,HL
	JR	L_25
;   79	
;   80	                case ASCII_LINEFEED :
L_15:
.LINE 80

;   81	                case ASCII_ENTER :
L_16:
.LINE 81

;   82	
;   83	                    // return with input in text bufferP
;   84	                    return textLength;
.LINE 84

	LD	HL,(IX+%FFFFFFFD)
	JR	L_25
;   85	
;   86	                default :
L_17:
.LINE 86

;   87	
;   88	                    // any other control characters get you a slap on the wrist
;   89	                    consoleCharOut( ASCII_BELL );
.LINE 89

	LD	BC,7
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;   90	                    continue;
.LINE 90

	JR	L_23
;   91	
;   92	            }
;   93	        }
;   94	        else
L_22:
.LINE 94

;   95	        {
;   96	            // if bufferP not full then put char in bufferP
;   97	            if ( textLength < (size-1) )
.LINE 97

	LD	IY,(IX+%9)
	LEA	BC,IY+%FFFFFFFF
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_20
;   98	            {
;   99	                consoleCharOut( characterBuffer );
.LINE 99

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;  100	               *bufferP++ = characterBuffer;
.LINE 100

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF6),BC
	LD	HL,BC
	LD	A,(IX+%FFFFFFFC)
	LD	(HL),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  101	               *bufferP   = '\0';
.LINE 101

	LD	HL,BC
	LD	(HL),%0
;  102	              ++textLength;
.LINE 102

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  103	            }
;  104	            // else slap user on wrist
;  105	            else
.LINE 105

	JR	L_23
L_20:
;  106	            {
;  107	                consoleCharOut( ASCII_BELL );
.LINE 107

	LD	BC,7
	PUSH	BC
	CALL	_consoleCharOut
	POP	BC
;  108	            }
;  109	        }
;  110	    }
.LINE 110

	JR	L_23
;  111	}
L_25:
.LINE 111

	LD	SP,IX
	POP	IX
	RET	


;**************************** _consoleStringIn ***************************
;Name                         Addr/Register   Size   Type
;_consoleCharOut                     IMPORT  -----   function
;_consoleCharIn                      IMPORT  -----   function
;base                                  IX-7      3   variable
;characterBuffer                       IX-4      1   variable
;textLength                            IX-3      3   variable
;size                                  IX+9      3   parameter
;bufferP                               IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "consoleStringIn",111,"_consoleStringIn"
	XREF _consoleCharOut:ROM
	XREF _consoleCharIn:ROM
	XDEF _consoleStringIn
	XDEF _consoleStringOut
	END
