; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\..\fatfs\source\ff.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",566
.DEFINE "fs_type"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pdrv"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "n_fats"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "wflag"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fsi_flag"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "id"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "n_rootdir"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "csize"
.VALUE 9
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "lfnbuf"
.VALUE 11
.CLASS 8
.TYPE 45
.ENDEF
.DEFINE "last_clst"
.VALUE 14
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "free_clst"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "cdir"
.VALUE 22
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "n_fatent"
.VALUE 26
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fsize"
.VALUE 30
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "volbase"
.VALUE 34
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fatbase"
.VALUE 38
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dirbase"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "database"
.VALUE 46
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "winsect"
.VALUE 50
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "win"
.VALUE 54
.CLASS 8
.DIM 512
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 40
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 44
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",46
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME1"
.TYPE 8
.ENDEF
.DEFINE "dptr"
.VALUE 15
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 23
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir"
.VALUE 27
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "fn"
.VALUE 30
.CLASS 8
.DIM 12
.TYPE 108
.ENDEF
.DEFINE "blk_ofs"
.VALUE 42
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",278
.DEFINE "fsize"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "fdate"
.VALUE 4
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "ftime"
.VALUE 6
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "fattrib"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "altname"
.VALUE 9
.CLASS 8
.DIM 13
.TYPE 98
.ENDEF
.DEFINE "fname"
.VALUE 22
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.ENDREC "NONAME4"
	SEGMENT BSS
_FatFs:
	DS	3
.DEFINE "FatFs"
.ALIAS "_FatFs"
.CLASS 83
.VALUE _FatFs
.DIM 1
.TAG "NONAME0"
.TYPE 360
.ENDEF
_Fsid:
	DS	2*1
.DEFINE "Fsid"
.ALIAS "_Fsid"
.CLASS 83
.VALUE _Fsid
.TYPE 13
.ENDEF
_CurrVol:
	DS	1
.DEFINE "CurrVol"
.ALIAS "_CurrVol"
.CLASS 83
.VALUE _CurrVol
.TYPE 12
.ENDEF
	SEGMENT TEXT
_LfnOfs:
	DB	1
	DB	3
	DB	5
	DB	7
	DB	9
	DB	14
	DB	16
	DB	18
	DB	20
	DB	22
	DB	24
	DB	28
	DB	30
.DEFINE "LfnOfs"
.ALIAS "_LfnOfs"
.CLASS 84
.VALUE _LfnOfs
.DIM 13
.TYPE 108
.ENDEF
	SEGMENT BSS
_LfnBuf:
	DS	512
.DEFINE "LfnBuf"
.ALIAS "_LfnBuf"
.CLASS 83
.VALUE _LfnBuf
.DIM 256
.TYPE 109
.ENDEF
	SEGMENT TEXT
_ExCvt:
	DB	128
	DB	154
	DB	69
	DB	65
	DB	142
	DB	65
	DB	143
	DB	128
	DB	69
	DB	69
	DB	69
	DB	73
	DB	73
	DB	73
	DB	142
	DB	143
	DB	144
	DB	146
	DB	146
	DB	79
	DB	153
	DB	79
	DB	85
	DB	85
	DB	89
	DB	153
	DB	154
	DB	155
	DB	156
	DB	157
	DB	158
	DB	159
	DB	65
	DB	73
	DB	79
	DB	85
	DB	165
	DB	165
	DB	166
	DB	167
	DB	168
	DB	169
	DB	170
	DB	171
	DB	172
	DB	173
	DB	174
	DB	175
	DB	176
	DB	177
	DB	178
	DB	179
	DB	180
	DB	181
	DB	182
	DB	183
	DB	184
	DB	185
	DB	186
	DB	187
	DB	188
	DB	189
	DB	190
	DB	191
	DB	192
	DB	193
	DB	194
	DB	195
	DB	196
	DB	197
	DB	198
	DB	199
	DB	200
	DB	201
	DB	202
	DB	203
	DB	204
	DB	205
	DB	206
	DB	207
	DB	208
	DB	209
	DB	210
	DB	211
	DB	212
	DB	213
	DB	214
	DB	215
	DB	216
	DB	217
	DB	218
	DB	219
	DB	220
	DB	221
	DB	222
	DB	223
	DB	224
	DB	225
	DB	226
	DB	227
	DB	228
	DB	229
	DB	230
	DB	231
	DB	232
	DB	233
	DB	234
	DB	235
	DB	236
	DB	237
	DB	238
	DB	239
	DB	240
	DB	241
	DB	242
	DB	243
	DB	244
	DB	245
	DB	246
	DB	247
	DB	248
	DB	249
	DB	250
	DB	251
	DB	252
	DB	253
	DB	254
	DB	255
.DEFINE "ExCvt"
.ALIAS "_ExCvt"
.CLASS 84
.VALUE _ExCvt
.DIM 128
.TYPE 108
.ENDEF
;    1	/*----------------------------------------------------------------------------/
;    2	/  FatFs - Generic FAT Filesystem Module  R0.13b                              /
;    3	/-----------------------------------------------------------------------------/
;    4	/
;    5	/ Copyright (C) 2018, ChaN, all right reserved.
;    6	/
;    7	/ FatFs module is an open source software. Redistribution and use of FatFs in
;    8	/ source and binary forms, with or without modification, are permitted provided
;    9	/ that the following condition is met:
;   10	/
;   11	/ 1. Redistributions of source code must retain the above copyright notice,
;   12	/    this condition and the following disclaimer.
;   13	/
;   14	/ This software is provided by the copyright holder and contributors "AS IS"
;   15	/ and any warranties related to this software are DISCLAIMED.
;   16	/ The copyright owner or contributors be NOT LIABLE for any damages caused
;   17	/ by use of this software.
;   18	/
;   19	/----------------------------------------------------------------------------*/
;   20	
;   21	
;   22	#include "ff.h"			/* Declarations of FatFs API */
;   23	#include "diskio.h"		/* Declarations of device I/O functions */
;   24	
;   25	
;   26	/*--------------------------------------------------------------------------
;   27	
;   28	   Module Private Definitions
;   29	
;   30	---------------------------------------------------------------------------*/
;   31	
;   32	#if FF_DEFINED != 63463	/* Revision ID */
;   33	#error Wrong include file (ff.h).
;   34	#endif
;   35	
;   36	
;   37	/* Character code support macros */
;   38	#define IsUpper(c)		((c) >= 'A' && (c) <= 'Z')
;   39	#define IsLower(c)		((c) >= 'a' && (c) <= 'z')
;   40	#define IsDigit(c)		((c) >= '0' && (c) <= '9')
;   41	#define IsSurrogate(c)	((c) >= 0xD800 && (c) <= 0xDFFF)
;   42	#define IsSurrogateH(c)	((c) >= 0xD800 && (c) <= 0xDBFF)
;   43	#define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <= 0xDFFF)
;   44	
;   45	
;   46	/* Additional file attribute bits for internal use */
;   47	#define AM_VOL		0x08	/* Volume label */
;   48	#define AM_LFN		0x0F	/* LFN entry */
;   49	#define AM_MASK		0x3F	/* Mask of defined bits */
;   50	
;   51	
;   52	/* Additional file access control and file status flags for internal use */
;   53	#define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
;   54	#define FA_MODIFIED	0x40	/* File has been modified */
;   55	#define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
;   56	
;   57	
;   58	/* Name status flags in fn[11] */
;   59	#define NSFLAG		11		/* Index of the name status byte */
;   60	#define NS_LOSS		0x01	/* Out of 8.3 format */
;   61	#define NS_LFN		0x02	/* Force to create LFN entry */
;   62	#define NS_LAST		0x04	/* Last segment */
;   63	#define NS_BODY		0x08	/* Lower case flag (body) */
;   64	#define NS_EXT		0x10	/* Lower case flag (ext) */
;   65	#define NS_DOT		0x20	/* Dot entry */
;   66	#define NS_NOLFN	0x40	/* Do not find LFN */
;   67	#define NS_NONAME	0x80	/* Not followed */
;   68	
;   69	
;   70	/* Limits and boundaries */
;   71	#define MAX_DIR		0x200000		/* Max size of FAT directory */
;   72	#define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
;   73	#define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows behavior) */
;   74	#define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Windows behavior) */
;   75	#define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
;   76	#define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
;   77	
;   78	
;   79	/* FatFs refers the FAT structure as simple byte array instead of structure member
;   80	/ because the C structure is not binary compatible between different platforms */
;   81	
;   82	#define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
;   83	#define BS_OEMName			3		/* OEM name (8-byte) */
;   84	#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
;   85	#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
;   86	#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
;   87	#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
;   88	#define BPB_RootEntCnt		17		/* Size of root directory area for FAT [entry] (WORD) */
;   89	#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
;   90	#define BPB_Media			21		/* Media descriptor byte (BYTE) */
;   91	#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
;   92	#define BPB_SecPerTrk		24		/* Number of sectors per track for int13h [sector] (WORD) */
;   93	#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
;   94	#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
;   95	#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
;   96	#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
;   97	#define BS_NTres			37		/* WindowsNT error flag (BYTE) */
;   98	#define BS_BootSig			38		/* Extended boot signature (BYTE) */
;   99	#define BS_VolID			39		/* Volume serial number (DWORD) */
;  100	#define BS_VolLab			43		/* Volume label string (8-byte) */
;  101	#define BS_FilSysType		54		/* Filesystem type string (8-byte) */
;  102	#define BS_BootCode			62		/* Boot code (448-byte) */
;  103	#define BS_55AA				510		/* Signature word (WORD) */
;  104	
;  105	#define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
;  106	#define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
;  107	#define BPB_FSVer32			42		/* FAT32: Filesystem version (WORD) */
;  108	#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
;  109	#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
;  110	#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
;  111	#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
;  112	#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
;  113	#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
;  114	#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
;  115	#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
;  116	#define BS_FilSysType32		82		/* FAT32: Filesystem type string (8-byte) */
;  117	#define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
;  118	
;  119	#define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
;  120	#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
;  121	#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
;  122	#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
;  123	#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
;  124	#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
;  125	#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
;  126	#define BPB_RootClusEx		96		/* exFAT: Root directory start cluster (DWORD) */
;  127	#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
;  128	#define BPB_FSVerEx			104		/* exFAT: Filesystem version (WORD) */
;  129	#define BPB_VolFlagEx		106		/* exFAT: Volume flags (WORD) */
;  130	#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in unit of byte (BYTE) */
;  131	#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in unit of sector (BYTE) */
;  132	#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
;  133	#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
;  134	#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
;  135	#define BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
;  136	#define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
;  137	
;  138	#define DIR_Name			0		/* Short file name (11-byte) */
;  139	#define DIR_Attr			11		/* Attribute (BYTE) */
;  140	#define DIR_NTres			12		/* Lower case flag (BYTE) */
;  141	#define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
;  142	#define DIR_CrtTime			14		/* Created time (DWORD) */
;  143	#define DIR_LstAccDate		18		/* Last accessed date (WORD) */
;  144	#define DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
;  145	#define DIR_ModTime			22		/* Modified time (DWORD) */
;  146	#define DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
;  147	#define DIR_FileSize		28		/* File size (DWORD) */
;  148	#define LDIR_Ord			0		/* LFN: LFN order and LLE flag (BYTE) */
;  149	#define LDIR_Attr			11		/* LFN: LFN attribute (BYTE) */
;  150	#define LDIR_Type			12		/* LFN: Entry type (BYTE) */
;  151	#define LDIR_Chksum			13		/* LFN: Checksum of the SFN (BYTE) */
;  152	#define LDIR_FstClusLO		26		/* LFN: MBZ field (WORD) */
;  153	#define XDIR_Type			0		/* exFAT: Type of exFAT directory entry (BYTE) */
;  154	#define XDIR_NumLabel		1		/* exFAT: Number of volume label characters (BYTE) */
;  155	#define XDIR_Label			2		/* exFAT: Volume label (11-WORD) */
;  156	#define XDIR_CaseSum		4		/* exFAT: Sum of case conversion table (DWORD) */
;  157	#define XDIR_NumSec			1		/* exFAT: Number of secondary entries (BYTE) */
;  158	#define XDIR_SetSum			2		/* exFAT: Sum of the set of directory entries (WORD) */
;  159	#define XDIR_Attr			4		/* exFAT: File attribute (WORD) */
;  160	#define XDIR_CrtTime		8		/* exFAT: Created time (DWORD) */
;  161	#define XDIR_ModTime		12		/* exFAT: Modified time (DWORD) */
;  162	#define XDIR_AccTime		16		/* exFAT: Last accessed time (DWORD) */
;  163	#define XDIR_CrtTime10		20		/* exFAT: Created time subsecond (BYTE) */
;  164	#define XDIR_ModTime10		21		/* exFAT: Modified time subsecond (BYTE) */
;  165	#define XDIR_CrtTZ			22		/* exFAT: Created timezone (BYTE) */
;  166	#define XDIR_ModTZ			23		/* exFAT: Modified timezone (BYTE) */
;  167	#define XDIR_AccTZ			24		/* exFAT: Last accessed timezone (BYTE) */
;  168	#define XDIR_GenFlags		33		/* exFAT: General secondary flags (BYTE) */
;  169	#define XDIR_NumName		35		/* exFAT: Number of file name characters (BYTE) */
;  170	#define XDIR_NameHash		36		/* exFAT: Hash of file name (WORD) */
;  171	#define XDIR_ValidFileSize	40		/* exFAT: Valid file size (QWORD) */
;  172	#define XDIR_FstClus		52		/* exFAT: First cluster of the file data (DWORD) */
;  173	#define XDIR_FileSize		56		/* exFAT: File/Directory size (QWORD) */
;  174	
;  175	#define SZDIRE				32		/* Size of a directory entry */
;  176	#define DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
;  177	#define RDDEM				0x05	/* Replacement of the character collides with DDEM */
;  178	#define LLEF				0x40	/* Last long entry flag in LDIR_Ord */
;  179	
;  180	#define FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
;  181	#define FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
;  182	#define FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
;  183	#define FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
;  184	
;  185	#define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
;  186	#define SZ_PTE				16		/* MBR: Size of a partition table entry */
;  187	#define PTE_Boot			0		/* MBR PTE: Boot indicator */
;  188	#define PTE_StHead			1		/* MBR PTE: Start head */
;  189	#define PTE_StSec			2		/* MBR PTE: Start sector */
;  190	#define PTE_StCyl			3		/* MBR PTE: Start cylinder */
;  191	#define PTE_System			4		/* MBR PTE: System ID */
;  192	#define PTE_EdHead			5		/* MBR PTE: End head */
;  193	#define PTE_EdSec			6		/* MBR PTE: End sector */
;  194	#define PTE_EdCyl			7		/* MBR PTE: End cylinder */
;  195	#define PTE_StLba			8		/* MBR PTE: Start in LBA */
;  196	#define PTE_SizLba			12		/* MBR PTE: Size in LBA */
;  197	
;  198	
;  199	/* Post process on fatal error in the file operations */
;  200	#define ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
;  201	
;  202	
;  203	/* Re-entrancy related */
;  204	#if FF_FS_REENTRANT
;  205	#if FF_USE_LFN == 1
;  206	#error Static LFN work area cannot be used at thread-safe configuration
;  207	#endif
;  208	#define LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
;  209	#else
;  210	#define LEAVE_FF(fs, res)	return res
;  211	#endif
;  212	
;  213	
;  214	/* Definitions of volume - physical location conversion */
;  215	#if FF_MULTI_PARTITION
;  216	#define LD2PD(vol) VolToPart[vol].pd	/* Get physical drive number */
;  217	#define LD2PT(vol) VolToPart[vol].pt	/* Get partition index */
;  218	#else
;  219	#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
;  220	#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
;  221	#endif
;  222	
;  223	
;  224	/* Definitions of sector size */
;  225	#if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MAX_SS != 4096) || (FF_MIN_SS != 512 && FF_MIN_SS != 1024 && FF_MIN_SS != 2048 && FF_MIN_SS != 4096)
;  226	#error Wrong sector size configuration
;  227	#endif
;  228	#if FF_MAX_SS == FF_MIN_SS
;  229	#define SS(fs)	((UINT)FF_MAX_SS)	/* Fixed sector size */
;  230	#else
;  231	#define SS(fs)	((fs)->ssize)	/* Variable sector size */
;  232	#endif
;  233	
;  234	
;  235	/* Timestamp */
;  236	#if FF_FS_NORTC == 1
;  237	#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 1 || FF_NORTC_MDAY > 31
;  238	#error Invalid FF_FS_NORTC settings
;  239	#endif
;  240	#define GET_FATTIME()	((DWORD)(FF_NORTC_YEAR - 1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_NORTC_MDAY << 16)
;  241	#else
;  242	#define GET_FATTIME()	get_fattime()
;  243	#endif
;  244	
;  245	
;  246	/* File lock controls */
;  247	#if FF_FS_LOCK != 0
;  248	#if FF_FS_READONLY
;  249	#error FF_FS_LOCK must be 0 at read-only configuration
;  250	#endif
;  251	typedef struct {
;  252		FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
;  253		DWORD clu;		/* Object ID 2, containing directory (0:root) */
;  254		DWORD ofs;		/* Object ID 3, offset in the directory */
;  255		WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
;  256	} FILESEM;
;  257	#endif
;  258	
;  259	
;  260	/* SBCS up-case tables (\x80-\xFF) */
;  261	#define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  262						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  263						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  264						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  265						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  266						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  267						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  268						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  269	#define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  270						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  271						0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  272						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  273						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  274						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  275						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  276						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  277	#define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  278						0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
;  279						0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
;  280						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  281						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  282						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  283						0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  284						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  285	#define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  286						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  287						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  288						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  289						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  290						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
;  291						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  292						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
;  293	#define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
;  294						0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
;  295						0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  296						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  297						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  298						0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  299						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
;  300						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  301	#define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
;  302						0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
;  303						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  304						0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  305						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  306						0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
;  307						0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
;  308						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  309	#define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
;  310						0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
;  311						0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
;  312						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
;  313						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  314						0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  315						0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
;  316						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
;  317	#define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
;  318						0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
;  319						0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
;  320						0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
;  321						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  322						0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
;  323						0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
;  324						0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
;  325	#define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
;  326						0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
;  327						0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  328						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  329						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  330						0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  331						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
;  332						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  333	#define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
;  334						0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  335						0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  336						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  337						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  338						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  339						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  340						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  341	#define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
;  342						0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
;  343						0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  344						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  345						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  346						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  347						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  348						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  349	#define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  350						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  351						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  352						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  353						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  354						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  355						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  356						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  357	#define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
;  358						0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
;  359						0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  360						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  361						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  362						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  363						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  364						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  365	#define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  366						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  367						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  368						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  369						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  370						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  371						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  372						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  373	#define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
;  374						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  375						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  376						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  377						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  378						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  379						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
;  380						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  381	#define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  382						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  383						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  384						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  385						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  386						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
;  387						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
;  388						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
;  389	#define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
;  390						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
;  391						0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
;  392						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
;  393						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
;  394						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
;  395						0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
;  396						0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
;  397	
;  398	
;  399	/* DBCS code range |----- 1st byte -----|  |----------- 2nd byte -----------| */
;  400	#define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 0x7E, 0x80, 0xFC, 0x00, 0x00}
;  401	#define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00}
;  402	#define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 0x5A, 0x61, 0x7A, 0x81, 0xFE}
;  403	#define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0xA1, 0xFE, 0x00, 0x00}
;  404	
;  405	
;  406	/* Macros for table definitions */
;  407	#define MERGE_2STR(a, b) a ## b
;  408	#define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)
;  409	
;  410	
;  411	
;  412	
;  413	/*--------------------------------------------------------------------------
;  414	
;  415	   Module Private Work Area
;  416	
;  417	---------------------------------------------------------------------------*/
;  418	/* Remark: Variables defined here without initial value shall be guaranteed
;  419	/  zero/null at start-up. If not, the linker option or start-up routine is
;  420	/  not compliance with C standard. */
;  421	
;  422	/*--------------------------------*/
;  423	/* File/Volume controls           */
;  424	/*--------------------------------*/
;  425	
;  426	#if FF_VOLUMES < 1 || FF_VOLUMES > 10
;  427	#error Wrong FF_VOLUMES setting
;  428	#endif
;  429	static FATFS* FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
;  430	static WORD Fsid;					/* Filesystem mount ID */
;  431	
;  432	#if FF_FS_RPATH != 0
;  433	static BYTE CurrVol;				/* Current drive */
;  434	#endif
;  435	
;  436	#if FF_FS_LOCK != 0
;  437	static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
;  438	#endif
;  439	
;  440	#if FF_STR_VOLUME_ID
;  441	#ifdef FF_VOLUME_STRS
;  442	static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};	/* Pre-defined volume ID */
;  443	#endif
;  444	#endif
;  445	
;  446	
;  447	/*--------------------------------*/
;  448	/* LFN/Directory working buffer   */
;  449	/*--------------------------------*/
;  450	
;  451	#if FF_USE_LFN == 0		/* Non-LFN configuration */
;  452	#if FF_FS_EXFAT
;  453	#error LFN must be enabled when enable exFAT
;  454	#endif
;  455	#define DEF_NAMBUF
;  456	#define INIT_NAMBUF(fs)
;  457	#define FREE_NAMBUF()
;  458	#define LEAVE_MKFS(res)	return res
;  459	
;  460	#else					/* LFN configurations */
;  461	#if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
;  462	#error Wrong setting of FF_MAX_LFN
;  463	#endif
;  464	#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
;  465	#error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
;  466	#endif
;  467	#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
;  468	#error Wrong setting of FF_LFN_UNICODE
;  469	#endif
;  470	static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* FAT: Offset of LFN characters in the directory entry */
;  471	#define MAXDIRB(nc)	((nc + 44U) / 15 * SZDIRE)	/* exFAT: Size of directory entry block scratchpad buffer needed for the name length */
;  472	
;  473	#if FF_USE_LFN == 1		/* LFN enabled with static working buffer */
;  474	#if FF_FS_EXFAT
;  475	static BYTE	DirBuf[MAXDIRB(FF_MAX_LFN)];	/* Directory entry block scratchpad buffer */
;  476	#endif
;  477	static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
;  478	#define DEF_NAMBUF
;  479	#define INIT_NAMBUF(fs)
;  480	#define FREE_NAMBUF()
;  481	#define LEAVE_MKFS(res)	return res
;  482	
;  483	#elif FF_USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
;  484	#if FF_FS_EXFAT
;  485	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];	/* LFN working buffer and directory entry block scratchpad buffer */
;  486	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
;  487	#define FREE_NAMBUF()
;  488	#else
;  489	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1];	/* LFN working buffer */
;  490	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
;  491	#define FREE_NAMBUF()
;  492	#endif
;  493	#define LEAVE_MKFS(res)	return res
;  494	
;  495	#elif FF_USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
;  496	#if FF_FS_EXFAT
;  497	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer and directory entry block scratchpad buffer */
;  498	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+FF_MAX_LFN+1); }
;  499	#define FREE_NAMBUF()	ff_memfree(lfn)
;  500	#else
;  501	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer */
;  502	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
;  503	#define FREE_NAMBUF()	ff_memfree(lfn)
;  504	#endif
;  505	#define LEAVE_MKFS(res)	{ if (!work) ff_memfree(buf); return res; }
;  506	#define MAX_MALLOC	0x8000	/* Must be >=FF_MAX_SS */
;  507	
;  508	#else
;  509	#error Wrong setting of FF_USE_LFN
;  510	
;  511	#endif	/* FF_USE_LFN == 1 */
;  512	#endif	/* FF_USE_LFN == 0 */
;  513	
;  514	
;  515	
;  516	/*--------------------------------*/
;  517	/* Code conversion tables         */
;  518	/*--------------------------------*/
;  519	
;  520	#if FF_CODE_PAGE == 0		/* Run-time code page configuration */
;  521	#define CODEPAGE CodePage
;  522	static WORD CodePage;	/* Current code page */
;  523	static const BYTE *ExCvt, *DbcTbl;	/* Pointer to current SBCS up-case table and DBCS code range table below */
;  524	static const BYTE Ct437[] = TBL_CT437;
;  525	static const BYTE Ct720[] = TBL_CT720;
;  526	static const BYTE Ct737[] = TBL_CT737;
;  527	static const BYTE Ct771[] = TBL_CT771;
;  528	static const BYTE Ct775[] = TBL_CT775;
;  529	static const BYTE Ct850[] = TBL_CT850;
;  530	static const BYTE Ct852[] = TBL_CT852;
;  531	static const BYTE Ct855[] = TBL_CT855;
;  532	static const BYTE Ct857[] = TBL_CT857;
;  533	static const BYTE Ct860[] = TBL_CT860;
;  534	static const BYTE Ct861[] = TBL_CT861;
;  535	static const BYTE Ct862[] = TBL_CT862;
;  536	static const BYTE Ct863[] = TBL_CT863;
;  537	static const BYTE Ct864[] = TBL_CT864;
;  538	static const BYTE Ct865[] = TBL_CT865;
;  539	static const BYTE Ct866[] = TBL_CT866;
;  540	static const BYTE Ct869[] = TBL_CT869;
;  541	static const BYTE Dc932[] = TBL_DC932;
;  542	static const BYTE Dc936[] = TBL_DC936;
;  543	static const BYTE Dc949[] = TBL_DC949;
;  544	static const BYTE Dc950[] = TBL_DC950;
;  545	
;  546	#elif FF_CODE_PAGE < 900	/* Static code page configuration (SBCS) */
;  547	#define CODEPAGE FF_CODE_PAGE
;  548	static const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CODE_PAGE);
	SEGMENT CODE
;  549	
;  550	#else					/* Static code page configuration (DBCS) */
;  551	#define CODEPAGE FF_CODE_PAGE
;  552	static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);
;  553	
;  554	#endif
;  555	
;  556	
;  557	
;  558	
;  559	/*--------------------------------------------------------------------------
;  560	
;  561	   Module Private Functions
;  562	
;  563	---------------------------------------------------------------------------*/
;  564	
;  565	
;  566	/*-----------------------------------------------------------------------*/
;  567	/* Load/Store multi-byte word in the FAT structure                       */
;  568	/*-----------------------------------------------------------------------*/
;  569	
;  570	static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
;  571	{
_ld_word:
.DEFINE "_ld_word"

.VALUE _ld_word

.CLASS 3

.TYPE 77

.ENDEF

.BEGFUNC "ld_word",571,"_ld_word"

.LINE 571

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "rv"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  572		WORD rv;
;  573	
;  574		rv = ptr[1];
.LINE 574

	LD	HL,(IX+%6)
	INC	HL
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  575		rv = rv << 8 | ptr[0];
.LINE 575

	LD	HL,(IX+%6)
	LD	C,(HL)
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFE)
	LD	H,L
	LD	L,%0
	LD	BC,HL
	LD	HL,DE
	CALL	__sor
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  576		return rv;
.LINE 576

	LD	HL,(IX+%FFFFFFFE)
;  577	}
.LINE 577

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_word ***************************
;Name                         Addr/Register   Size   Type
;rv                                    IX-2      2   variable
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ld_word",577,"_ld_word"
;  578	
;  579	static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
;  580	{
_ld_dword:
.DEFINE "_ld_dword"

.VALUE _ld_dword

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "ld_dword",580,"_ld_dword"

.LINE 580

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "rv"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEB
	LD	SP,HL
;  581		DWORD rv;
;  582	
;  583		rv = ptr[3];
.LINE 583

	LD	IY,(IX+%6)
	UEXT	HL
	LD	L,(IY+%3)
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),H
;  584		rv = rv << 8 | ptr[2];
.LINE 584

	UEXT	HL
	LD	L,(IY+%2)
	LD	(IX+%FFFFFFF9),HL
	LD	E,H
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	PUSH	BC
	UEXT	HL
	PUSH	HL
	INC	SP
	INC	SP
	POP	BC
	LD	(IX+%FFFFFFF8),E	; spill
	POP	DE
	LD	(IX+%FFFFFFF7),E	; spill
	LD	E,(IX+%FFFFFFF8)	; unspill
	INC	SP
	LD	HL,(IX+%FFFFFFF9)
	LD	(IX+%FFFFFFF8),E	; spill
	LD	E,(IX+%FFFFFFF7)	; unspill
	LD	A,E
	LD	E,(IX+%FFFFFFF8)	; unspill
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  585		rv = rv << 8 | ptr[1];
.LINE 585

	UEXT	HL
	LD	L,(IY+%1)
	LD	(IX+%FFFFFFF4),HL
	LD	E,H
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	PUSH	BC
	UEXT	HL
	PUSH	HL
	INC	SP
	INC	SP
	POP	BC
	LD	(IX+%FFFFFFF8),E	; spill
	POP	DE
	LD	(IX+%FFFFFFF3),E	; spill
	LD	E,(IX+%FFFFFFF8)	; unspill
	INC	SP
	LD	HL,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFF8),E	; spill
	LD	E,(IX+%FFFFFFF3)	; unspill
	LD	A,E
	LD	E,(IX+%FFFFFFF8)	; unspill
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  586		rv = rv << 8 | ptr[0];
.LINE 586

	LD	BC,HL
	PUSH	BC
	PUSH	BC
	UEXT	HL
	PUSH	HL
	INC	SP
	INC	SP
	POP	DE
	LD	(IX+%FFFFFFED),DE	; spill
	POP	HL
	LD	(IX+%FFFFFFEB),L	; spill
	INC	SP
	UEXT	HL
	LD	L,(IY)
	LD	BC,HL
	LD	A,H
	LD	L,(IX+%FFFFFFEB)	; unspill
	LD	E,L
	LD	(IX+%FFFFFFF0),DE	; spill
	LD	HL,(IX+%FFFFFFED)
	LD	DE,(IX+%FFFFFFF0)	; unspill
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  587		return rv;
.LINE 587

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
;  588	}
.LINE 588

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_dword ***************************
;Name                         Addr/Register   Size   Type
;rv                                    IX-4      4   variable
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "ld_dword",588,"_ld_dword"
;  589	
;  590	#if FF_FS_EXFAT
;  591	static QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
;  592	{
;  593		QWORD rv;
;  594	
;  595		rv = ptr[7];
;  596		rv = rv << 8 | ptr[6];
;  597		rv = rv << 8 | ptr[5];
;  598		rv = rv << 8 | ptr[4];
;  599		rv = rv << 8 | ptr[3];
;  600		rv = rv << 8 | ptr[2];
;  601		rv = rv << 8 | ptr[1];
;  602		rv = rv << 8 | ptr[0];
;  603		return rv;
;  604	}
;  605	#endif
;  606	
;  607	#if !FF_FS_READONLY
;  608	static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
;  609	{
_st_word:
.DEFINE "_st_word"

.VALUE _st_word

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "st_word",609,"_st_word"

.LINE 609

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  610		*ptr++ = (BYTE)val; val >>= 8;
.LINE 610

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	DEC	SP
	PUSH	BC
	INC	SP
	POP	AF
	SEXT	HL
	PUSH	HL
	PUSH	BC
	INC	SP
	POP	HL
	INC	SP
	INC	SP
	LD	(IX+%9),L
	LD	(IX+%A),H
;  611		*ptr++ = (BYTE)val;
.LINE 611

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
;  612	}
.LINE 612

	LD	SP,IX
	POP	IX
	RET	


;**************************** _st_word ***************************
;Name                         Addr/Register   Size   Type
;val                                   IX+9      2   parameter
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "st_word",612,"_st_word"
;  613	
;  614	static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
;  615	{
_st_dword:
.DEFINE "_st_dword"

.VALUE _st_dword

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "st_dword",615,"_st_dword"

.LINE 615

.DEFINE "ptr"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  616		*ptr++ = (BYTE)val; val >>= 8;
.LINE 616

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	BC,(IX+%A)
	XOR	A,A
	LD	(IX+%9),BC
	LD	(IX+%C),A
;  617		*ptr++ = (BYTE)val; val >>= 8;
.LINE 617

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	BC,(IX+%A)
	XOR	A,A
	LD	(IX+%9),BC
	LD	(IX+%C),A
;  618		*ptr++ = (BYTE)val; val >>= 8;
.LINE 618

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
	LD	BC,(IX+%A)
	XOR	A,A
	LD	(IX+%9),BC
	LD	(IX+%C),A
;  619		*ptr++ = (BYTE)val;
.LINE 619

	LD	A,(IX+%9)
	LD	HL,(IX+%6)
	LD	(HL),A
;  620	}
.LINE 620

	LD	SP,IX
	POP	IX
	RET	


;**************************** _st_dword ***************************
;Name                         Addr/Register   Size   Type
;val                                   IX+9      4   parameter
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "st_dword",620,"_st_dword"
;  621	
;  622	#if FF_FS_EXFAT
;  623	static void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
;  624	{
;  625		*ptr++ = (BYTE)val; val >>= 8;
;  626		*ptr++ = (BYTE)val; val >>= 8;
;  627		*ptr++ = (BYTE)val; val >>= 8;
;  628		*ptr++ = (BYTE)val; val >>= 8;
;  629		*ptr++ = (BYTE)val; val >>= 8;
;  630		*ptr++ = (BYTE)val; val >>= 8;
;  631		*ptr++ = (BYTE)val; val >>= 8;
;  632		*ptr++ = (BYTE)val;
;  633	}
;  634	#endif
;  635	#endif	/* !FF_FS_READONLY */
;  636	
;  637	
;  638	
;  639	/*-----------------------------------------------------------------------*/
;  640	/* String functions                                                      */
;  641	/*-----------------------------------------------------------------------*/
;  642	
;  643	/* Copy memory to memory */
;  644	static void mem_cpy (void* dst, const void* src, UINT cnt)
;  645	{
_mem_cpy:
.DEFINE "_mem_cpy"

.VALUE _mem_cpy

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "mem_cpy",645,"_mem_cpy"

.LINE 645

.DEFINE "dst"

.CLASS 65

.VALUE 6

.TYPE 33

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "cnt"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "d"

.CLASS 65

.VALUE -3

.TYPE 44

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 204

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  646		BYTE *d = (BYTE*)dst;
.LINE 646

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  647		const BYTE *s = (const BYTE*)src;
.LINE 647

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  648	
;  649		if (cnt != 0) {
.LINE 649

	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_15
;  650			do {
L_12:
.LINE 650

;  651				*d++ = *s++;
.LINE 651

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF4),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  652			} while (--cnt);
.LINE 652

	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_12
;  653		}
;  654	}
L_15:
.LINE 654

	LD	SP,IX
	POP	IX
	RET	


;**************************** _mem_cpy ***************************
;Name                         Addr/Register   Size   Type
;s                                     IX-6      3   variable
;d                                     IX-3      3   variable
;cnt                                  IX+12      3   parameter
;src                                   IX+9      3   parameter
;dst                                   IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "mem_cpy",654,"_mem_cpy"
;  655	
;  656	
;  657	/* Fill memory block */
;  658	static void mem_set (void* dst, int val, UINT cnt)
;  659	{
_mem_set:
.DEFINE "_mem_set"

.VALUE _mem_set

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "mem_set",659,"_mem_set"

.LINE 659

.DEFINE "dst"

.CLASS 65

.VALUE 6

.TYPE 33

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "cnt"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "d"

.CLASS 65

.VALUE -3

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  660		BYTE *d = (BYTE*)dst;
.LINE 660

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  661	
;  662		do {
L_17:
.LINE 662

;  663			*d++ = (BYTE)val;
.LINE 663

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
	LD	A,(IX+%9)
	LD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  664		} while (--cnt);
.LINE 664

	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_17
;  665	}
.LINE 665

	LD	SP,IX
	POP	IX
	RET	


;**************************** _mem_set ***************************
;Name                         Addr/Register   Size   Type
;d                                     IX-3      3   variable
;cnt                                  IX+12      3   parameter
;val                                   IX+9      3   parameter
;dst                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "mem_set",665,"_mem_set"
;  666	
;  667	
;  668	/* Compare memory block */
;  669	static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
;  670	{
_mem_cmp:
.DEFINE "_mem_cmp"

.VALUE _mem_cmp

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "mem_cmp",670,"_mem_cmp"

.LINE 670

.DEFINE "dst"

.CLASS 65

.VALUE 6

.TYPE 193

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "cnt"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "d"

.CLASS 65

.VALUE -3

.TYPE 204

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 204

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;  671		const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
.LINE 671

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  672		int r = 0;
;  673	
;  674		do {
L_23:
.LINE 674

;  675			r = *d++ - *s++;
.LINE 675

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF4),BC
	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF1),BC
	LD	HL,(IX+%FFFFFFF4)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF1)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFF7),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  676		} while (--cnt && r == 0);
.LINE 676

	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_25
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_23
L_25:
;  677	
;  678		return r;
.LINE 678

	LD	HL,(IX+%FFFFFFF7)
;  679	}
.LINE 679

	LD	SP,IX
	POP	IX
	RET	


;**************************** _mem_cmp ***************************
;Name                         Addr/Register   Size   Type
;r                                     IX-9      3   variable
;s                                     IX-6      3   variable
;d                                     IX-3      3   variable
;cnt                                  IX+12      3   parameter
;src                                   IX+9      3   parameter
;dst                                   IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "mem_cmp",679,"_mem_cmp"
;  680	
;  681	
;  682	/* Check if chr is contained in the string */
;  683	static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
;  684	{
_chk_chr:
.DEFINE "_chk_chr"

.VALUE _chk_chr

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "chk_chr",684,"_chk_chr"

.LINE 684

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "chr"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  685		while (*str && *str != chr) str++;
.LINE 685

	JR	L_29
L_30:
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
L_29:
	LD	HL,(IX+%6)
	LD	A,(HL)
	OR	A,A
	JR	Z,L_31
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_30
L_31:
;  686		return *str;
.LINE 686

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
;  687	}
.LINE 687

	LD	SP,IX
	POP	IX
	RET	


;**************************** _chk_chr ***************************
;Name                         Addr/Register   Size   Type
;chr                                   IX+9      3   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "chk_chr",687,"_chk_chr"
;  688	
;  689	
;  690	/* Test if the character is DBC 1st byte */
;  691	static int dbc_1st (BYTE c)
;  692	{
_dbc_1st:
.DEFINE "_dbc_1st"

.VALUE _dbc_1st

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dbc_1st",692,"_dbc_1st"

.LINE 692

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  693	#if FF_CODE_PAGE == 0		/* Variable code page */
;  694		if (DbcTbl && c >= DbcTbl[0]) {
;  695			if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
;  696			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
;  697		}
;  698	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;  699		if (c >= DbcTbl[0]) {
;  700			if (c <= DbcTbl[1]) return 1;
;  701			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
;  702		}
;  703	#else						/* SBCS fixed code page */
;  704		if (c != 0) return 0;	/* Always false */
.LINE 704

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_34
	OR	A,A
	SBC	HL,HL
	JR	L_35
L_34:
;  705	#endif
;  706		return 0;
.LINE 706

	OR	A,A
	SBC	HL,HL
;  707	}
L_35:
.LINE 707

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dbc_1st ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dbc_1st",707,"_dbc_1st"
;  708	
;  709	
;  710	/* Test if the character is DBC 2nd byte */
;  711	static int dbc_2nd (BYTE c)
;  712	{
_dbc_2nd:
.DEFINE "_dbc_2nd"

.VALUE _dbc_2nd

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dbc_2nd",712,"_dbc_2nd"

.LINE 712

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  713	#if FF_CODE_PAGE == 0		/* Variable code page */
;  714		if (DbcTbl && c >= DbcTbl[4]) {
;  715			if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
;  716			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
;  717			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
;  718		}
;  719	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;  720		if (c >= DbcTbl[4]) {
;  721			if (c <= DbcTbl[5]) return 1;
;  722			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
;  723			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
;  724		}
;  725	#else						/* SBCS fixed code page */
;  726		if (c != 0) return 0;	/* Always false */
.LINE 726

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_37
	OR	A,A
	SBC	HL,HL
	JR	L_38
L_37:
;  727	#endif
;  728		return 0;
.LINE 728

	OR	A,A
	SBC	HL,HL
;  729	}
L_38:
.LINE 729

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dbc_2nd ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dbc_2nd",729,"_dbc_2nd"
;  730	
;  731	
;  732	#if FF_USE_LFN
;  733	
;  734	/* Get a character from TCHAR string in defined API encodeing */
;  735	static DWORD tchar2uni (	/* Returns character in UTF-16 encoding (>=0x10000 on double encoding unit, 0xFFFFFFFF on decode error) */
;  736		const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
;  737	)
;  738	{
_tchar2uni:
.DEFINE "_tchar2uni"

.VALUE _tchar2uni

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "tchar2uni",738,"_tchar2uni"

.LINE 738

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -3

.TYPE 194

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;  739		DWORD uc;
;  740		const TCHAR *p = *str;
.LINE 740

	LD	HL,(IX+%6)
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
;  741	
;  742	#if FF_LFN_UNICODE == 1		/* UTF-16 input */
;  743		WCHAR wc;
;  744	
;  745		uc = *p++;	/* Get a unit */
;  746		if (IsSurrogate(uc)) {	/* Surrogate? */
;  747			wc = *p++;		/* Get low surrogate */
;  748			if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;	/* Wrong surrogate? */
;  749			uc = uc << 16 | wc;
;  750		}
;  751	
;  752	#elif FF_LFN_UNICODE == 2	/* UTF-8 input */
;  753		BYTE b;
;  754		int nf;
;  755	
;  756		uc = (BYTE)*p++;	/* Get a unit */
;  757		if (uc & 0x80) {	/* Multiple byte code? */
;  758			if ((uc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
;  759				uc &= 0x1F; nf = 1;
;  760			} else {
;  761				if ((uc & 0xF0) == 0xE0) {	/* 3-byte sequence? */
;  762					uc &= 0x0F; nf = 2;
;  763				} else {
;  764					if ((uc & 0xF8) == 0xF0) {	/* 4-byte sequence? */
;  765						uc &= 0x07; nf = 3;
;  766					} else {					/* Wrong sequence */
;  767						return 0xFFFFFFFF;
;  768					}
;  769				}
;  770			}
;  771			do {	/* Get trailing bytes */
;  772				b = (BYTE)*p++;
;  773				if ((b & 0xC0) != 0x80) return 0xFFFFFFFF;	/* Wrong sequence? */
;  774				uc = uc << 6 | (b & 0x3F);
;  775			} while (--nf != 0);
;  776			if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
;  777			if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
;  778		}
;  779	
;  780	#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
;  781		uc = (TCHAR)*p++;	/* Get a unit */
;  782		if (uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
;  783		if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
;  784	
;  785	#else		/* ANSI/OEM input */
;  786		BYTE b;
;  787		WCHAR wc;
;  788	
;  789		wc = (BYTE)*p++;			/* Get a byte */
.LINE 789

	LD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  790		if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1st byte? */
.LINE 790

	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	CALL	_dbc_1st
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_46
;  791			b = (BYTE)*p++;			/* Get 2nd byte */
.LINE 791

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	(IX+%FFFFFFFA),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  792			if (!dbc_2nd(b)) return 0xFFFFFFFF;	/* Invalid code? */
.LINE 792

	LD	C,(IX+%FFFFFFFA)
	LD	B,%0
	PUSH	BC
	CALL	_dbc_2nd
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_42
	LD	HL,16777215
	LD	E,%FF
	JR	L_48
L_42:
;  793			wc = (wc << 8) + b;		/* Make a DBC */
.LINE 793

	LD	HL,(IX+%FFFFFFFB)
	LD	H,L
	LD	L,%0
	LD	C,(IX+%FFFFFFFA)
	LD	B,%0
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
;  794		}
L_46:
.LINE 794

;  795		if (wc != 0) {
.LINE 795

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_47
;  796			wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
.LINE 796

	LD	BC,437
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_ff_oem2uni
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
;  797			if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
.LINE 797

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_47
	LD	HL,16777215
	LD	E,%FF
	JR	L_48
;  798		}
L_47:
.LINE 798

;  799		uc = wc;
.LINE 799

	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),A
;  800	
;  801	#endif
;  802		*str = p;	/* Next read pointer */
.LINE 802

	LD	HL,(IX+%6)
	LD	BC,(IX+%FFFFFFFD)
	LD	(HL),BC
;  803		return uc;
.LINE 803

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
;  804	}
L_48:
.LINE 804

	LD	SP,IX
	POP	IX
	RET	


;**************************** _tchar2uni ***************************
;Name                         Addr/Register   Size   Type
;_ff_oem2uni                         IMPORT  -----   function
;uc                                   IX-10      4   variable
;b                                     IX-6      1   variable
;wc                                    IX-5      2   variable
;p                                     IX-3      3   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "tchar2uni",804,"_tchar2uni"
;  805	
;  806	
;  807	/* Output a TCHAR string in defined API encoding */
;  808	static BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
;  809		DWORD chr,	/* UTF-16 encoded character (Double encoding unit char if >=0x10000) */
;  810		TCHAR* buf,	/* Output buffer */
;  811		UINT szb	/* Size of the buffer */
;  812	)
;  813	{
_put_utf:
.DEFINE "_put_utf"

.VALUE _put_utf

.CLASS 3

.TYPE 76

.ENDEF

.BEGFUNC "put_utf",813,"_put_utf"

.LINE 813

.DEFINE "chr"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE 12

.TYPE 34

.ENDEF

.DEFINE "szb"

.CLASS 65

.VALUE 15

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  814	#if FF_LFN_UNICODE == 1	/* UTF-16 output */
;  815		WCHAR hs, wc;
;  816	
;  817		hs = (WCHAR)(chr >> 16);
;  818		wc = (WCHAR)chr;
;  819		if (hs == 0) {	/* Single encoding unit? */
;  820			if (szb < 1 || IsSurrogate(wc)) return 0;	/* Buffer overflow or wrong code? */
;  821			*buf = wc;
;  822			return 1;
;  823		}
;  824		if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogateL(wc)) return 0;	/* Buffer overflow or wrong surrogate? */
;  825		*buf++ = hs;
;  826		*buf++ = wc;
;  827		return 2;
;  828	
;  829	#elif FF_LFN_UNICODE == 2	/* UTF-8 output */
;  830		DWORD hc;
;  831	
;  832		if (chr < 0x80) {	/* Single byte code? */
;  833			if (szb < 1) return 0;	/* Buffer overflow? */
;  834			*buf = (TCHAR)chr;
;  835			return 1;
;  836		}
;  837		if (chr < 0x800) {	/* 2-byte sequence? */
;  838			if (szb < 2) return 0;	/* Buffer overflow? */
;  839			*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
;  840			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  841			return 2;
;  842		}
;  843		if (chr < 0x10000) {	/* 3-byte sequence? */
;  844			if (szb < 3 || IsSurrogate(chr)) return 0;	/* Buffer overflow or wrong code? */
;  845			*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
;  846			*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
;  847			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  848			return 3;
;  849		}
;  850		/* 4-byte sequence */
;  851		if (szb < 4) return 0;	/* Buffer overflow? */
;  852		hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
;  853		chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
;  854		if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
;  855		chr = (hc | chr) + 0x10000;
;  856		*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
;  857		*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
;  858		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
;  859		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
;  860		return 4;
;  861	
;  862	#elif FF_LFN_UNICODE == 3	/* UTF-32 output */
;  863		DWORD hc;
;  864	
;  865		if (szb < 1) return 0;	/* Buffer overflow? */
;  866		if (chr >= 0x10000) {	/* Out of BMP? */
;  867			hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
;  868			chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
;  869			if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
;  870			chr = (hc | chr) + 0x10000;
;  871		}
;  872		*buf++ = (TCHAR)chr;
;  873		return 1;
;  874	
;  875	#else						/* ANSI/OEM output */
;  876		WCHAR wc;
;  877	
;  878		wc = ff_uni2oem(chr, CODEPAGE);
.LINE 878

	LD	BC,437
	PUSH	BC
	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_ff_uni2oem
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  879		if (wc >= 0x100) {	/* Is this a DBC? */
.LINE 879

	LD.LIS	BC,256
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_56
;  880			if (szb < 2) return 0;
.LINE 880

	LD	BC,2
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_51
	XOR	A,A
	JR	L_59
L_51:
;  881			*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
.LINE 881

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	DEC	SP
	PUSH	BC
	INC	SP
	POP	AF
	SEXT	HL
	PUSH	HL
	PUSH	BC
	INC	SP
	POP	HL
	INC	SP
	INC	SP
	LD	IY,(IX+%C)
	LD	(IY),L
	LD	BC,(IX+%C)
	INC	BC
	LD	(IX+%C),BC
;  882			*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
.LINE 882

	LD	A,(IX+%FFFFFFFE)
	LD	HL,BC
	LD	(HL),A
;  883			return 2;
.LINE 883

	LD	A,%2
	JR	L_59
;  884		}
L_56:
.LINE 884

;  885		if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
.LINE 885

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_55
	LD	BC,1
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_58
L_55:
	XOR	A,A
	JR	L_59
L_58:
;  886		*buf++ = (TCHAR)wc;					/* Store the character */
.LINE 886

	LD	A,(IX+%FFFFFFFE)
	LD	HL,(IX+%C)
	LD	(HL),A
;  887		return 1;
.LINE 887

	LD	A,%1
;  888	#endif
;  889	}
L_59:
.LINE 889

	LD	SP,IX
	POP	IX
	RET	


;**************************** _put_utf ***************************
;Name                         Addr/Register   Size   Type
;_ff_uni2oem                         IMPORT  -----   function
;wc                                    IX-2      2   variable
;szb                                  IX+15      3   parameter
;buf                                  IX+12      3   parameter
;chr                                   IX+6      4   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "put_utf",889,"_put_utf"
;  890	#endif	/* FF_USE_LFN */
;  891	
;  892	
;  893	#if FF_FS_REENTRANT
;  894	/*-----------------------------------------------------------------------*/
;  895	/* Request/Release grant to access the volume                            */
;  896	/*-----------------------------------------------------------------------*/
;  897	static int lock_fs (		/* 1:Ok, 0:timeout */
;  898		FATFS* fs		/* Filesystem object */
;  899	)
;  900	{
;  901		return ff_req_grant(fs->sobj);
;  902	}
;  903	
;  904	
;  905	static void unlock_fs (
;  906		FATFS* fs,		/* Filesystem object */
;  907		FRESULT res		/* Result code to be returned */
;  908	)
;  909	{
;  910		if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
;  911			ff_rel_grant(fs->sobj);
;  912		}
;  913	}
;  914	
;  915	#endif
;  916	
;  917	
;  918	
;  919	#if FF_FS_LOCK != 0
;  920	/*-----------------------------------------------------------------------*/
;  921	/* File lock control functions                                           */
;  922	/*-----------------------------------------------------------------------*/
;  923	
;  924	static FRESULT chk_lock (	/* Check if the file can be accessed */
;  925		DIR* dp,		/* Directory object pointing the file to be checked */
;  926		int acc			/* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
;  927	)
;  928	{
;  929		UINT i, be;
;  930	
;  931		/* Search open object table for the object */
;  932		be = 0;
;  933		for (i = 0; i < FF_FS_LOCK; i++) {
;  934			if (Files[i].fs) {	/* Existing entry */
;  935				if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matches with an open object */
;  936					Files[i].clu == dp->obj.sclust &&
;  937					Files[i].ofs == dp->dptr) break;
;  938			} else {			/* Blank entry */
;  939				be = 1;
;  940			}
;  941		}
;  942		if (i == FF_FS_LOCK) {	/* The object has not been opened */
;  943			return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new object? */
;  944		}
;  945	
;  946		/* The object was opened. Reject any open against writing file and all write mode open */
;  947		return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
;  948	}
;  949	
;  950	
;  951	static int enq_lock (void)	/* Check if an entry is available for a new object */
;  952	{
;  953		UINT i;
;  954	
;  955		for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
;  956		return (i == FF_FS_LOCK) ? 0 : 1;
;  957	}
;  958	
;  959	
;  960	static UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
;  961		DIR* dp,	/* Directory object pointing the file to register or increment */
;  962		int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;  963	)
;  964	{
;  965		UINT i;
;  966	
;  967	
;  968		for (i = 0; i < FF_FS_LOCK; i++) {	/* Find the object */
;  969			if (Files[i].fs == dp->obj.fs &&
;  970				Files[i].clu == dp->obj.sclust &&
;  971				Files[i].ofs == dp->dptr) break;
;  972		}
;  973	
;  974		if (i == FF_FS_LOCK) {				/* Not opened. Register it as new. */
;  975			for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
;  976			if (i == FF_FS_LOCK) return 0;	/* No free entry to register (int err) */
;  977			Files[i].fs = dp->obj.fs;
;  978			Files[i].clu = dp->obj.sclust;
;  979			Files[i].ofs = dp->dptr;
;  980			Files[i].ctr = 0;
;  981		}
;  982	
;  983		if (acc >= 1 && Files[i].ctr) return 0;	/* Access violation (int err) */
;  984	
;  985		Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;  986	
;  987		return i + 1;	/* Index number origin from 1 */
;  988	}
;  989	
;  990	
;  991	static FRESULT dec_lock (	/* Decrement object open counter */
;  992		UINT i			/* Semaphore index (1..) */
;  993	)
;  994	{
;  995		WORD n;
;  996		FRESULT res;
;  997	
;  998	
;  999		if (--i < FF_FS_LOCK) {	/* Index number origin from 0 */
; 1000			n = Files[i].ctr;
; 1001			if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
; 1002			if (n > 0) n--;				/* Decrement read mode open count */
; 1003			Files[i].ctr = n;
; 1004			if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
; 1005			res = FR_OK;
; 1006		} else {
; 1007			res = FR_INT_ERR;			/* Invalid index nunber */
; 1008		}
; 1009		return res;
; 1010	}
; 1011	
; 1012	
; 1013	static void clear_lock (	/* Clear lock entries of the volume */
; 1014		FATFS *fs
; 1015	)
; 1016	{
; 1017		UINT i;
; 1018	
; 1019		for (i = 0; i < FF_FS_LOCK; i++) {
; 1020			if (Files[i].fs == fs) Files[i].fs = 0;
; 1021		}
; 1022	}
; 1023	
; 1024	#endif	/* FF_FS_LOCK != 0 */
; 1025	
; 1026	
; 1027	
; 1028	/*-----------------------------------------------------------------------*/
; 1029	/* Move/Flush disk access window in the filesystem object                */
; 1030	/*-----------------------------------------------------------------------*/
; 1031	#if !FF_FS_READONLY
; 1032	static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
; 1033		FATFS* fs			/* Filesystem object */
; 1034	)
; 1035	{
_sync_window:
.DEFINE "_sync_window"

.VALUE _sync_window

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "sync_window",1035,"_sync_window"

.LINE 1035

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
; 1036		FRESULT res = FR_OK;
.LINE 1036

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 1037	
; 1038	
; 1039		if (fs->wflag) {	/* Is the disk access window dirty */
.LINE 1039

	LD	IY,(IX+%6)
	LD	A,(IY+%3)
	OR	A,A
	JR	Z,L_65
; 1040			if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
.LINE 1040

	LD	BC,1
	PUSH	BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	LD	A,(IY+%35)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%36
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_63
; 1041				fs->wflag = 0;	/* Clear window dirty flag */
.LINE 1041

	LD	IY,(IX+%6)
	LD	(IY+%3),%0
; 1042				if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
.LINE 1042

	LD	BC,(IY+%32)
	LD	A,(IY+%35)
	LD	(IX+%FFFFFFF5),BC
	LD	(IX+%FFFFFFF8),A
	LD	BC,(IY+%1E)
	LD	A,(IY+%21)
	LD	(IX+%FFFFFFF9),BC
	LD	(IX+%FFFFFFFC),A
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IY+%26)
	LD	A,(IY+%29)
	CALL	__lsub
	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	CALL	__lcmpu
	JR	NC,L_65
; 1043					if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
.LINE 1043

	LD	IY,(IX+%6)
	LD	A,(IY+%2)
	CP	A,%2
	JR	NZ,L_65
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	IY,(IX+%6)
	PEA	IY+%36
	LD	C,(IY+%1)
	PUSH	BC
	CALL	_disk_write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1044				}
; 1045			} else {
.LINE 1045

	JR	L_65
L_63:
; 1046				res = FR_DISK_ERR;
.LINE 1046

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 1047			}
; 1048		}
L_65:
.LINE 1048

; 1049		return res;
.LINE 1049

	LD	HL,(IX+%FFFFFFFD)
; 1050	}
.LINE 1050

	LD	SP,IX
	POP	IX
	RET	


;**************************** _sync_window ***************************
;Name                         Addr/Register   Size   Type
;_disk_write                         IMPORT  -----   function
;G_0                                  IX-11      4   variable
;G_1                                   IX-7      4   variable
;res                                   IX-3      3   variable
;fs                                    IX+6      3   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "sync_window",1050,"_sync_window"
; 1051	#endif
; 1052	
; 1053	
; 1054	static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
; 1055		FATFS* fs,			/* Filesystem object */
; 1056		DWORD sector		/* Sector number to make appearance in the fs->win[] */
; 1057	)
; 1058	{
_move_window:
.DEFINE "_move_window"

.VALUE _move_window

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "move_window",1058,"_move_window"

.LINE 1058

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 1059		FRESULT res = FR_OK;
.LINE 1059

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 1060	
; 1061	
; 1062		if (sector != fs->winsect) {	/* Window offset changed? */
.LINE 1062

	LD	IY,(IX+%6)
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	Z,L_71
; 1063	#if !FF_FS_READONLY
; 1064			res = sync_window(fs);		/* Write-back changes */
.LINE 1064

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_sync_window
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1065	#endif
; 1066			if (res == FR_OK) {			/* Fill sector window with new data */
.LINE 1066

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_71
; 1067				if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
.LINE 1067

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%36
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_68
; 1068					sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
.LINE 1068

	LD	BC,16777215
	LD	A,%FF
	LD	(IX+%9),BC
	LD	(IX+%C),A
; 1069					res = FR_DISK_ERR;
.LINE 1069

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 1070				}
L_68:
.LINE 1070

; 1071				fs->winsect = sector;
.LINE 1071

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%32),BC
	LD	(IY+%35),A
; 1072			}
; 1073		}
L_71:
.LINE 1073

; 1074		return res;
.LINE 1074

	LD	HL,(IX+%FFFFFFFD)
; 1075	}
.LINE 1075

	LD	SP,IX
	POP	IX
	RET	


;**************************** _move_window ***************************
;Name                         Addr/Register   Size   Type
;_disk_read                          IMPORT  -----   function
;res                                   IX-3      3   variable
;sector                                IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "move_window",1075,"_move_window"
; 1076	
; 1077	
; 1078	
; 1079	
; 1080	#if !FF_FS_READONLY
; 1081	/*-----------------------------------------------------------------------*/
; 1082	/* Synchronize filesystem and data on the storage                        */
; 1083	/*-----------------------------------------------------------------------*/
; 1084	
; 1085	static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
; 1086		FATFS* fs		/* Filesystem object */
; 1087	)
; 1088	{
_sync_fs:
.DEFINE "_sync_fs"

.VALUE _sync_fs

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "sync_fs",1088,"_sync_fs"

.LINE 1088

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 1089		FRESULT res;
; 1090	
; 1091	
; 1092		res = sync_window(fs);
.LINE 1092

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_sync_window
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1093		if (res == FR_OK) {
.LINE 1093

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_78
; 1094			if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
.LINE 1094

	LD	IY,(IX+%6)
	LD	A,(IY+%0)
	CP	A,%3
	JR	NZ,L_76
	LD	IY,(IX+%6)
	LD	A,(IY+%4)
	CP	A,%1
	JR	NZ,L_76
; 1095				/* Create FSInfo structure */
; 1096				mem_set(fs->win, 0, SS(fs));
.LINE 1096

	LD	BC,512
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%36
	CALL	_mem_set
	POP	BC
	POP	BC
	POP	BC
; 1097				st_word(fs->win + BS_55AA, 0xAA55);
.LINE 1097

	LD	BC,43605
	PUSH	BC
	LD	BC,510
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_word
	POP	BC
	POP	BC
; 1098				st_dword(fs->win + FSI_LeadSig, 0x41615252);
.LINE 1098

	LD	BC,65
	PUSH	BC
	LD	BC,6378066
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%36
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 1099				st_dword(fs->win + FSI_StrucSig, 0x61417272);
.LINE 1099

	LD	BC,97
	PUSH	BC
	LD	BC,4289138
	PUSH	BC
	LD	BC,484
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 1100				st_dword(fs->win + FSI_Free_Count, fs->free_clst);
.LINE 1100

	LD	IY,(IX+%6)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,488
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 1101				st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
.LINE 1101

	LD	IY,(IX+%6)
	LD	BC,(IY+%E)
	LD	A,(IY+%11)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,492
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 1102				/* Write it into the FSInfo sector */
; 1103				fs->winsect = fs->volbase + 1;
.LINE 1103

	LD	IY,(IX+%6)
	LD	HL,(IY+%22)
	LD	E,(IY+%25)
	LD	A,%1
	CALL	__ladd_b
	LD	(IY+%32),HL
	LD	(IY+%35),E
; 1104				disk_write(fs->pdrv, fs->win, fs->winsect, 1);
.LINE 1104

	LD	BC,1
	PUSH	BC
	LD	BC,(IY+%32)
	LD	A,(IY+%35)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%36
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 1105				fs->fsi_flag = 0;
.LINE 1105

	LD	IY,(IX+%6)
	LD	(IY+%4),%0
; 1106			}
L_76:
.LINE 1106

; 1107			/* Make sure that no pending write process in the lower layer */
; 1108			if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
.LINE 1108

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	IY,(IX+%6)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_ioctl
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_78
	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 1109		}
L_78:
.LINE 1109

; 1110	
; 1111		return res;
.LINE 1111

	LD	HL,(IX+%FFFFFFFD)
; 1112	}
.LINE 1112

	LD	SP,IX
	POP	IX
	RET	


;**************************** _sync_fs ***************************
;Name                         Addr/Register   Size   Type
;_disk_ioctl                         IMPORT  -----   function
;_disk_write                         IMPORT  -----   function
;res                                   IX-3      3   variable
;fs                                    IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "sync_fs",1112,"_sync_fs"
; 1113	
; 1114	#endif
; 1115	
; 1116	
; 1117	
; 1118	/*-----------------------------------------------------------------------*/
; 1119	/* Get physical sector number from cluster number                        */
; 1120	/*-----------------------------------------------------------------------*/
; 1121	
; 1122	static DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
; 1123		FATFS* fs,		/* Filesystem object */
; 1124		DWORD clst		/* Cluster# to be converted */
; 1125	)
; 1126	{
_clst2sect:
.DEFINE "_clst2sect"

.VALUE _clst2sect

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "clst2sect",1126,"_clst2sect"

.LINE 1126

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1127		clst -= 2;		/* Cluster number is origin from 2 */
.LINE 1127

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
; 1128		if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
.LINE 1128

	LD	IY,(IX+%6)
	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	CALL	__lcmpu
	JR	C,L_81
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	JR	L_82
L_81:
; 1129		return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
.LINE 1129

	LD	IY,(IX+%6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	E,%0
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lmulu
	LD	BC,(IY+%2E)
	LD	A,(IY+%31)
	CALL	__ladd
; 1130	}
L_82:
.LINE 1130

	LD	SP,IX
	POP	IX
	RET	


;**************************** _clst2sect ***************************
;Name                         Addr/Register   Size   Type
;clst                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "clst2sect",1130,"_clst2sect"
; 1131	
; 1132	
; 1133	
; 1134	
; 1135	/*-----------------------------------------------------------------------*/
; 1136	/* FAT access - Read value of a FAT entry                                */
; 1137	/*-----------------------------------------------------------------------*/
; 1138	
; 1139	static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
; 1140		FFOBJID* obj,	/* Corresponding object */
; 1141		DWORD clst		/* Cluster number to get the value */
; 1142	)
; 1143	{
_get_fat:
.DEFINE "_get_fat"

.VALUE _get_fat

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "get_fat",1143,"_get_fat"

.LINE 1143

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "bc"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 1144		UINT wc, bc;
; 1145		DWORD val;
; 1146		FATFS *fs = obj->fs;
.LINE 1146

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
; 1147	
; 1148	
; 1149		if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
.LINE 1149

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_101
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_102
L_101:
; 1150			val = 1;	/* Internal error */
.LINE 1150

	LD	BC,1
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1151	
; 1152		} else {
.LINE 1152

	JR	L_103
L_102:
; 1153			val = 0xFFFFFFFF;	/* Default value falls on disk error */
.LINE 1153

	LD	BC,16777215
	LD	A,%FF
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1154	
; 1155			switch (fs->fs_type) {
.LINE 1155

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	UEXT	HL
	LD	L,A
	LD	BC,HL
L__48:
	LD	DE,1
	OR	A,A
	SBC	HL,DE
	JR	C,L_100
	LD	HL,3
	OR	A,A
	SBC	HL,BC
	JR	C,L_100
	LD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,L__47-3
	ADD	HL,BC
	LD	HL,(HL)
	JP	(HL)
L__47:
	DW24	L_84	

	DW24	L_94	

	DW24	L_97	

; 1156			case FS_FAT12 :
L_84:
.LINE 1156

; 1157				bc = (UINT)clst; bc += bc / 2;
.LINE 1157

	LD	HL,(IX+%9)
	LD	A,%1
	CALL	__ishru_b
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 1158				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
.LINE 1158

	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_103
; 1159				wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
.LINE 1159

	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF3),HL
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
; 1160				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
.LINE 1160

	LD	HL,BC
	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_103
; 1161				wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
.LINE 1161

	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	UEXT	HL
	PUSH	HL
	INC	SP
	INC	SP
	POP	HL
	INC	SP
	LD	BC,(IX+%FFFFFFF3)
	CALL	__ior
	LD	(IX+%FFFFFFF3),HL
; 1162				val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
.LINE 1162

	LD	A,(IX+%9)
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_92
	LD	HL,(IX+%FFFFFFF3)
	LD	A,%4
	CALL	__ishru_b
	LD	(IX+%FFFFFFF0),HL
	JR	L_93
L_92:
	LD	BC,4095
	LD	HL,(IX+%FFFFFFF3)
	CALL	__iand
	LD	(IX+%FFFFFFF0),HL
L_93:
	LD	BC,(IX+%FFFFFFF0)
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1163				break;
.LINE 1163

	JR	L_103
; 1164	
; 1165			case FS_FAT16 :
L_94:
.LINE 1165

; 1166				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
.LINE 1166

	LD	BC,(IX+%A)
	XOR	A,A
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_103
; 1167				val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
.LINE 1167

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),A
; 1168				break;
.LINE 1168

	JR	L_103
; 1169	
; 1170			case FS_FAT32 :
L_97:
.LINE 1170

; 1171				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
.LINE 1171

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%7
	CALL	__lshru
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_103
; 1172				val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
.LINE 1172

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	BC,16777215
	LD	A,%F
	CALL	__land
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 1173				break;
.LINE 1173

	JR	L_103
; 1174	#if FF_FS_EXFAT
; 1175			case FS_EXFAT :
; 1176				if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
; 1177					DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
; 1178					DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
; 1179	
; 1180					if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
; 1181						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
; 1182						break;
; 1183					}
; 1184					if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
; 1185						val = clst + 1; 	/* Generate the value */
; 1186						break;
; 1187					}
; 1188					if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
; 1189						if (obj->n_frag != 0) {	/* Is it on the growing edge? */
; 1190							val = 0x7FFFFFFF;	/* Generate EOC */
; 1191						} else {
; 1192							if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
; 1193							val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
; 1194						}
; 1195						break;
; 1196					}
; 1197				}
; 1198				/* go to default */
; 1199	#endif
; 1200			default:
L_100:
.LINE 1200

; 1201				val = 1;	/* Internal error */
.LINE 1201

	LD	BC,1
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 1202			}
; 1203		}
L_103:
.LINE 1203

; 1204	
; 1205		return val;
.LINE 1205

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
; 1206	}
.LINE 1206

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_fat ***************************
;Name                         Addr/Register   Size   Type
;temp90                               IX-16      3   variable
;wc                                   IX-13      3   variable
;val                                  IX-10      4   variable
;bc                                    IX-6      3   variable
;fs                                    IX-3      3   variable
;clst                                  IX+9      4   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "get_fat",1206,"_get_fat"
; 1207	
; 1208	
; 1209	
; 1210	
; 1211	#if !FF_FS_READONLY
; 1212	/*-----------------------------------------------------------------------*/
; 1213	/* FAT access - Change value of a FAT entry                              */
; 1214	/*-----------------------------------------------------------------------*/
; 1215	
; 1216	static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
; 1217		FATFS* fs,		/* Corresponding filesystem object */
; 1218		DWORD clst,		/* FAT index number (cluster number) to be changed */
; 1219		DWORD val		/* New value to be set to the entry */
; 1220	)
; 1221	{
_put_fat:
.DEFINE "_put_fat"

.VALUE _put_fat

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "put_fat",1221,"_put_fat"

.LINE 1221

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE 15

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "bc"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -16

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE6
	LD	SP,HL
; 1222		UINT bc;
; 1223		BYTE *p;
; 1224		FRESULT res = FR_INT_ERR;
.LINE 1224

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 1225	
; 1226	
; 1227		if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
.LINE 1227

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_129
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	IY,(IX+%6)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	NC,L_129
; 1228			switch (fs->fs_type) {
.LINE 1228

	LD	IY,(IX+%6)
	LD	A,(IY+%0)
	UEXT	HL
	LD	L,A
	LD	BC,HL
L__60:
	LD	DE,1
	OR	A,A
	SBC	HL,DE
	JR	C,L_129
	LD	HL,3
	OR	A,A
	SBC	HL,BC
	JR	C,L_129
	LD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,L__59-3
	ADD	HL,BC
	LD	HL,(HL)
	JP	(HL)
L__59:
	DW24	L_106	

	DW24	L_120	

	DW24	L_123	

; 1229			case FS_FAT12 :
L_106:
.LINE 1229

; 1230				bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
.LINE 1230

	LD	HL,(IX+%9)
	LD	A,%1
	CALL	__ishru_b
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 1231				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
.LINE 1231

	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1232				if (res != FR_OK) break;
.LINE 1232

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_129
; 1233				p = fs->win + bc++ % SS(fs);
.LINE 1233

	LD	IY,(IX+%6)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
; 1234				*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
.LINE 1234

	LD	A,(IX+%9)
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L__65
	LD	A,%1
	JR	L__66
L__65:
	XOR	A,A
L__66:
	LD	(IX+%FFFFFFF9),A
	OR	A,A
	JR	NZ,L_112
	LD	IY,(IX+%6)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFED),BC
	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	BC,HL
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	A,(HL)
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(IX+%F)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,DE
	CALL	__ior
	LD	(IX+%FFFFFFF6),HL
	JR	L_113
L_112:
	LD	A,(IX+%F)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF6),HL
L_113:
	LD	BC,511
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	(IX+%FFFFFFEA),HL
	LD	A,(IX+%FFFFFFF6)
	LD	BC,(IX+%FFFFFFED)
	ADD	HL,BC
	LD	(HL),A
; 1235				fs->wflag = 1;
.LINE 1235

	LD	IY,(IX+%6)
	LD	(IY+%3),%1
; 1236				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
.LINE 1236

	LD	HL,(IX+%FFFFFFFA)
	LD	A,%9
	CALL	__ishru_b
	LD	BC,HL
	XOR	A,A
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1237				if (res != FR_OK) break;
.LINE 1237

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_129
; 1238				p = fs->win + bc % SS(fs);
.LINE 1238

	LD	BC,(IX+%FFFFFFEA)
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	(IX+%FFFFFFF0),HL
; 1239				*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
.LINE 1239

	LD	A,(IX+%FFFFFFF9)
	OR	A,A
	JR	NZ,L_118
	LD	BC,(IX+%F)
	LD	A,(IX+%12)
	LD	L,%4
	CALL	__lshru
	LD	A,C
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF3),HL
	JR	L_119
L_118:
	LD	BC,(IX+%10)
	LD	A,C
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF0)
	LD	A,(HL)
	AND	A,%F0
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__ior
	LD	(IX+%FFFFFFF3),HL
L_119:
	LD	A,(IX+%FFFFFFF3)
	LD	HL,(IX+%FFFFFFF0)
	LD	(HL),A
; 1240				fs->wflag = 1;
.LINE 1240

	LD	IY,(IX+%6)
	LD	(IY+%3),%1
; 1241				break;
.LINE 1241

	JR	L_129
; 1242	
; 1243			case FS_FAT16 :
L_120:
.LINE 1243

; 1244				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
.LINE 1244

	LD	BC,(IX+%A)
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1245				if (res != FR_OK) break;
.LINE 1245

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_129
; 1246				st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
.LINE 1246

	LD	BC,(IX+%F)
	PUSH	BC
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_word
	POP	BC
	POP	BC
; 1247				fs->wflag = 1;
.LINE 1247

	LD	IY,(IX+%6)
	LD	(IY+%3),%1
; 1248				break;
.LINE 1248

	JR	L_129
; 1249	
; 1250			case FS_FAT32 :
L_123:
.LINE 1250

; 1251	#if FF_FS_EXFAT
; 1252			case FS_EXFAT :
; 1253	#endif
; 1254				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
.LINE 1254

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%7
	CALL	__lshru
	LD	IY,(IX+%6)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1255				if (res != FR_OK) break;
.LINE 1255

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_129
; 1256				if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
; 1257					val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
.LINE 1257

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	BC,0
	LD	A,%F0
	CALL	__land
	LD	(IX+%FFFFFFE9),E
	LD	(IX+%FFFFFFE6),HL
	LD	HL,(IX+%F)
	LD	E,(IX+%12)
	LD	BC,16777215
	LD	A,%F
	CALL	__land
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFE9)
	LD	HL,(IX+%FFFFFFE6)
	CALL	__lor
	LD	(IX+%F),HL
	LD	(IX+%12),E
; 1258				}
; 1259				st_dword(fs->win + clst * 4 % SS(fs), val);
.LINE 1259

	LD	C,(IX+%12)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%F)
	PUSH	BC
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%6)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 1260				fs->wflag = 1;
.LINE 1260

	LD	IY,(IX+%6)
	LD	(IY+%3),%1
; 1261				break;
; 1262			}
; 1263		}
L_129:
.LINE 1263

; 1264		return res;
.LINE 1264

	LD	HL,(IX+%FFFFFFFD)
; 1265	}
.LINE 1265

	LD	SP,IX
	POP	IX
	RET	


;**************************** _put_fat ***************************
;Name                         Addr/Register   Size   Type
;G_7                                  IX-22      3   variable
;G_6                                  IX-19      3   variable
;p                                    IX-16      3   variable
;temp116                              IX-13      3   variable
;temp110                              IX-10      3   variable
;G_8                                   IX-7      1   variable
;bc                                    IX-6      3   variable
;res                                   IX-3      3   variable
;val                                  IX+15      4   parameter
;clst                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 47 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "put_fat",1265,"_put_fat"
; 1266	
; 1267	#endif /* !FF_FS_READONLY */
; 1268	
; 1269	
; 1270	
; 1271	
; 1272	#if FF_FS_EXFAT && !FF_FS_READONLY
; 1273	/*-----------------------------------------------------------------------*/
; 1274	/* exFAT: Accessing FAT and Allocation Bitmap                            */
; 1275	/*-----------------------------------------------------------------------*/
; 1276	
; 1277	/*--------------------------------------*/
; 1278	/* Find a contiguous free cluster block */
; 1279	/*--------------------------------------*/
; 1280	
; 1281	static DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
; 1282		FATFS* fs,	/* Filesystem object */
; 1283		DWORD clst,	/* Cluster number to scan from */
; 1284		DWORD ncl	/* Number of contiguous clusters to find (1..) */
; 1285	)
; 1286	{
; 1287		BYTE bm, bv;
; 1288		UINT i;
; 1289		DWORD val, scl, ctr;
; 1290	
; 1291	
; 1292		clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
; 1293		if (clst >= fs->n_fatent - 2) clst = 0;
; 1294		scl = val = clst; ctr = 0;
; 1295		while (1) {
; 1296			if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
; 1297			i = val / 8 % SS(fs); bm = 1 << (val % 8);
; 1298			do {
; 1299				do {
; 1300					bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
; 1301					if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
; 1302						val = 0; bm = 0; i = SS(fs);
; 1303					}
; 1304					if (bv == 0) {	/* Is it a free cluster? */
; 1305						if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
; 1306					} else {
; 1307						scl = val; ctr = 0;		/* Encountered a cluster in-use, restart to scan */
; 1308					}
; 1309					if (val == clst) return 0;	/* All cluster scanned? */
; 1310				} while (bm != 0);
; 1311				bm = 1;
; 1312			} while (++i < SS(fs));
; 1313		}
; 1314	}
; 1315	
; 1316	
; 1317	/*----------------------------------------*/
; 1318	/* Set/Clear a block of allocation bitmap */
; 1319	/*----------------------------------------*/
; 1320	
; 1321	static FRESULT change_bitmap (
; 1322		FATFS* fs,	/* Filesystem object */
; 1323		DWORD clst,	/* Cluster number to change from */
; 1324		DWORD ncl,	/* Number of clusters to be changed */
; 1325		int bv		/* bit value to be set (0 or 1) */
; 1326	)
; 1327	{
; 1328		BYTE bm;
; 1329		UINT i;
; 1330		DWORD sect;
; 1331	
; 1332	
; 1333		clst -= 2;	/* The first bit corresponds to cluster #2 */
; 1334		sect = fs->database + clst / 8 / SS(fs);	/* Sector address (assuming bitmap is located top of the cluster heap) */
; 1335		i = clst / 8 % SS(fs);						/* Byte offset in the sector */
; 1336		bm = 1 << (clst % 8);						/* Bit mask in the byte */
; 1337		while (1) {
; 1338			if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
; 1339			do {
; 1340				do {
; 1341					if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
; 1342					fs->win[i] ^= bm;	/* Flip the bit */
; 1343					fs->wflag = 1;
; 1344					if (--ncl == 0) return FR_OK;	/* All bits processed? */
; 1345				} while (bm <<= 1);		/* Next bit */
; 1346				bm = 1;
; 1347			} while (++i < SS(fs));		/* Next byte */
; 1348			i = 0;
; 1349		}
; 1350	}
; 1351	
; 1352	
; 1353	/*---------------------------------------------*/
; 1354	/* Fill the first fragment of the FAT chain    */
; 1355	/*---------------------------------------------*/
; 1356	
; 1357	static FRESULT fill_first_frag (
; 1358		FFOBJID* obj	/* Pointer to the corresponding object */
; 1359	)
; 1360	{
; 1361		FRESULT res;
; 1362		DWORD cl, n;
; 1363	
; 1364	
; 1365		if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
; 1366			for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
; 1367				res = put_fat(obj->fs, cl, cl + 1);
; 1368				if (res != FR_OK) return res;
; 1369			}
; 1370			obj->stat = 0;	/* Change status 'FAT chain is valid' */
; 1371		}
; 1372		return FR_OK;
; 1373	}
; 1374	
; 1375	
; 1376	/*---------------------------------------------*/
; 1377	/* Fill the last fragment of the FAT chain     */
; 1378	/*---------------------------------------------*/
; 1379	
; 1380	static FRESULT fill_last_frag (
; 1381		FFOBJID* obj,	/* Pointer to the corresponding object */
; 1382		DWORD lcl,		/* Last cluster of the fragment */
; 1383		DWORD term		/* Value to set the last FAT entry */
; 1384	)
; 1385	{
; 1386		FRESULT res;
; 1387	
; 1388	
; 1389		while (obj->n_frag > 0) {	/* Create the chain of last fragment */
; 1390			res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
; 1391			if (res != FR_OK) return res;
; 1392			obj->n_frag--;
; 1393		}
; 1394		return FR_OK;
; 1395	}
; 1396	
; 1397	#endif	/* FF_FS_EXFAT && !FF_FS_READONLY */
; 1398	
; 1399	
; 1400	
; 1401	#if !FF_FS_READONLY
; 1402	/*-----------------------------------------------------------------------*/
; 1403	/* FAT handling - Remove a cluster chain                                 */
; 1404	/*-----------------------------------------------------------------------*/
; 1405	
; 1406	static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
; 1407		FFOBJID* obj,		/* Corresponding object */
; 1408		DWORD clst,			/* Cluster to remove a chain from */
; 1409		DWORD pclst			/* Previous cluster of clst (0:entire chain) */
; 1410	)
; 1411	{
_remove_chain:
.DEFINE "_remove_chain"

.VALUE _remove_chain

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "remove_chain",1411,"_remove_chain"

.LINE 1411

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "pclst"

.CLASS 65

.VALUE 15

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "nxt"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF2
	LD	SP,HL
; 1412		FRESULT res = FR_OK;
.LINE 1412

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1413		DWORD nxt;
; 1414		FATFS *fs = obj->fs;
.LINE 1414

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
; 1415	#if FF_FS_EXFAT || FF_USE_TRIM
; 1416		DWORD scl = clst, ecl = clst;
; 1417	#endif
; 1418	#if FF_USE_TRIM
; 1419		DWORD rt[2];
; 1420	#endif
; 1421	
; 1422		if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
.LINE 1422

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_132
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_136
L_132:
	LD	HL,2
	JR	L_153
L_136:
; 1423	
; 1424		/* Mark the previous cluster 'EOC' on the FAT if it exists */
; 1425		if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
.LINE 1425

	LD	HL,(IX+%F)
	LD	E,(IX+%12)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_151
; 1426			res = put_fat(fs, pclst, 0xFFFFFFFF);
.LINE 1426

	LD	BC,255
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	LD	C,(IX+%12)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%F)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_put_fat
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 1427			if (res != FR_OK) return res;
.LINE 1427

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_151
	LD	HL,(IX+%FFFFFFFA)
	JR	L_153
; 1428		}
L_151:
.LINE 1428

; 1429	
; 1430		/* Remove the chain */
; 1431		do {
L_149:
.LINE 1431

; 1432			nxt = get_fat(obj, clst);			/* Get cluster status */
.LINE 1432

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 1433			if (nxt == 0) break;				/* Empty cluster? */
.LINE 1433

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_152
; 1434			if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
.LINE 1434

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_141
	LD	HL,2
	JR	L_153
L_141:
; 1435			if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
.LINE 1435

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_143
	LD	HL,1
	JR	L_153
; 1436			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
L_143:
.LINE 1436

; 1437				res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
.LINE 1437

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_put_fat
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 1438				if (res != FR_OK) return res;
.LINE 1438

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_147
	LD	HL,(IX+%FFFFFFFA)
	JR	L_153
; 1439			}
L_147:
.LINE 1439

; 1440			if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
.LINE 1440

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	LD	(IX+%FFFFFFF2),BC
	LD	(IX+%FFFFFFF5),A
	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	CALL	__lcmpu
	JR	NC,L_148
; 1441				fs->free_clst++;
.LINE 1441

	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%12),HL
	LD	(IY+%15),E
; 1442				fs->fsi_flag |= 1;
.LINE 1442

	LD	A,(IY+%4)
	SET	%0,A
	LD	(IY+%4),A
; 1443			}
L_148:
.LINE 1443

; 1444	#if FF_FS_EXFAT || FF_USE_TRIM
; 1445			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
; 1446				ecl = nxt;
; 1447			} else {				/* End of contiguous cluster block */
; 1448	#if FF_FS_EXFAT
; 1449				if (fs->fs_type == FS_EXFAT) {
; 1450					res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
; 1451					if (res != FR_OK) return res;
; 1452				}
; 1453	#endif
; 1454	#if FF_USE_TRIM
; 1455				rt[0] = clst2sect(fs, scl);					/* Start of data area freed */
; 1456				rt[1] = clst2sect(fs, ecl) + fs->csize - 1;	/* End of data area freed */
; 1457				disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform device the data in the block is no longer needed */
; 1458	#endif
; 1459				scl = ecl = nxt;
; 1460			}
; 1461	#endif
; 1462			clst = nxt;					/* Next cluster */
.LINE 1462

	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	(IX+%9),BC
	LD	(IX+%C),A
; 1463		} while (clst < fs->n_fatent);	/* Repeat while not the last link */
.LINE 1463

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_149
L_152:
; 1464	
; 1465	#if FF_FS_EXFAT
; 1466		/* Some post processes for chain status */
; 1467		if (fs->fs_type == FS_EXFAT) {
; 1468			if (pclst == 0) {	/* Has the entire chain been removed? */
; 1469				obj->stat = 0;		/* Change the chain status 'initial' */
; 1470			} else {
; 1471				if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
; 1472					clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
; 1473					while (clst != pclst) {
; 1474						nxt = get_fat(obj, clst);
; 1475						if (nxt < 2) return FR_INT_ERR;
; 1476						if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
; 1477						if (nxt != clst + 1) break;	/* Not contiguous? */
; 1478						clst++;
; 1479					}
; 1480					if (clst == pclst) {	/* Has the chain got contiguous again? */
; 1481						obj->stat = 2;		/* Change the chain status 'contiguous' */
; 1482					}
; 1483				} else {
; 1484					if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the chain fragmented in this session and got contiguous again? */
; 1485						obj->stat = 2;	/* Change the chain status 'contiguous' */
; 1486					}
; 1487				}
; 1488			}
; 1489		}
; 1490	#endif
; 1491		return FR_OK;
.LINE 1491

	OR	A,A
	SBC	HL,HL
; 1492	}
L_153:
.LINE 1492

	LD	SP,IX
	POP	IX
	RET	


;**************************** _remove_chain ***************************
;Name                         Addr/Register   Size   Type
;G_9                                  IX-14      4   variable
;nxt                                  IX-10      4   variable
;res                                   IX-6      3   variable
;fs                                    IX-3      3   variable
;pclst                                IX+15      4   parameter
;clst                                  IX+9      4   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "remove_chain",1492,"_remove_chain"
; 1493	
; 1494	
; 1495	
; 1496	
; 1497	/*-----------------------------------------------------------------------*/
; 1498	/* FAT handling - Stretch a chain or Create a new chain                  */
; 1499	/*-----------------------------------------------------------------------*/
; 1500	
; 1501	static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
; 1502		FFOBJID* obj,		/* Corresponding object */
; 1503		DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
; 1504	)
; 1505	{
_create_chain:
.DEFINE "_create_chain"

.VALUE _create_chain

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "create_chain",1505,"_create_chain"

.LINE 1505

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "cs"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "ncl"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -11

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "scl"

.CLASS 65

.VALUE -15

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -18

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE6
	LD	SP,HL
; 1506		DWORD cs, ncl, scl;
; 1507		FRESULT res;
; 1508		FATFS *fs = obj->fs;
.LINE 1508

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF5),BC
; 1509	
; 1510	
; 1511		if (clst == 0) {	/* Create a new chain */
.LINE 1511

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_163
; 1512			scl = fs->last_clst;				/* Suggested cluster to start to find */
.LINE 1512

	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%E)
	LD	A,(IY+%11)
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
; 1513			if (scl == 0 || scl >= fs->n_fatent) scl = 1;
.LINE 1513

	LD	HL,BC
	LD	E,(IX+%FFFFFFF4)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_155
	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_165
L_155:
	LD	BC,1
	XOR	A,A
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
; 1514		}
; 1515		else {				/* Stretch a chain */
.LINE 1515

	JR	L_165
L_163:
; 1516			cs = get_fat(obj, clst);			/* Check the cluster status */
.LINE 1516

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1517			if (cs < 2) return 1;				/* Test for insanity */
.LINE 1517

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_158
	LD	HL,1
	LD	E,%0
	JR	L_205
L_158:
; 1518			if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
.LINE 1518

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_160
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	JR	L_205
L_160:
; 1519			if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
.LINE 1519

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	NC,L_161
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	JR	L_205
L_161:
; 1520			scl = clst;							/* Cluster to start to find */
.LINE 1520

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
; 1521		}
L_165:
.LINE 1521

; 1522		if (fs->free_clst == 0) return 0;		/* No free cluster */
.LINE 1522

	LD	IY,(IX+%FFFFFFF5)
	LD	HL,(IY+%12)
	LD	E,(IY+%15)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_193
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	JR	L_205
L_193:
; 1523	
; 1524	#if FF_FS_EXFAT
; 1525		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 1526			ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
; 1527			if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
; 1528			res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
; 1529			if (res == FR_INT_ERR) return 1;
; 1530			if (res == FR_DISK_ERR) return 0xFFFFFFFF;
; 1531			if (clst == 0) {							/* Is it a new chain? */
; 1532				obj->stat = 2;							/* Set status 'contiguous' */
; 1533			} else {									/* It is a stretched chain */
; 1534				if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
; 1535					obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
; 1536					obj->stat = 3;						/* Change status 'just fragmented' */
; 1537				}
; 1538			}
; 1539			if (obj->stat != 2) {	/* Is the file non-contiguous? */
; 1540				if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
; 1541					obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
; 1542				} else {				/* New fragment */
; 1543					if (obj->n_frag == 0) obj->n_frag = 1;
; 1544					res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
; 1545					if (res == FR_OK) obj->n_frag = 1;
; 1546				}
; 1547			}
; 1548		} else
; 1549	#endif
; 1550		{	/* On the FAT/FAT32 volume */
; 1551			ncl = 0;
.LINE 1551

	XOR	A,A
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
; 1552			if (scl == clst) {						/* Stretching an existing chain? */
.LINE 1552

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	NZ,L_189
; 1553				ncl = scl + 1;						/* Test if next cluster is free */
.LINE 1553

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
; 1554				if (ncl >= fs->n_fatent) ncl = 2;
.LINE 1554

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_167
	LD	BC,2
	XOR	A,A
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
L_167:
; 1555				cs = get_fat(obj, ncl);				/* Get next cluster status */
.LINE 1555

	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1556				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
.LINE 1556

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_169
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_174
L_169:
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	JR	L_205
L_174:
; 1557				if (cs != 0) {						/* Not free? */
.LINE 1557

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_189
; 1558					cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
.LINE 1558

	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%E)
	LD	A,(IY+%11)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1559					if (cs >= 2 && cs < fs->n_fatent) scl = cs;
.LINE 1559

	LD	HL,BC
	LD	E,(IX+%FFFFFFFF)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_172
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	NC,L_172
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
L_172:
; 1560					ncl = 0;
.LINE 1560

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
; 1561				}
; 1562			}
L_189:
.LINE 1562

; 1563			if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
.LINE 1563

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_190
; 1564				ncl = scl;	/* Start cluster */
.LINE 1564

	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
; 1565				while (1) {
L_187:
.LINE 1565

; 1566					ncl++;							/* Next cluster */
.LINE 1566

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
; 1567					if (ncl >= fs->n_fatent) {		/* Check wrap-around */
.LINE 1567

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	IY,(IX+%FFFFFFF5)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_179
; 1568						ncl = 2;
.LINE 1568

	LD	BC,2
	XOR	A,A
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
; 1569						if (ncl > scl) return 0;	/* No free cluster found? */
.LINE 1569

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_179
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	JR	L_205
; 1570					}
L_179:
.LINE 1570

; 1571					cs = get_fat(obj, ncl);			/* Get the cluster status */
.LINE 1571

	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1572					if (cs == 0) break;				/* Found a free cluster? */
.LINE 1572

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_190
; 1573					if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
.LINE 1573

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_182
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_185
L_182:
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	JR	L_205
L_185:
; 1574					if (ncl == scl) return 0;		/* No free cluster found? */
.LINE 1574

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	CALL	__lcmpu
	JR	NZ,L_187
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	JR	L_205
; 1575				}
.LINE 1575

; 1576			}
L_190:
.LINE 1576

; 1577			res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
.LINE 1577

	LD	BC,255
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	CALL	_put_fat
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEE),HL
; 1578			if (res == FR_OK && clst != 0) {
.LINE 1578

	LD	BC,0
	LD	HL,(IX+%FFFFFFEE)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_203
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_203
; 1579				res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
.LINE 1579

	LD	C,(IX+%FFFFFFFB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	CALL	_put_fat
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEE),HL
; 1580			}
; 1581		}
L_203:
.LINE 1581

; 1582	
; 1583		if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
.LINE 1583

	LD	BC,0
	LD	HL,(IX+%FFFFFFEE)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_202
; 1584			fs->last_clst = ncl;
.LINE 1584

	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	LD	IY,(IX+%FFFFFFF5)
	LD	(IY+%E),BC
	LD	(IY+%11),A
; 1585			if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
.LINE 1585

	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	LD	(IX+%FFFFFFEA),BC
	LD	(IX+%FFFFFFED),A
	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	BC,(IX+%FFFFFFEA)
	LD	A,(IX+%FFFFFFED)
	CALL	__lcmpu
	JR	C,L_196
	LD	HL,(IX+%FFFFFFEA)
	LD	E,(IX+%FFFFFFED)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	IY,(IX+%FFFFFFF5)
	LD	(IY+%12),HL
	LD	(IY+%15),E
L_196:
; 1586			fs->fsi_flag |= 1;
.LINE 1586

	LD	IY,(IX+%FFFFFFF5)
	LD	A,(IY+%4)
	SET	%0,A
	LD	(IY+%4),A
; 1587		} else {
.LINE 1587

	JR	L_204
L_202:
; 1588			ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
.LINE 1588

	LD	BC,1
	LD	HL,(IX+%FFFFFFEE)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_199
	LD	BC,16777215
	LD	A,%FF
	LD	(IX+%FFFFFFE6),BC
	LD	(IX+%FFFFFFE9),A
	JR	L_200
L_199:
	XOR	A,A
	LD	(IX+%FFFFFFE6),BC
	LD	(IX+%FFFFFFE9),A
L_200:
	LD	BC,(IX+%FFFFFFE6)
	LD	A,(IX+%FFFFFFE9)
	LD	(IX+%FFFFFFF8),BC
	LD	(IX+%FFFFFFFB),A
; 1589		}
L_204:
.LINE 1589

; 1590	
; 1591		return ncl;		/* Return new cluster number or error status */
.LINE 1591

	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
; 1592	}
L_205:
.LINE 1592

	LD	SP,IX
	POP	IX
	RET	


;**************************** _create_chain ***************************
;Name                         Addr/Register   Size   Type
;temp197                              IX-26      4   variable
;G_10                                 IX-22      4   variable
;res                                  IX-18      3   variable
;scl                                  IX-15      4   variable
;fs                                   IX-11      3   variable
;ncl                                   IX-8      4   variable
;cs                                    IX-4      4   variable
;clst                                  IX+9      4   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "create_chain",1592,"_create_chain"
; 1593	
; 1594	#endif /* !FF_FS_READONLY */
; 1595	
; 1596	
; 1597	
; 1598	
; 1599	#if FF_USE_FASTSEEK
; 1600	/*-----------------------------------------------------------------------*/
; 1601	/* FAT handling - Convert offset into cluster with link map table        */
; 1602	/*-----------------------------------------------------------------------*/
; 1603	
; 1604	static DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
; 1605		FIL* fp,		/* Pointer to the file object */
; 1606		FSIZE_t ofs		/* File offset to be converted to cluster# */
; 1607	)
; 1608	{
; 1609		DWORD cl, ncl, *tbl;
; 1610		FATFS *fs = fp->obj.fs;
; 1611	
; 1612	
; 1613		tbl = fp->cltbl + 1;	/* Top of CLMT */
; 1614		cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
; 1615		while (1) {
; 1616			ncl = *tbl++;			/* Number of cluters in the fragment */
; 1617			if (ncl == 0) return 0;	/* End of table? (error) */
; 1618			if (cl < ncl) break;	/* In this fragment? */
; 1619			cl -= ncl; tbl++;		/* Next fragment */
; 1620		}
; 1621		return cl + *tbl;	/* Return the cluster number */
; 1622	}
; 1623	
; 1624	#endif	/* FF_USE_FASTSEEK */
; 1625	
; 1626	
; 1627	
; 1628	
; 1629	/*-----------------------------------------------------------------------*/
; 1630	/* Directory handling - Fill a cluster with zeros                        */
; 1631	/*-----------------------------------------------------------------------*/
; 1632	
; 1633	#if !FF_FS_READONLY
; 1634	static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
; 1635		FATFS *fs,		/* Filesystem object */
; 1636		DWORD clst		/* Directory table to clear */
; 1637	)
; 1638	{
_dir_clear:
.DEFINE "_dir_clear"

.VALUE _dir_clear

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_clear",1638,"_dir_clear"

.LINE 1638

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "ibuf"

.CLASS 65

.VALUE -9

.TYPE 44

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE -13

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
; 1639		DWORD sect;
; 1640		UINT n, szb;
; 1641		BYTE *ibuf;
; 1642	
; 1643	
; 1644		if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
.LINE 1644

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_sync_window
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_207
	LD	HL,1
	JR	L_217
L_207:
; 1645		sect = clst2sect(fs, clst);		/* Top of the cluster */
.LINE 1645

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
; 1646		fs->winsect = sect;				/* Set window to top of the cluster */
.LINE 1646

	LD	A,(IX+%FFFFFFF6)
	LD	IY,(IX+%6)
	LD	(IY+%32),HL
	LD	(IY+%35),A
; 1647		mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
.LINE 1647

	LD	BC,512
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PEA	IY+%36
	CALL	_mem_set
	POP	BC
	POP	BC
	POP	BC
; 1648	#if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
; 1649		/* Allocate a temporary buffer */
; 1650		for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
; 1651		if (szb > SS(fs)) {		/* Buffer allocated? */
; 1652			mem_set(ibuf, 0, szb);
; 1653			szb /= SS(fs);		/* Bytes -> Sectors */
; 1654			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
; 1655			ff_memfree(ibuf);
; 1656		} else
; 1657	#endif
; 1658		{
; 1659			ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
.LINE 1659

	LD	IY,(IX+%6)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFF7),BC
; 1660			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
.LINE 1660

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_211
L_209:
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_211:
	LD	IY,(IX+%6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_216
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	XOR	A,A
	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_209
; 1661		}
L_216:
.LINE 1661

; 1662		return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
.LINE 1662

	LD	IY,(IX+%6)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_214
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_215
L_214:
	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
L_215:
	LD	HL,(IX+%FFFFFFFA)
; 1663	}
L_217:
.LINE 1663

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_clear ***************************
;Name                         Addr/Register   Size   Type
;_disk_write                         IMPORT  -----   function
;sect                                 IX-13      4   variable
;ibuf                                  IX-9      3   variable
;temp212                               IX-6      3   variable
;n                                     IX-3      3   variable
;clst                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 28 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_clear",1663,"_dir_clear"
; 1664	#endif	/* !FF_FS_READONLY */
; 1665	
; 1666	
; 1667	
; 1668	
; 1669	/*-----------------------------------------------------------------------*/
; 1670	/* Directory handling - Set directory index                              */
; 1671	/*-----------------------------------------------------------------------*/
; 1672	
; 1673	static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
; 1674		DIR* dp,		/* Pointer to directory object */
; 1675		DWORD ofs		/* Offset of directory table */
; 1676	)
; 1677	{
_dir_sdi:
.DEFINE "_dir_sdi"

.VALUE _dir_sdi

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_sdi",1677,"_dir_sdi"

.LINE 1677

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -7

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "csz"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 1678		DWORD csz, clst;
; 1679		FATFS *fs = dp->obj.fs;
.LINE 1679

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
; 1680	
; 1681	
; 1682		if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
.LINE 1682

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,2097152
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_219
	LD	A,(IX+%9)
	AND	A,%1F
	UEXT	HL
	LD	L,A
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_220
L_219:
; 1683			return FR_INT_ERR;
.LINE 1683

	LD	HL,2
	JR	L_240
; 1684		}
L_220:
.LINE 1684

; 1685		dp->dptr = ofs;				/* Set current offset */
.LINE 1685

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%F),BC
	LD	(IY+%12),A
; 1686		clst = dp->obj.sclust;		/* Table start cluster (0:root) */
.LINE 1686

	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1687		if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
.LINE 1687

	LD	HL,BC
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_236
	LD	IY,(IX+%FFFFFFF9)
	LD	A,(IY+%0)
	CP	A,%3
	JR	C,L_236
; 1688			clst = fs->dirbase;
.LINE 1688

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%2A)
	LD	A,(IY+%2D)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1689			if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
; 1690		}
L_236:
.LINE 1690

; 1691	
; 1692		if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
.LINE 1692

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_235
; 1693			if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
.LINE 1693

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	(IX+%FFFFFFF2),HL
	LD	B,%0
	LD	(IX+%FFFFFFF0),B	; spill
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%5
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	B,(IX+%FFFFFFF0)	; unspill
	LD	A,B
	LD	BC,(IX+%FFFFFFF2)
	CALL	__lcmpu
	JR	C,L_225
	LD	HL,2
	JR	L_240
L_225:
; 1694			dp->sect = fs->dirbase;
.LINE 1694

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%2A)
	LD	A,(IY+%2D)
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),A
; 1695	
; 1696		} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
.LINE 1696

	JR	L_237
L_235:
; 1697			csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
.LINE 1697

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	E,%0
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1698			while (ofs >= csz) {				/* Follow cluster chain */
.LINE 1698

	JR	L_231
L_232:
; 1699				clst = get_fat(&dp->obj, clst);				/* Get next cluster */
.LINE 1699

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1700				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
.LINE 1700

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_229
	LD	HL,1
	JR	L_240
L_229:
; 1701				if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
.LINE 1701

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_228
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_230
L_228:
	LD	HL,2
	JR	L_240
L_230:
; 1702				ofs -= csz;
.LINE 1702

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
; 1703			}
L_231:
.LINE 1703

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lcmpu
	JR	NC,L_232
; 1704			dp->sect = clst2sect(fs, clst);
.LINE 1704

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1705		}
L_237:
.LINE 1705

; 1706		dp->clust = clst;					/* Current cluster# */
.LINE 1706

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%13),BC
	LD	(IY+%16),A
; 1707		if (dp->sect == 0) return FR_INT_ERR;
.LINE 1707

	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_239
	LD	HL,2
	JR	L_240
L_239:
; 1708		dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
.LINE 1708

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%9
	CALL	__lshru
	LD	IY,(IX+%6)
	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	CALL	__ladd
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1709		dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
.LINE 1709

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFF9)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	IY,(IX+%6)
	LD	(IY+%1B),HL
; 1710	
; 1711		return FR_OK;
.LINE 1711

	OR	A,A
	SBC	HL,HL
; 1712	}
L_240:
.LINE 1712

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_sdi ***************************
;Name                         Addr/Register   Size   Type
;csz                                  IX-11      4   variable
;fs                                    IX-7      3   variable
;clst                                  IX-4      4   variable
;ofs                                   IX+9      4   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_sdi",1712,"_dir_sdi"
; 1713	
; 1714	
; 1715	
; 1716	
; 1717	/*-----------------------------------------------------------------------*/
; 1718	/* Directory handling - Move directory table index next                  */
; 1719	/*-----------------------------------------------------------------------*/
; 1720	
; 1721	static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
; 1722		DIR* dp,				/* Pointer to the directory object */
; 1723		int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
; 1724	)
; 1725	{
_dir_next:
.DEFINE "_dir_next"

.VALUE _dir_next

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_next",1725,"_dir_next"

.LINE 1725

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "stretch"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -7

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE5
	LD	SP,HL
; 1726		DWORD ofs, clst;
; 1727		FATFS *fs = dp->obj.fs;
.LINE 1727

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
; 1728	
; 1729	
; 1730		ofs = dp->dptr + SZDIRE;	/* Next entry */
.LINE 1730

	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	LD	A,%20
	CALL	__ladd_b
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1731		if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
.LINE 1731

	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF4)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_242
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,2097152
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_266
L_242:
	LD	HL,4
	JR	L_268
L_266:
; 1732	
; 1733		if (ofs % SS(fs) == 0) {	/* Sector changed? */
.LINE 1733

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_267
; 1734			dp->sect++;				/* Next sector */
.LINE 1734

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1735	
; 1736			if (dp->clust == 0) {	/* Static table */
.LINE 1736

	LD	BC,(IY+%13)
	LD	A,(IY+%16)
	LD	(IX+%FFFFFFED),BC
	LD	(IX+%FFFFFFF0),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF0)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_264
; 1737				if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
.LINE 1737

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	(IX+%FFFFFFE7),HL
	LD	B,%0
	LD	(IX+%FFFFFFE5),B	; spill
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%5
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	B,(IX+%FFFFFFE5)	; unspill
	LD	A,B
	LD	BC,(IX+%FFFFFFE7)
	CALL	__lcmpu
	JR	C,L_267
; 1738					dp->sect = 0; return FR_NO_FILE;
.LINE 1738

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
	LD	HL,4
	JR	L_268
; 1739				}
; 1740			}
; 1741			else {					/* Dynamic table */
L_264:
.LINE 1741

; 1742				if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
.LINE 1742

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%9)
	CALL	__stoiu
	DEC	HL
	LD	BC,HL
	CALL	__itol
	LD	(IX+%FFFFFFEA),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%9
	CALL	__lshru
	LD	HL,(IX+%FFFFFFEA)
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_267
; 1743					clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
.LINE 1743

	LD	C,(IX+%FFFFFFF0)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),E
; 1744					if (clst <= 1) return FR_INT_ERR;			/* Internal error */
.LINE 1744

	LD	HL,1
	LD	E,%0
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_247
	LD	HL,2
	JR	L_268
L_247:
; 1745					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
.LINE 1745

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_260
	LD	HL,1
	JR	L_268
L_260:
; 1746					if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
.LINE 1746

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_261
; 1747	#if !FF_FS_READONLY
; 1748						if (!stretch) {								/* If no stretch, report EOT */
.LINE 1748

	LD	BC,0
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_249
; 1749							dp->sect = 0; return FR_NO_FILE;
.LINE 1749

	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
	LD	HL,4
	JR	L_268
; 1750						}
L_249:
.LINE 1750

; 1751						clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
.LINE 1751

	LD	IY,(IX+%6)
	LD	BC,(IY+%13)
	LD	A,(IY+%16)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%0
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1752						if (clst == 0) return FR_DENIED;			/* No free cluster */
.LINE 1752

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_252
	LD	HL,7
	JR	L_268
L_252:
; 1753						if (clst == 1) return FR_INT_ERR;			/* Internal error */
.LINE 1753

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_254
	LD	HL,2
	JR	L_268
L_254:
; 1754						if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
.LINE 1754

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_256
	LD	HL,1
	JR	L_268
L_256:
; 1755						if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
.LINE 1755

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_dir_clear
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_261
	LD	HL,1
	JR	L_268
; 1756						if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
; 1757	#else
; 1758						if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
; 1759						dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
; 1760	#endif
; 1761					}
L_261:
.LINE 1761

; 1762					dp->clust = clst;		/* Initialize data for new cluster */
.LINE 1762

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%13),BC
	LD	(IY+%16),A
; 1763					dp->sect = clst2sect(fs, clst);
.LINE 1763

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%17),HL
	LD	(IY+%1A),E
; 1764				}
; 1765			}
; 1766		}
L_267:
.LINE 1766

; 1767		dp->dptr = ofs;						/* Current entry */
.LINE 1767

	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	IY,(IX+%6)
	LD	(IY+%F),BC
	LD	(IY+%12),A
; 1768		dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
.LINE 1768

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFF9)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	IY,(IX+%6)
	LD	(IY+%1B),HL
; 1769	
; 1770		return FR_OK;
.LINE 1770

	OR	A,A
	SBC	HL,HL
; 1771	}
L_268:
.LINE 1771

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_next ***************************
;Name                         Addr/Register   Size   Type
;G_12                                 IX-19      4   variable
;G_11                                 IX-15      4   variable
;ofs                                  IX-11      4   variable
;fs                                    IX-7      3   variable
;clst                                  IX-4      4   variable
;stretch                               IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_next",1771,"_dir_next"
; 1772	
; 1773	
; 1774	
; 1775	
; 1776	#if !FF_FS_READONLY
; 1777	/*-----------------------------------------------------------------------*/
; 1778	/* Directory handling - Reserve a block of directory entries             */
; 1779	/*-----------------------------------------------------------------------*/
; 1780	
; 1781	static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
; 1782		DIR* dp,				/* Pointer to the directory object */
; 1783		UINT nent				/* Number of contiguous entries to allocate */
; 1784	)
; 1785	{
_dir_alloc:
.DEFINE "_dir_alloc"

.VALUE _dir_alloc

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_alloc",1785,"_dir_alloc"

.LINE 1785

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "nent"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -12

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 1786		FRESULT res;
; 1787		UINT n;
; 1788		FATFS *fs = dp->obj.fs;
.LINE 1788

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF4),BC
; 1789	
; 1790	
; 1791		res = dir_sdi(dp, 0);
.LINE 1791

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1792		if (res == FR_OK) {
.LINE 1792

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_280
; 1793			n = 0;
.LINE 1793

	LD	(IX+%FFFFFFFA),BC
; 1794			do {
L_276:
.LINE 1794

; 1795				res = move_window(fs, dp->sect);
.LINE 1795

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1796				if (res != FR_OK) break;
.LINE 1796

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_280
; 1797	#if FF_FS_EXFAT
; 1798				if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
; 1799	#else
; 1800				if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
.LINE 1800

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFF7),BC
	LD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,229
	OR	A,A
	SBC	HL,BC
	JR	Z,L_272
	LD	HL,(IX+%FFFFFFF7)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_273
L_272:
; 1801	#endif
; 1802					if (++n == nent) break;	/* A block of contiguous free entries is found */
.LINE 1802

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_280
	JR	L_275
; 1803				} else {
L_273:
.LINE 1803

; 1804					n = 0;					/* Not a blank entry. Restart to search */
.LINE 1804

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1805				}
L_275:
.LINE 1805

; 1806				res = dir_next(dp, 1);
.LINE 1806

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1807			} while (res == FR_OK);	/* Next entry with table stretch enabled */
.LINE 1807

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_276
; 1808		}
L_280:
.LINE 1808

; 1809	
; 1810		if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
.LINE 1810

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_281
	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
L_281:
; 1811		return res;
.LINE 1811

	LD	HL,(IX+%FFFFFFFD)
; 1812	}
.LINE 1812

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_alloc ***************************
;Name                         Addr/Register   Size   Type
;fs                                   IX-12      3   variable
;G_13                                  IX-9      3   variable
;n                                     IX-6      3   variable
;res                                   IX-3      3   variable
;nent                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_alloc",1812,"_dir_alloc"
; 1813	
; 1814	#endif	/* !FF_FS_READONLY */
; 1815	
; 1816	
; 1817	
; 1818	
; 1819	/*-----------------------------------------------------------------------*/
; 1820	/* FAT: Directory handling - Load/Store start cluster number             */
; 1821	/*-----------------------------------------------------------------------*/
; 1822	
; 1823	static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
; 1824		FATFS* fs,			/* Pointer to the fs object */
; 1825		const BYTE* dir		/* Pointer to the key entry */
; 1826	)
; 1827	{
_ld_clust:
.DEFINE "_ld_clust"

.VALUE _ld_clust

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "ld_clust",1827,"_ld_clust"

.LINE 1827

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 204

.ENDEF

.DEFINE "cl"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
; 1828		DWORD cl;
; 1829	
; 1830		cl = ld_word(dir + DIR_FstClusLO);
.LINE 1830

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),A
; 1831		if (fs->fs_type == FS_FAT32) {
.LINE 1831

	LD	IY,(IX+%6)
	LD	A,(IY+%0)
	CP	A,%3
	JR	NZ,L_284
; 1832			cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
.LINE 1832

	LD	IY,(IX+%9)
	LEA	BC,IY+%14
	PUSH	BC
	LD	(IX+%FFFFFFFB),A
	CALL	_ld_word
	LD	A,(IX+%FFFFFFFB)
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	PUSH	HL
	PUSH	HL
	UEXT	HL
	PUSH	HL
	INC	SP
	POP	HL
	POP	BC
	INC	SP
	INC	SP
	LD	E,C
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lor
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1833		}
L_284:
.LINE 1833

; 1834	
; 1835		return cl;
.LINE 1835

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 1836	}
.LINE 1836

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ld_clust ***************************
;Name                         Addr/Register   Size   Type
;cl                                    IX-4      4   variable
;dir                                   IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "ld_clust",1836,"_ld_clust"
; 1837	
; 1838	
; 1839	#if !FF_FS_READONLY
; 1840	static void st_clust (
; 1841		FATFS* fs,	/* Pointer to the fs object */
; 1842		BYTE* dir,	/* Pointer to the key entry */
; 1843		DWORD cl	/* Value to be set */
; 1844	)
; 1845	{
_st_clust:
.DEFINE "_st_clust"

.VALUE _st_clust

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "st_clust",1845,"_st_clust"

.LINE 1845

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "cl"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1846		st_word(dir + DIR_FstClusLO, (WORD)cl);
.LINE 1846

	LD	BC,(IX+%C)
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_st_word
	POP	BC
	POP	BC
; 1847		if (fs->fs_type == FS_FAT32) {
.LINE 1847

	LD	IY,(IX+%6)
	LD	A,(IY+%0)
	CP	A,%3
	JR	NZ,L_287
; 1848			st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
.LINE 1848

	UEXT	HL
	PUSH	HL
	LD	BC,(IX+%D)
	PUSH	BC
	INC	SP
	POP	BC
	INC	SP
	INC	SP
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	BC,IY+%14
	PUSH	BC
	CALL	_st_word
	POP	BC
	POP	BC
; 1849		}
; 1850	}
L_287:
.LINE 1850

	LD	SP,IX
	POP	IX
	RET	


;**************************** _st_clust ***************************
;Name                         Addr/Register   Size   Type
;cl                                   IX+12      4   parameter
;dir                                   IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "st_clust",1850,"_st_clust"
; 1851	#endif
; 1852	
; 1853	
; 1854	
; 1855	#if FF_USE_LFN
; 1856	/*--------------------------------------------------------*/
; 1857	/* FAT-LFN: Compare a part of file name with an LFN entry */
; 1858	/*--------------------------------------------------------*/
; 1859	
; 1860	static int cmp_lfn (		/* 1:matched, 0:not matched */
; 1861		const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
; 1862		BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
; 1863	)
; 1864	{
_cmp_lfn:
.DEFINE "_cmp_lfn"

.VALUE _cmp_lfn

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "cmp_lfn",1864,"_cmp_lfn"

.LINE 1864

.DEFINE "lfnbuf"

.CLASS 65

.VALUE 6

.TYPE 205

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF2
	LD	SP,HL
; 1865		UINT i, s;
; 1866		WCHAR wc, uc;
; 1867	
; 1868	
; 1869		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
.LINE 1869

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD.LIS	BC,0
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_289
	OR	A,A
	SBC	HL,HL
	JR	L_306
L_289:
; 1870	
; 1871		i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
.LINE 1871

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%3F
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,%D
	CALL	__imul_b
	LD	(IX+%FFFFFFFD),HL
; 1872	
; 1873		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
.LINE 1873

	LD	(IX+%FFFFFFF8),%1
	LD	(IX+%FFFFFFF9),%0
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_300
L_298:
; 1874			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
.LINE 1874

	LD	BC,_LfnOfs
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF6),L
	LD	(IX+%FFFFFFF7),H
; 1875			if (wc != 0) {
.LINE 1875

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_297
; 1876				if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
.LINE 1876

	LD	BC,255
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_293
	LD	HL,(IX+%FFFFFFFD)
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_wtoupper
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF5),E
	LD	(IX+%FFFFFFF2),HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_wtoupper
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFF5)
	LD	HL,(IX+%FFFFFFF2)
	CALL	__lcmpu
	JR	Z,L_294
L_293:
; 1877					return 0;					/* Not matched */
.LINE 1877

	OR	A,A
	SBC	HL,HL
	JR	L_306
; 1878				}
L_294:
.LINE 1878

; 1879				wc = uc;
.LINE 1879

	LD	BC,(IX+%FFFFFFF6)
	LD	(IX+%FFFFFFF8),C
	LD	(IX+%FFFFFFF9),B
; 1880			} else {
.LINE 1880

	JR	L_299
L_297:
; 1881				if (uc != 0xFFFF) return 0;		/* Check filler */
.LINE 1881

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_299
	OR	A,A
	SBC	HL,HL
	JR	L_306
; 1882			}
; 1883		}
L_299:
.LINE 1883

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_300:
	LD	BC,13
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_298
; 1884	
; 1885		if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
.LINE 1885

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%40
	JR	Z,L_305
	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_305
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD.LIS	BC,0
	LD	HL,(HL)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_305
	OR	A,A
	SBC	HL,HL
	JR	L_306
L_305:
; 1886	
; 1887		return 1;		/* The part of LFN matched */
.LINE 1887

	LD	HL,1
; 1888	}
L_306:
.LINE 1888

	LD	SP,IX
	POP	IX
	RET	


;**************************** _cmp_lfn ***************************
;Name                         Addr/Register   Size   Type
;_ff_wtoupper                        IMPORT  -----   function
;_LfnOfs                             STATIC     13   variable
;uc                                   IX-10      2   variable
;wc                                    IX-8      2   variable
;s                                     IX-6      3   variable
;i                                     IX-3      3   variable
;dir                                   IX+9      3   parameter
;lfnbuf                                IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "cmp_lfn",1888,"_cmp_lfn"
; 1889	
; 1890	
; 1891	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
; 1892	/*-----------------------------------------------------*/
; 1893	/* FAT-LFN: Pick a part of file name from an LFN entry */
; 1894	/*-----------------------------------------------------*/
; 1895	
; 1896	static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
; 1897		WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
; 1898		BYTE* dir			/* Pointer to the LFN entry */
; 1899	)
; 1900	{
_pick_lfn:
.DEFINE "_pick_lfn"

.VALUE _pick_lfn

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "pick_lfn",1900,"_pick_lfn"

.LINE 1900

.DEFINE "lfnbuf"

.CLASS 65

.VALUE 6

.TYPE 45

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
; 1901		UINT i, s;
; 1902		WCHAR wc, uc;
; 1903	
; 1904	
; 1905		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
.LINE 1905

	LD	IY,(IX+%9)
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD.LIS	BC,0
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_308
	OR	A,A
	SBC	HL,HL
	JR	L_324
L_308:
; 1906	
; 1907		i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
.LINE 1907

	LD	HL,(IX+%9)
	LD	A,(HL)
	RES	%6,A
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,%D
	CALL	__imul_b
	LD	(IX+%FFFFFFFD),HL
; 1908	
; 1909		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
.LINE 1909

	LD	(IX+%FFFFFFF6),%1
	LD	(IX+%FFFFFFF7),%0
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_318
L_316:
; 1910			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
.LINE 1910

	LD	BC,_LfnOfs
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFF8),L
	LD	(IX+%FFFFFFF9),H
; 1911			if (wc != 0) {
.LINE 1911

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_315
; 1912				if (i >= FF_MAX_LFN) return 0;	/* Buffer overflow? */
.LINE 1912

	LD	BC,255
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_312
	OR	A,A
	SBC	HL,HL
	JR	L_324
L_312:
; 1913				lfnbuf[i++] = wc = uc;			/* Store it */
.LINE 1913

	LD	BC,(IX+%FFFFFFF8)
	LD	(IX+%FFFFFFF6),C
	LD	(IX+%FFFFFFF7),B
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IX+%FFFFFFF8)
	LD	(HL),A
	INC	HL
	LD	A,(IX+%FFFFFFF9)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 1914			} else {
.LINE 1914

	JR	L_317
L_315:
; 1915				if (uc != 0xFFFF) return 0;		/* Check filler */
.LINE 1915

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_317
	OR	A,A
	SBC	HL,HL
	JR	L_324
; 1916			}
; 1917		}
L_317:
.LINE 1917

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_318:
	LD	BC,13
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_316
; 1918	
; 1919		if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
.LINE 1919

	LD	HL,(IX+%9)
	LD	A,(HL)
	AND	A,%40
	JR	Z,L_323
; 1920			if (i >= FF_MAX_LFN) return 0;		/* Buffer overflow? */
.LINE 1920

	LD	BC,255
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_320
	OR	A,A
	SBC	HL,HL
	JR	L_324
L_320:
; 1921			lfnbuf[i] = 0;
.LINE 1921

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 1922		}
L_323:
.LINE 1922

; 1923	
; 1924		return 1;		/* The part of LFN is valid */
.LINE 1924

	LD	HL,1
; 1925	}
L_324:
.LINE 1925

	LD	SP,IX
	POP	IX
	RET	


;**************************** _pick_lfn ***************************
;Name                         Addr/Register   Size   Type
;_LfnOfs                             STATIC     13   variable
;wc                                   IX-10      2   variable
;uc                                    IX-8      2   variable
;s                                     IX-6      3   variable
;i                                     IX-3      3   variable
;dir                                   IX+9      3   parameter
;lfnbuf                                IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "pick_lfn",1925,"_pick_lfn"
; 1926	#endif
; 1927	
; 1928	
; 1929	#if !FF_FS_READONLY
; 1930	/*-----------------------------------------*/
; 1931	/* FAT-LFN: Create an entry of LFN entries */
; 1932	/*-----------------------------------------*/
; 1933	
; 1934	static void put_lfn (
; 1935		const WCHAR* lfn,	/* Pointer to the LFN */
; 1936		BYTE* dir,			/* Pointer to the LFN entry to be created */
; 1937		BYTE ord,			/* LFN order (1-20) */
; 1938		BYTE sum			/* Checksum of the corresponding SFN */
; 1939	)
; 1940	{
_put_lfn:
.DEFINE "_put_lfn"

.VALUE _put_lfn

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "put_lfn",1940,"_put_lfn"

.LINE 1940

.DEFINE "lfn"

.CLASS 65

.VALUE 6

.TYPE 205

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "ord"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE 15

.TYPE 12

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -5

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -8

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
; 1941		UINT i, s;
; 1942		WCHAR wc;
; 1943	
; 1944	
; 1945		dir[LDIR_Chksum] = sum;			/* Set checksum */
.LINE 1945

	LD	IY,(IX+%9)
	LEA	HL,IY+%D
	LD	A,(IX+%F)
	LD	(HL),A
; 1946		dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
.LINE 1946

	LEA	HL,IY+%B
	LD	(HL),%F
; 1947		dir[LDIR_Type] = 0;
.LINE 1947

	LEA	HL,IY+%C
	LD	(HL),%0
; 1948		st_word(dir + LDIR_FstClusLO, 0);
.LINE 1948

	LD	BC,0
	PUSH	BC
	LEA	BC,IY+%1A
	PUSH	BC
	CALL	_st_word
	POP	BC
	POP	BC
; 1949	
; 1950		i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
.LINE 1950

	LD	A,(IX+%C)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,%D
	CALL	__imul_b
	LD	(IX+%FFFFFFF8),HL
; 1951		s = wc = 0;
.LINE 1951

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	LD	BC,0
	LD	(IX+%FFFFFFFB),BC
; 1952		do {
L_329:
.LINE 1952

; 1953			if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
.LINE 1953

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_327
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFE),C
	LD	(IX+%FFFFFFFF),B
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
L_327:
; 1954			st_word(dir + LfnOfs[s], wc);		/* Put it */
.LINE 1954

	LD	BC,(IX+%FFFFFFFE)
	PUSH	BC
	LD	BC,_LfnOfs
	LD	HL,(IX+%FFFFFFFB)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%9)
	ADD	HL,BC
	PUSH	HL
	CALL	_st_word
	POP	BC
	POP	BC
; 1955			if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
.LINE 1955

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_330
	LD	(IX+%FFFFFFFE),%FF
	LD	(IX+%FFFFFFFF),%FF
; 1956		} while (++s < 13);
L_330:
.LINE 1956

	LD	BC,(IX+%FFFFFFFB)
	INC	BC
	LD	(IX+%FFFFFFFB),BC
	LD	BC,13
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	C,L_329
; 1957		if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
.LINE 1957

	LD.LIS	BC,65535
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_332
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD.LIS	BC,0
	LD	HL,(HL)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_334
L_332:
	LD	A,(IX+%C)
	SET	%6,A
	LD	(IX+%C),A
L_334:
; 1958		dir[LDIR_Ord] = ord;			/* Set the LFN order */
.LINE 1958

	LD	HL,(IX+%9)
	LD	A,(IX+%C)
	LD	(HL),A
; 1959	}
.LINE 1959

	LD	SP,IX
	POP	IX
	RET	


;**************************** _put_lfn ***************************
;Name                         Addr/Register   Size   Type
;_LfnOfs                             STATIC     13   variable
;i                                     IX-8      3   variable
;s                                     IX-5      3   variable
;wc                                    IX-2      2   variable
;sum                                  IX+15      1   parameter
;ord                                  IX+12      1   parameter
;dir                                   IX+9      3   parameter
;lfn                                   IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "put_lfn",1959,"_put_lfn"
; 1960	
; 1961	#endif	/* !FF_FS_READONLY */
; 1962	#endif	/* FF_USE_LFN */
; 1963	
; 1964	
; 1965	
; 1966	#if FF_USE_LFN && !FF_FS_READONLY
; 1967	/*-----------------------------------------------------------------------*/
; 1968	/* FAT-LFN: Create a Numbered SFN                                        */
; 1969	/*-----------------------------------------------------------------------*/
; 1970	
; 1971	static void gen_numname (
; 1972		BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
; 1973		const BYTE* src,	/* Pointer to SFN */
; 1974		const WCHAR* lfn,	/* Pointer to LFN */
; 1975		UINT seq			/* Sequence number */
; 1976	)
; 1977	{
_gen_numname:
.DEFINE "_gen_numname"

.VALUE _gen_numname

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "gen_numname",1977,"_gen_numname"

.LINE 1977

.DEFINE "dst"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE 9

.TYPE 204

.ENDEF

.DEFINE "lfn"

.CLASS 65

.VALUE 12

.TYPE 205

.ENDEF

.DEFINE "seq"

.CLASS 65

.VALUE 15

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "c"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "sr"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -13

.TYPE 13

.ENDEF

.DEFINE "ns"

.CLASS 65

.VALUE -33

.DIM 8

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDC
	LD	SP,HL
; 1978		BYTE ns[8], c;
; 1979		UINT i, j;
; 1980		WCHAR wc;
; 1981		DWORD sr;
; 1982	
; 1983	
; 1984		mem_cpy(dst, src, 11);
.LINE 1984

	LD	BC,11
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 1985	
; 1986		if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
.LINE 1986

	LD	BC,(IX+%F)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	JR	NC,L_346
; 1987			sr = seq;
.LINE 1987

	LD	BC,(IX+%F)
	XOR	A,A
	LD	(IX+%FFFFFFF5),BC
	LD	(IX+%FFFFFFF8),A
; 1988			while (*lfn) {	/* Create a CRC as hash value */
.LINE 1988

	JR	L_342
L_343:
; 1989				wc = *lfn++;
.LINE 1989

	LD	HL,(IX+%C)
	LD	BC,(HL)
	LD	(IX+%FFFFFFF3),C
	LD	(IX+%FFFFFFF4),B
	LD	IY,(IX+%C)
	LEA	IY,IY+%2
	LD	(IX+%C),IY
; 1990				for (i = 0; i < 16; i++) {
.LINE 1990

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_341
L_339:
; 1991					sr = (sr << 1) + (wc & 1);
.LINE 1991

	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%1
	CALL	__lshl
	LD	(IX+%FFFFFFDC),BC
	LD	E,A
	LD	A,(IX+%FFFFFFF3)
	AND	A,%1
	LD	C,A
	LD	B,%0
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFDC)
	CALL	__ladd
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1992					wc >>= 1;
.LINE 1992

	LD	BC,(IX+%FFFFFFF3)
	CALL	__stoiu
	LD	A,%1
	CALL	__ishrs_b
	LD	(IX+%FFFFFFF3),L
	LD	(IX+%FFFFFFF4),H
; 1993					if (sr & 0x10000) sr ^= 0x11021;
.LINE 1993

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,65536
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_340
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,69665
	XOR	A,A
	CALL	__lxor
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 1994				}
L_340:
.LINE 1994

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_341:
	LD	BC,16
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_339
; 1995			}
L_342:
.LINE 1995

	LD	HL,(IX+%C)
	LD.LIS	BC,0
	LD	HL,(HL)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_343
; 1996			seq = (UINT)sr;
.LINE 1996

	LD	BC,(IX+%FFFFFFF5)
	LD	(IX+%F),BC
; 1997		}
L_346:
.LINE 1997

; 1998	
; 1999		/* itoa (hexdecimal) */
; 2000		i = 7;
.LINE 2000

	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
; 2001		do {
L_350:
.LINE 2001

; 2002			c = (BYTE)((seq % 16) + '0');
.LINE 2002

	LD	A,(IX+%F)
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+%30
	LD	(IX+%FFFFFFF9),L
; 2003			if (c > '9') c += 7;
.LINE 2003

	LD	A,%39
	CP	A,(IX+%FFFFFFF9)
	JR	NC,L_349
	LD	A,(IX+%FFFFFFF9)
	ADD	A,%7
	LD	(IX+%FFFFFFF9),A
L_349:
; 2004			ns[i--] = c;
.LINE 2004

	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IX+%FFFFFFDF
	ADD	HL,BC
	LD	A,(IX+%FFFFFFF9)
	LD	(HL),A
	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
; 2005			seq /= 16;
.LINE 2005

	LD	HL,(IX+%F)
	LD	A,%4
	CALL	__ishru_b
	LD	(IX+%F),HL
; 2006		} while (seq);
.LINE 2006

	LD	BC,0
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_350
; 2007		ns[i] = '~';
.LINE 2007

	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IX+%FFFFFFDF
	ADD	HL,BC
	LD	(HL),%7E
; 2008	
; 2009		/* Append the number to the SFN body */
; 2010		for (j = 0; j < i && dst[j] != ' '; j++) {
.LINE 2010

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_361
L_359:
; 2011			if (dbc_1st(dst[j])) {
.LINE 2011

	LD	HL,(IX+%FFFFFFED)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_dbc_1st
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_360
; 2012				if (j == i - 1) break;
.LINE 2012

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_368
; 2013				j++;
.LINE 2013

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
; 2014			}
; 2015		}
L_360:
.LINE 2015

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_361:
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_368
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFED),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_359
; 2016		do {
L_368:
.LINE 2016

; 2017			dst[j++] = (i < 8) ? ns[i++] : ' ';
.LINE 2017

	LD	BC,8
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_366
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFE7),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	BC,(IX+%FFFFFFE7)
	LEA	HL,IX+%FFFFFFDF
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF0),HL
	JR	L_367
L_366:
	LD	BC,32
	LD	(IX+%FFFFFFF0),BC
L_367:
	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFEA),BC
	LD	A,(IX+%FFFFFFF0)
	LD	BC,(IX+%FFFFFFEA)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
; 2018		} while (j < 8);
.LINE 2018

	LD	BC,8
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_368
; 2019	}
.LINE 2019

	LD	SP,IX
	POP	IX
	RET	


;**************************** _gen_numname ***************************
;Name                         Addr/Register   Size   Type
;ns                                   IX-33      8   variable
;temp363                              IX-25      3   variable
;temp362                              IX-22      3   variable
;G_14                                 IX-19      3   variable
;temp364                              IX-16      3   variable
;wc                                   IX-13      2   variable
;sr                                   IX-11      4   variable
;c                                     IX-7      1   variable
;j                                     IX-6      3   variable
;i                                     IX-3      3   variable
;seq                                  IX+15      3   parameter
;lfn                                  IX+12      3   parameter
;src                                   IX+9      3   parameter
;dst                                   IX+6      3   parameter


; Stack Frame Size: 54 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "gen_numname",2019,"_gen_numname"
; 2020	#endif	/* FF_USE_LFN && !FF_FS_READONLY */
; 2021	
; 2022	
; 2023	
; 2024	#if FF_USE_LFN
; 2025	/*-----------------------------------------------------------------------*/
; 2026	/* FAT-LFN: Calculate checksum of an SFN entry                           */
; 2027	/*-----------------------------------------------------------------------*/
; 2028	
; 2029	static BYTE sum_sfn (
; 2030		const BYTE* dir		/* Pointer to the SFN entry */
; 2031	)
; 2032	{
_sum_sfn:
.DEFINE "_sum_sfn"

.VALUE _sum_sfn

.CLASS 3

.TYPE 76

.ENDEF

.BEGFUNC "sum_sfn",2032,"_sum_sfn"

.LINE 2032

.DEFINE "dir"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 2033		BYTE sum = 0;
.LINE 2033

	LD	(IX+%FFFFFFFF),%0
; 2034		UINT n = 11;
.LINE 2034

	LD	BC,11
	LD	(IX+%FFFFFFFC),BC
; 2035	
; 2036		do {
L_373:
.LINE 2036

; 2037			sum = (sum >> 1) + (sum << 7) + *dir++;
.LINE 2037

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	A,%1
	CALL	__ishrs_b
	LD	B,%7
	LD	A,(IX+%FFFFFFFF)
	CALL	__bshl
	LD	B,A
	LD	A,L
	ADD	A,B
	LD	HL,(IX+%6)
	ADD	A,(HL)
	LD	(IX+%FFFFFFFF),A
	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
; 2038		} while (--n);
.LINE 2038

	LD	IY,(IX+%FFFFFFFC)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFC),IY
	LD	BC,0
	LD	HL,(IX+%FFFFFFFC)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_373
; 2039		return sum;
.LINE 2039

	LD	A,(IX+%FFFFFFFF)
; 2040	}
.LINE 2040

	LD	SP,IX
	POP	IX
	RET	


;**************************** _sum_sfn ***************************
;Name                         Addr/Register   Size   Type
;n                                     IX-4      3   variable
;sum                                   IX-1      1   variable
;dir                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "sum_sfn",2040,"_sum_sfn"
; 2041	
; 2042	#endif	/* FF_USE_LFN */
; 2043	
; 2044	
; 2045	
; 2046	#if FF_FS_EXFAT
; 2047	/*-----------------------------------------------------------------------*/
; 2048	/* exFAT: Checksum                                                       */
; 2049	/*-----------------------------------------------------------------------*/
; 2050	
; 2051	static WORD xdir_sum (	/* Get checksum of the directoly entry block */
; 2052		const BYTE* dir		/* Directory entry block to be calculated */
; 2053	)
; 2054	{
; 2055		UINT i, szblk;
; 2056		WORD sum;
; 2057	
; 2058	
; 2059		szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
; 2060		for (i = sum = 0; i < szblk; i++) {
; 2061			if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
; 2062				i++;
; 2063			} else {
; 2064				sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
; 2065			}
; 2066		}
; 2067		return sum;
; 2068	}
; 2069	
; 2070	
; 2071	
; 2072	static WORD xname_sum (	/* Get check sum (to be used as hash) of the file name */
; 2073		const WCHAR* name	/* File name to be calculated */
; 2074	)
; 2075	{
; 2076		WCHAR chr;
; 2077		WORD sum = 0;
; 2078	
; 2079	
; 2080		while ((chr = *name++) != 0) {
; 2081			chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
; 2082			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
; 2083			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
; 2084		}
; 2085		return sum;
; 2086	}
; 2087	
; 2088	
; 2089	#if !FF_FS_READONLY && FF_USE_MKFS
; 2090	static DWORD xsum32 (	/* Returns 32-bit checksum */
; 2091		BYTE  dat,			/* Byte to be calculated (byte-by-byte processing) */
; 2092		DWORD sum			/* Previous sum value */
; 2093	)
; 2094	{
; 2095		sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
; 2096		return sum;
; 2097	}
; 2098	#endif
; 2099	
; 2100	
; 2101	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
; 2102	/*------------------------------------------------------*/
; 2103	/* exFAT: Get object information from a directory block */
; 2104	/*------------------------------------------------------*/
; 2105	
; 2106	static void get_xfileinfo (
; 2107		BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
; 2108		FILINFO* fno		/* Buffer to store the extracted file information */
; 2109	)
; 2110	{
; 2111		WCHAR wc, hs;
; 2112		UINT di, si, nc;
; 2113	
; 2114		/* Get file name from the entry block */
; 2115		si = SZDIRE * 2;	/* 1st C1 entry */
; 2116		nc = 0; hs = 0; di = 0;
; 2117		while (nc < dirb[XDIR_NumName]) {
; 2118			if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
; 2119			if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
; 2120			wc = ld_word(dirb + si); si += 2; nc++;	/* Get a character */
; 2121			if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
; 2122				hs = wc; continue;	/* Get low surrogate */
; 2123			}
; 2124			wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
; 2125			if (wc == 0) { di = 0; break; }	/* Buffer overflow or wrong encoding? */
; 2126			di += wc;
; 2127			hs = 0;
; 2128		}
; 2129		if (hs != 0) di = 0;					/* Broken surrogate pair? */
; 2130		if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
; 2131		fno->fname[di] = 0;						/* Terminate the name */
; 2132		fno->altname[0] = 0;					/* exFAT does not support SFN */
; 2133	
; 2134		fno->fattrib = dirb[XDIR_Attr];			/* Attribute */
; 2135		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
; 2136		fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
; 2137		fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
; 2138	}
; 2139	
; 2140	#endif	/* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
; 2141	
; 2142	
; 2143	/*-----------------------------------*/
; 2144	/* exFAT: Get a directry entry block */
; 2145	/*-----------------------------------*/
; 2146	
; 2147	static FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
; 2148		DIR* dp					/* Reading direcotry object pointing top of the entry block to load */
; 2149	)
; 2150	{
; 2151		FRESULT res;
; 2152		UINT i, sz_ent;
; 2153		BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
; 2154	
; 2155	
; 2156		/* Load 85 entry */
; 2157		res = move_window(dp->obj.fs, dp->sect);
; 2158		if (res != FR_OK) return res;
; 2159		if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;	/* Invalid order */
; 2160		mem_cpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
; 2161		sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
; 2162		if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
; 2163	
; 2164		/* Load C0 entry */
; 2165		res = dir_next(dp, 0);
; 2166		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
; 2167		if (res != FR_OK) return res;
; 2168		res = move_window(dp->obj.fs, dp->sect);
; 2169		if (res != FR_OK) return res;
; 2170		if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;	/* Invalid order */
; 2171		mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
; 2172		if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
; 2173	
; 2174		/* Load C1 entries */
; 2175		i = 2 * SZDIRE;	/* C1 offset to load */
; 2176		do {
; 2177			res = dir_next(dp, 0);
; 2178			if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
; 2179			if (res != FR_OK) return res;
; 2180			res = move_window(dp->obj.fs, dp->sect);
; 2181			if (res != FR_OK) return res;
; 2182			if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;	/* Invalid order */
; 2183			if (i < MAXDIRB(FF_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
; 2184		} while ((i += SZDIRE) < sz_ent);
; 2185	
; 2186		/* Sanity check (do it for only accessible object) */
; 2187		if (i <= MAXDIRB(FF_MAX_LFN)) {
; 2188			if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
; 2189		}
; 2190		return FR_OK;
; 2191	}
; 2192	
; 2193	
; 2194	/*------------------------------------------------------------------*/
; 2195	/* exFAT: Initialize object allocation info with loaded entry block */
; 2196	/*------------------------------------------------------------------*/
; 2197	
; 2198	static void init_alloc_info (
; 2199		FATFS* fs,		/* Filesystem object */
; 2200		FFOBJID* obj	/* Object allocation information to be initialized */
; 2201	)
; 2202	{
; 2203		obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
; 2204		obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
; 2205		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
; 2206		obj->n_frag = 0;										/* No last fragment info */
; 2207	}
; 2208	
; 2209	
; 2210	
; 2211	#if !FF_FS_READONLY || FF_FS_RPATH != 0
; 2212	/*------------------------------------------------*/
; 2213	/* exFAT: Load the object's directory entry block */
; 2214	/*------------------------------------------------*/
; 2215	
; 2216	static FRESULT load_obj_xdir (
; 2217		DIR* dp,			/* Blank directory object to be used to access containing direcotry */
; 2218		const FFOBJID* obj	/* Object with its containing directory information */
; 2219	)
; 2220	{
; 2221		FRESULT res;
; 2222	
; 2223		/* Open object containing directory */
; 2224		dp->obj.fs = obj->fs;
; 2225		dp->obj.sclust = obj->c_scl;
; 2226		dp->obj.stat = (BYTE)obj->c_size;
; 2227		dp->obj.objsize = obj->c_size & 0xFFFFFF00;
; 2228		dp->obj.n_frag = 0;
; 2229		dp->blk_ofs = obj->c_ofs;
; 2230	
; 2231		res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
; 2232		if (res == FR_OK) {
; 2233			res = load_xdir(dp);		/* Load the object's entry block */
; 2234		}
; 2235		return res;
; 2236	}
; 2237	#endif
; 2238	
; 2239	
; 2240	#if !FF_FS_READONLY
; 2241	/*----------------------------------------*/
; 2242	/* exFAT: Store the directory entry block */
; 2243	/*----------------------------------------*/
; 2244	
; 2245	static FRESULT store_xdir (
; 2246		DIR* dp				/* Pointer to the direcotry object */
; 2247	)
; 2248	{
; 2249		FRESULT res;
; 2250		UINT nent;
; 2251		BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
; 2252	
; 2253		/* Create set sum */
; 2254		st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
; 2255		nent = dirb[XDIR_NumSec] + 1;
; 2256	
; 2257		/* Store the direcotry entry block to the directory */
; 2258		res = dir_sdi(dp, dp->blk_ofs);
; 2259		while (res == FR_OK) {
; 2260			res = move_window(dp->obj.fs, dp->sect);
; 2261			if (res != FR_OK) break;
; 2262			mem_cpy(dp->dir, dirb, SZDIRE);
; 2263			dp->obj.fs->wflag = 1;
; 2264			if (--nent == 0) break;
; 2265			dirb += SZDIRE;
; 2266			res = dir_next(dp, 0);
; 2267		}
; 2268		return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
; 2269	}
; 2270	
; 2271	
; 2272	
; 2273	/*-------------------------------------------*/
; 2274	/* exFAT: Create a new directory enrty block */
; 2275	/*-------------------------------------------*/
; 2276	
; 2277	static void create_xdir (
; 2278		BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
; 2279		const WCHAR* lfn	/* Pointer to the object name */
; 2280	)
; 2281	{
; 2282		UINT i;
; 2283		BYTE nc1, nlen;
; 2284		WCHAR wc;
; 2285	
; 2286	
; 2287		/* Create 85,C0 entry */
; 2288		mem_set(dirb, 0, 2 * SZDIRE);
; 2289		dirb[0 * SZDIRE + XDIR_Type] = 0x85;	/* 85 entry */
; 2290		dirb[1 * SZDIRE + XDIR_Type] = 0xC0;	/* C0 entry */
; 2291	
; 2292		/* Create C1 entries */
; 2293		i = SZDIRE * 2;	/* Top of C1 entries */
; 2294		nlen = nc1 = 0; wc = 1;
; 2295		do {
; 2296			dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
; 2297			do {	/* Fill name field */
; 2298				if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
; 2299				st_word(dirb + i, wc); 		/* Store it */
; 2300				i += 2;
; 2301			} while (i % SZDIRE != 0);
; 2302			nc1++;
; 2303		} while (lfn[nlen]);	/* Fill next entry if any char follows */
; 2304	
; 2305		dirb[XDIR_NumName] = nlen;		/* Set name length */
; 2306		dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
; 2307		st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
; 2308	}
; 2309	
; 2310	#endif	/* !FF_FS_READONLY */
; 2311	#endif	/* FF_FS_EXFAT */
; 2312	
; 2313	
; 2314	
; 2315	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
; 2316	/*-----------------------------------------------------------------------*/
; 2317	/* Read an object from the directory                                     */
; 2318	/*-----------------------------------------------------------------------*/
; 2319	
; 2320	#define dir_read_file(dp) dir_read(dp, 0)
; 2321	#define dir_read_label(dp) dir_read(dp, 1)
; 2322	
; 2323	static FRESULT dir_read (
; 2324		DIR* dp,		/* Pointer to the directory object */
; 2325		int vol			/* Filtered by 0:file/directory or 1:volume label */
; 2326	)
; 2327	{
_dir_read:
.DEFINE "_dir_read"

.VALUE _dir_read

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_read",2327,"_dir_read"

.LINE 2327

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "c"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "ord"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -5

.TYPE 4

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -10

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE9
	LD	SP,HL
; 2328		FRESULT res = FR_NO_FILE;
.LINE 2328

	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
; 2329		FATFS *fs = dp->obj.fs;
.LINE 2329

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF6),BC
; 2330		BYTE a, c;
; 2331	#if FF_USE_LFN
; 2332		BYTE ord = 0xFF, sum = 0xFF;
.LINE 2332

	LD	(IX+%FFFFFFFE),%FF
	LD	(IX+%FFFFFFF9),%FF
; 2333	#endif
; 2334	
; 2335		while (dp->sect) {
.LINE 2335

	JR	L_400
L_401:
; 2336			res = move_window(fs, dp->sect);
.LINE 2336

	LD	C,(IX+%FFFFFFEC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2337			if (res != FR_OK) break;
.LINE 2337

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_403
; 2338			c = dp->dir[DIR_Name];	/* Test for the entry type */
.LINE 2338

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFFF),A
; 2339			if (c == 0) {
.LINE 2339

	OR	A,A
	JR	NZ,L_397
; 2340				res = FR_NO_FILE; break; /* Reached to end of the directory */
.LINE 2340

	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
	JR	L_403
; 2341			}
L_397:
.LINE 2341

; 2342	#if FF_FS_EXFAT
; 2343			if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2344				if (FF_USE_LABEL && vol) {
; 2345					if (c == 0x83) break;	/* Volume label entry? */
; 2346				} else {
; 2347					if (c == 0x85) {		/* Start of the file entry block? */
; 2348						dp->blk_ofs = dp->dptr;	/* Get location of the block */
; 2349						res = load_xdir(dp);	/* Load the entry block */
; 2350						if (res == FR_OK) {
; 2351							dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
; 2352						}
; 2353						break;
; 2354					}
; 2355				}
; 2356			} else
; 2357	#endif
; 2358			{	/* On the FAT/FAT32 volume */
; 2359				dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
.LINE 2359

	LD	IY,(IX+%FFFFFFF0)
	LD	A,(IY+%B)
	AND	A,%3F
	LD	(IX+%FFFFFFFA),A
	LD	IY,(IX+%6)
	LD	(IY+%5),A
; 2360	#if FF_USE_LFN		/* LFN configuration */
; 2361				if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
.LINE 2361

	LD	A,(IX+%FFFFFFFF)
	CP	A,%E5
	JR	Z,L_395
	LD	A,(IX+%FFFFFFFF)
	CP	A,%2E
	JR	Z,L_395
	LD	A,(IX+%FFFFFFFA)
	RES	%5,A
	CP	A,%8
	JR	NZ,L__199
	LD	B,%1
	JR	L__200
L__199:
	LD	B,%0
L__200:
	LD	A,B
	SEXT	HL
	LD	L,B
	LD	BC,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_396
L_395:
; 2362					ord = 0xFF;
.LINE 2362

	LD	(IX+%FFFFFFFE),%FF
; 2363				} else {
.LINE 2363

	JR	L_398
L_396:
; 2364					if (a == AM_LFN) {			/* An LFN entry is found */
.LINE 2364

	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	NZ,L_394
; 2365						if (c & LLEF) {			/* Is it start of an LFN sequence? */
.LINE 2365

	LD	A,(IX+%FFFFFFFF)
	AND	A,%40
	JR	Z,L_389
; 2366							sum = dp->dir[LDIR_Chksum];
.LINE 2366

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%D)
	LD	(IX+%FFFFFFF9),A
; 2367							c &= (BYTE)~LLEF; ord = c;
.LINE 2367

	LD	A,(IX+%FFFFFFFF)
	RES	%6,A
	LD	(IX+%FFFFFFFF),A
	LD	(IX+%FFFFFFFE),A
; 2368							dp->blk_ofs = dp->dptr;
.LINE 2368

	LD	IY,(IX+%6)
	LD	BC,(IY+%F)
	LD	A,(IY+%12)
	LD	(IY+%2A),BC
	LD	(IY+%2D),A
; 2369						}
L_389:
.LINE 2369

; 2370						/* Check LFN validity and capture it */
; 2371						ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
.LINE 2371

	LD	A,(IX+%FFFFFFFF)
	CP	A,(IX+%FFFFFFFE)
	JR	NZ,L_387
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFED),BC
	LD	IY,(IX+%FFFFFFED)
	LD	A,(IY+%D)
	CP	A,(IX+%FFFFFFF9)
	JR	NZ,L_387
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%B)
	PUSH	BC
	CALL	_pick_lfn
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_387
	LD	A,(IX+%FFFFFFFE)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+%FFFFFFF3),HL
	JR	L_388
L_387:
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
L_388:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFFE),A
; 2372					} else {					/* An SFN entry is found */
.LINE 2372

	JR	L_398
L_394:
; 2373						if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
.LINE 2373

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	NZ,L_391
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_sum_sfn
	POP	BC
	CP	A,(IX+%FFFFFFF9)
	JR	Z,L_403
L_391:
; 2374							dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
.LINE 2374

	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2375						}
.LINE 2375

; 2376						break;
.LINE 2376

	JR	L_403
; 2377					}
; 2378				}
; 2379	#else		/* Non LFN configuration */
; 2380				if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
; 2381					break;
; 2382				}
; 2383	#endif
; 2384			}
L_398:
.LINE 2384

; 2385			res = dir_next(dp, 0);		/* Next entry */
.LINE 2385

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2386			if (res != FR_OK) break;
.LINE 2386

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_403
; 2387		}
L_400:
.LINE 2387

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	(IX+%FFFFFFE9),BC
	LD	(IX+%FFFFFFEC),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFEC)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_401
L_403:
; 2388	
; 2389		if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
.LINE 2389

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_404
	LD	IY,(IX+%6)
	LD	(IY+%17),BC
	LD	(IY+%1A),%0
L_404:
; 2390		return res;
.LINE 2390

	LD	HL,(IX+%FFFFFFFB)
; 2391	}
.LINE 2391

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_read ***************************
;Name                         Addr/Register   Size   Type
;G_15                                 IX-23      4   variable
;G_17                                 IX-19      3   variable
;G_16                                 IX-16      3   variable
;temp385                              IX-13      3   variable
;fs                                   IX-10      3   variable
;sum                                   IX-7      1   variable
;a                                     IX-6      1   variable
;res                                   IX-5      3   variable
;ord                                   IX-2      1   variable
;c                                     IX-1      1   variable
;vol                                   IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 35 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_read",2391,"_dir_read"
; 2392	
; 2393	#endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
; 2394	
; 2395	
; 2396	
; 2397	/*-----------------------------------------------------------------------*/
; 2398	/* Directory handling - Find an object in the directory                  */
; 2399	/*-----------------------------------------------------------------------*/
; 2400	
; 2401	static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
; 2402		DIR* dp					/* Pointer to the directory object with the file name */
; 2403	)
; 2404	{
_dir_find:
.DEFINE "_dir_find"

.VALUE _dir_find

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_find",2404,"_dir_find"

.LINE 2404

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "c"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "ord"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -5

.TYPE 4

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -10

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
; 2405		FRESULT res;
; 2406		FATFS *fs = dp->obj.fs;
.LINE 2406

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF6),BC
; 2407		BYTE c;
; 2408	#if FF_USE_LFN
; 2409		BYTE a, ord, sum;
; 2410	#endif
; 2411	
; 2412		res = dir_sdi(dp, 0);			/* Rewind directory object */
.LINE 2412

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2413		if (res != FR_OK) return res;
.LINE 2413

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_407
	LD	HL,(IX+%FFFFFFFB)
	JR	L_437
L_407:
; 2414	#if FF_FS_EXFAT
; 2415		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2416			BYTE nc;
; 2417			UINT di, ni;
; 2418			WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
; 2419	
; 2420			while ((res = dir_read_file(dp)) == FR_OK) {	/* Read an item */
; 2421	#if FF_MAX_LFN < 255
; 2422				if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;			/* Skip comparison if inaccessible object name */
; 2423	#endif
; 2424				if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
; 2425				for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
; 2426					if ((di % SZDIRE) == 0) di += 2;
; 2427					if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
; 2428				}
; 2429				if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
; 2430			}
; 2431			return res;
; 2432		}
; 2433	#endif
; 2434		/* On the FAT/FAT32 volume */
; 2435	#if FF_USE_LFN
; 2436		ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2436

	LD	(IX+%FFFFFFF9),%FF
	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2437	#endif
; 2438		do {
L_434:
.LINE 2438

; 2439			res = move_window(fs, dp->sect);
.LINE 2439

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2440			if (res != FR_OK) break;
.LINE 2440

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_436
; 2441			c = dp->dir[DIR_Name];
.LINE 2441

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFFF),A
; 2442			if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
.LINE 2442

	OR	A,A
	JR	NZ,L_411
	LD	BC,4
	LD	(IX+%FFFFFFFB),BC
	JR	L_436
L_411:
; 2443	#if FF_USE_LFN		/* LFN configuration */
; 2444			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
.LINE 2444

	LD	IY,(IX+%FFFFFFF0)
	LD	A,(IY+%B)
	AND	A,%3F
	LD	(IX+%FFFFFFFA),A
	LD	IY,(IX+%6)
	LD	(IY+%5),A
; 2445			if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
.LINE 2445

	LD	A,(IX+%FFFFFFFF)
	CP	A,%E5
	JR	Z,L_431
	LD	A,(IX+%FFFFFFFA)
	AND	A,%8
	JR	Z,L_432
	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	Z,L_432
L_431:
; 2446				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2446

	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2447			} else {
.LINE 2447

	JR	L_433
L_432:
; 2448				if (a == AM_LFN) {			/* An LFN entry is found */
.LINE 2448

	LD	A,(IX+%FFFFFFFA)
	CP	A,%F
	JR	NZ,L_430
; 2449					if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
.LINE 2449

	LD	IY,(IX+%6)
	LD	A,(IY+%29)
	AND	A,%40
	JR	NZ,L_433
; 2450						if (c & LLEF) {		/* Is it start of LFN sequence? */
.LINE 2450

	LD	A,(IX+%FFFFFFFF)
	AND	A,%40
	JR	Z,L_421
; 2451							sum = dp->dir[LDIR_Chksum];
.LINE 2451

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%D)
	LD	(IX+%FFFFFFF9),A
; 2452							c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
.LINE 2452

	LD	A,(IX+%FFFFFFFF)
	RES	%6,A
	LD	(IX+%FFFFFFFF),A
	LD	(IX+%FFFFFFFE),A
; 2453							dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
.LINE 2453

	LD	IY,(IX+%6)
	LD	BC,(IY+%F)
	LD	A,(IY+%12)
	LD	(IY+%2A),BC
	LD	(IY+%2D),A
; 2454						}
L_421:
.LINE 2454

; 2455						/* Check validity of the LFN entry and compare it with given name */
; 2456						ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
.LINE 2456

	LD	A,(IX+%FFFFFFFF)
	CP	A,(IX+%FFFFFFFE)
	JR	NZ,L_419
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	LD	(IX+%FFFFFFED),BC
	LD	IY,(IX+%FFFFFFED)
	LD	A,(IY+%D)
	CP	A,(IX+%FFFFFFF9)
	JR	NZ,L_419
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%B)
	PUSH	BC
	CALL	_cmp_lfn
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_419
	LD	A,(IX+%FFFFFFFE)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	(IX+%FFFFFFF3),HL
	JR	L_420
L_419:
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
L_420:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFFE),A
; 2457					}
; 2458				} else {					/* An SFN entry is found */
.LINE 2458

	JR	L_433
L_430:
; 2459					if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
.LINE 2459

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	NZ,L_427
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_sum_sfn
	POP	BC
	CP	A,(IX+%FFFFFFF9)
	JR	Z,L_436
L_427:
; 2460					if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
.LINE 2460

	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFEA),BC
	LD	IY,(IX+%FFFFFFEA)
	LD	A,(IY+%B)
	AND	A,%1
	JR	NZ,L_428
	LD	BC,11
	PUSH	BC
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_mem_cmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_436
L_428:
; 2461					ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
.LINE 2461

	LD	(IX+%FFFFFFFE),%FF
	LD	BC,16777215
	LD	IY,(IX+%6)
	LD	(IY+%2A),BC
	LD	(IY+%2D),%FF
; 2462				}
; 2463			}
L_433:
.LINE 2463

; 2464	#else		/* Non LFN configuration */
; 2465			dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
; 2466			if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
; 2467	#endif
; 2468			res = dir_next(dp, 0);	/* Next entry */
.LINE 2468

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),HL
; 2469		} while (res == FR_OK);
.LINE 2469

	LD	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_434
L_436:
; 2470	
; 2471		return res;
.LINE 2471

	LD	HL,(IX+%FFFFFFFB)
; 2472	}
L_437:
.LINE 2472

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_find ***************************
;Name                         Addr/Register   Size   Type
;G_20                                 IX-22      3   variable
;G_19                                 IX-19      3   variable
;G_18                                 IX-16      3   variable
;temp417                              IX-13      3   variable
;fs                                   IX-10      3   variable
;sum                                   IX-7      1   variable
;a                                     IX-6      1   variable
;res                                   IX-5      3   variable
;ord                                   IX-2      1   variable
;c                                     IX-1      1   variable
;dp                                    IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_find",2472,"_dir_find"
; 2473	
; 2474	
; 2475	
; 2476	
; 2477	#if !FF_FS_READONLY
; 2478	/*-----------------------------------------------------------------------*/
; 2479	/* Register an object to the directory                                   */
; 2480	/*-----------------------------------------------------------------------*/
; 2481	
; 2482	static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
; 2483		DIR* dp						/* Target directory with object name to be created */
; 2484	)
; 2485	{
_dir_register:
.DEFINE "_dir_register"

.VALUE _dir_register

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_register",2485,"_dir_register"

.LINE 2485

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "nent"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -9

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "nlen"

.CLASS 65

.VALUE -15

.TYPE 14

.ENDEF

.DEFINE "sum"

.CLASS 65

.VALUE -16

.TYPE 12

.ENDEF

.DEFINE "sn"

.CLASS 65

.VALUE -34

.DIM 12

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDE
	LD	SP,HL
; 2486		FRESULT res = FR_OK;
.LINE 2486

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2487		FATFS *fs = dp->obj.fs;
.LINE 2487

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF7),BC
; 2488	#if FF_USE_LFN		/* LFN configuration */
; 2489		UINT n, nlen, nent;
; 2490		BYTE sn[12], sum;
; 2491	
; 2492	
; 2493		if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
.LINE 2493

	LD	A,(IY+%29)
	AND	A,%A0
	JR	Z,L_443
	LD	HL,6
	JR	L_473
L_443:
; 2494		for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
.LINE 2494

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
	JR	L_442
L_440:
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
L_442:
	LD	HL,(IX+%FFFFFFF1)
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%B)
	ADD	HL,BC
	LD.LIS	BC,0
	LD	HL,(HL)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_440
; 2495	
; 2496	#if FF_FS_EXFAT
; 2497		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2498			nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
; 2499			res = dir_alloc(dp, nent);		/* Allocate entries */
; 2500			if (res != FR_OK) return res;
; 2501			dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
; 2502	
; 2503			if (dp->obj.stat & 4) {			/* Has the directory been stretched? */
; 2504				dp->obj.stat &= ~4;
; 2505				res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
; 2506				if (res != FR_OK) return res;
; 2507				res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
; 2508				if (res != FR_OK) return res;
; 2509				if (dp->obj.sclust != 0) {		/* Is it a sub directory? */
; 2510					DIR dj;
; 2511	
; 2512					res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
; 2513					if (res != FR_OK) return res;
; 2514					dp->obj.objsize += (DWORD)fs->csize * SS(fs);			/* Increase the directory size by cluster size */
; 2515					st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);	/* Update the allocation status */
; 2516					st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
; 2517					fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
; 2518					res = store_xdir(&dj);				/* Store the object status */
; 2519					if (res != FR_OK) return res;
; 2520				}
; 2521			}
; 2522	
; 2523			create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
; 2524			return FR_OK;
; 2525		}
; 2526	#endif
; 2527		/* On the FAT/FAT32 volume */
; 2528		mem_cpy(sn, dp->fn, 12);
.LINE 2528

	LD	BC,12
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%1E
	PEA	IX+%FFFFFFDE
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 2529		if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
.LINE 2529

	LEA	IY,IX+%FFFFFFDE
	LEA	BC,IY+%B
	LD	(IX+%FFFFFFEA),BC
	LD	A,(IY+%B)
	AND	A,%1
	JR	Z,L_460
; 2530			dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
.LINE 2530

	LD	IY,(IX+%6)
	LEA	HL,IY+%29
	LD	(HL),%40
; 2531			for (n = 1; n < 100; n++) {
.LINE 2531

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_449
L_447:
; 2532				gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
.LINE 2532

	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%B)
	PUSH	BC
	PEA	IX+%FFFFFFDE
	LD	IY,(IX+%6)
	PEA	IY+%1E
	CALL	_gen_numname
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 2533				res = dir_find(dp);				/* Check if the name collides with existing SFN */
.LINE 2533

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_find
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2534				if (res != FR_OK) break;
.LINE 2534

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_451
	LD	BC,(IX+%FFFFFFF4)
	INC	BC
	LD	(IX+%FFFFFFF4),BC
; 2535			}
L_449:
.LINE 2535

	LD	BC,100
	LD	HL,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,BC
	JR	C,L_447
L_451:
; 2536			if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
.LINE 2536

	LD	BC,100
	LD	HL,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_453
	LD	HL,7
	JR	L_473
L_453:
; 2537			if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
.LINE 2537

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_454
	LD	HL,(IX+%FFFFFFFD)
	JR	L_473
L_454:
; 2538			dp->fn[NSFLAG] = sn[NSFLAG];
.LINE 2538

	LEA	BC,IX+%FFFFFFE9
	LD	(IX+%FFFFFFEA),BC
	LEA	HL,IX+%FFFFFFE9
	LD	IY,(IX+%6)
	LD	A,(HL)
	LD	(IY+%29),A
; 2539		}
L_460:
.LINE 2539

; 2540	
; 2541		/* Create an SFN with/without LFNs. */
; 2542		nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
.LINE 2542

	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	AND	A,%2
	JR	Z,L_458
	LD	IY,(IX+%FFFFFFF1)
	LEA	HL,IY+%C
	LD	BC,13
	CALL	__idivu
	INC	HL
	LD	(IX+%FFFFFFED),HL
	JR	L_459
L_458:
	LD	BC,1
	LD	(IX+%FFFFFFED),BC
L_459:
	LD	BC,(IX+%FFFFFFED)
	LD	(IX+%FFFFFFFA),BC
; 2543		res = dir_alloc(dp, nent);		/* Allocate entries */
.LINE 2543

	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_alloc
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2544		if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
.LINE 2544

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_471
	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_471
; 2545			res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
.LINE 2545

	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2546			if (res == FR_OK) {
.LINE 2546

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_471
; 2547				sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
.LINE 2547

	LD	IY,(IX+%6)
	PEA	IY+%1E
	CALL	_sum_sfn
	POP	BC
	LD	(IX+%FFFFFFF0),A
; 2548				do {					/* Store LFN entries in bottom first */
L_465:
.LINE 2548

; 2549					res = move_window(fs, dp->sect);
.LINE 2549

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2550					if (res != FR_OK) break;
.LINE 2550

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_471
; 2551					put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
.LINE 2551

	LD	C,(IX+%FFFFFFF0)
	LD	B,%0
	PUSH	BC
	LD	C,(IX+%FFFFFFFA)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%B)
	PUSH	BC
	CALL	_put_lfn
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 2552					fs->wflag = 1;
.LINE 2552

	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),%1
; 2553					res = dir_next(dp, 0);	/* Next entry */
.LINE 2553

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2554				} while (res == FR_OK && --nent);
.LINE 2554

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_471
	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_465
; 2555			}
; 2556		}
L_471:
.LINE 2556

; 2557	
; 2558	#else	/* Non LFN configuration */
; 2559		res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
; 2560	
; 2561	#endif
; 2562	
; 2563		/* Set SFN entry */
; 2564		if (res == FR_OK) {
.LINE 2564

	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_472
; 2565			res = move_window(fs, dp->sect);
.LINE 2565

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2566			if (res == FR_OK) {
.LINE 2566

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_472
; 2567				mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
.LINE 2567

	LD	BC,32
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_mem_set
	POP	BC
	POP	BC
	POP	BC
; 2568				mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
.LINE 2568

	LD	BC,11
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%1E
	LD	BC,(IY+%1B)
	PUSH	BC
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 2569	#if FF_USE_LFN
; 2570				dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
.LINE 2570

	LD	IY,(IX+%6)
	LEA	HL,IY+%29
	LD	A,(HL)
	AND	A,%18
	LD	IY,(IY+%1B)
	LEA	HL,IY+%C
	LD	(HL),A
; 2571	#endif
; 2572				fs->wflag = 1;
.LINE 2572

	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),%1
; 2573			}
; 2574		}
L_472:
.LINE 2574

; 2575	
; 2576		return res;
.LINE 2576

	LD	HL,(IX+%FFFFFFFD)
; 2577	}
L_473:
.LINE 2577

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_register ***************************
;Name                         Addr/Register   Size   Type
;sn                                   IX-34     12   variable
;G_21                                 IX-22      3   variable
;temp456                              IX-19      3   variable
;sum                                  IX-16      1   variable
;nlen                                 IX-15      3   variable
;n                                    IX-12      3   variable
;fs                                    IX-9      3   variable
;nent                                  IX-6      3   variable
;res                                   IX-3      3   variable
;dp                                    IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_register",2577,"_dir_register"
; 2578	
; 2579	#endif /* !FF_FS_READONLY */
; 2580	
; 2581	
; 2582	
; 2583	#if !FF_FS_READONLY && FF_FS_MINIMIZE == 0
; 2584	/*-----------------------------------------------------------------------*/
; 2585	/* Remove an object from the directory                                   */
; 2586	/*-----------------------------------------------------------------------*/
; 2587	
; 2588	static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
; 2589		DIR* dp					/* Directory object pointing the entry to be removed */
; 2590	)
; 2591	{
_dir_remove:
.DEFINE "_dir_remove"

.VALUE _dir_remove

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "dir_remove",2591,"_dir_remove"

.LINE 2591

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "last"

.CLASS 65

.VALUE -17

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEF
	LD	SP,HL
; 2592		FRESULT res;
; 2593		FATFS *fs = dp->obj.fs;
.LINE 2593

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFA),BC
; 2594	#if FF_USE_LFN		/* LFN configuration */
; 2595		DWORD last = dp->dptr;
.LINE 2595

	LD	BC,(IY+%F)
	LD	A,(IY+%12)
	LD	(IX+%FFFFFFEF),BC
	LD	(IX+%FFFFFFF2),A
; 2596	
; 2597		res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
.LINE 2597

	LD	BC,(IY+%2A)
	LD	A,(IY+%2D)
	LD	(IX+%FFFFFFF3),BC
	LD	(IX+%FFFFFFF6),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF6)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_476
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_477
L_476:
	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF7),HL
L_477:
	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
; 2598		if (res == FR_OK) {
.LINE 2598

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_490
; 2599			do {
L_485:
.LINE 2599

; 2600				res = move_window(fs, dp->sect);
.LINE 2600

	LD	IY,(IX+%6)
	LD	BC,(IY+%17)
	LD	A,(IY+%1A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2601				if (res != FR_OK) break;
.LINE 2601

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_488
; 2602				if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2603					dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
; 2604				} else {									/* On the FAT/FAT32 volume */
; 2605					dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'. */
.LINE 2605

	LD	IY,(IX+%6)
	LD	HL,(IY+%1B)
	LD	(HL),%E5
; 2606				}
; 2607				fs->wflag = 1;
.LINE 2607

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 2608				if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
.LINE 2608

	LD	IY,(IX+%6)
	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	LD	BC,(IX+%FFFFFFEF)
	LD	A,(IX+%FFFFFFF2)
	CALL	__lcmpu
	JR	NC,L_488
; 2609				res = dir_next(dp, 0);	/* Next entry */
.LINE 2609

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2610			} while (res == FR_OK);
.LINE 2610

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_485
L_488:
; 2611			if (res == FR_NO_FILE) res = FR_INT_ERR;
.LINE 2611

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_490
	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 2612		}
L_490:
.LINE 2612

; 2613	#else			/* Non LFN configuration */
; 2614	
; 2615		res = move_window(fs, dp->sect);
; 2616		if (res == FR_OK) {
; 2617			dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
; 2618			fs->wflag = 1;
; 2619		}
; 2620	#endif
; 2621	
; 2622		return res;
.LINE 2622

	LD	HL,(IX+%FFFFFFFD)
; 2623	}
.LINE 2623

	LD	SP,IX
	POP	IX
	RET	


;**************************** _dir_remove ***************************
;Name                         Addr/Register   Size   Type
;last                                 IX-17      4   variable
;G_22                                 IX-13      4   variable
;temp474                               IX-9      3   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;dp                                    IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "dir_remove",2623,"_dir_remove"
; 2624	
; 2625	#endif /* !FF_FS_READONLY && FF_FS_MINIMIZE == 0 */
; 2626	
; 2627	
; 2628	
; 2629	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
; 2630	/*-----------------------------------------------------------------------*/
; 2631	/* Get file information from directory entry                             */
; 2632	/*-----------------------------------------------------------------------*/
; 2633	
; 2634	static void get_fileinfo (
; 2635		DIR* dp,			/* Pointer to the directory object */
; 2636		FILINFO* fno		/* Pointer to the file information to be filled */
; 2637	)
; 2638	{
_get_fileinfo:
.DEFINE "_get_fileinfo"

.VALUE _get_fileinfo

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "get_fileinfo",2638,"_get_fileinfo"

.LINE 2638

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "fno"

.CLASS 65

.VALUE 9

.TAG "NONAME4"

.TYPE 40

.ENDEF

.DEFINE "di"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "si"

.CLASS 65

.VALUE -8

.TYPE 14

.ENDEF

.DEFINE "hs"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -28

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDE
	LD	SP,HL
; 2639		UINT si, di;
; 2640	#if FF_USE_LFN
; 2641		WCHAR wc, hs;
; 2642		FATFS *fs = dp->obj.fs;
.LINE 2642

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFE4),BC
; 2643	#else
; 2644		TCHAR c;
; 2645	#endif
; 2646	
; 2647	
; 2648		fno->fname[0] = 0;			/* Invaidate file info */
.LINE 2648

	LD	IY,(IX+%9)
	LD	(IY+%16),%0
; 2649		if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
.LINE 2649

	LD	IY,(IX+%6)
	LD	HL,(IY+%17)
	LD	E,(IY+%1A)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_541
; 2650	
; 2651	#if FF_USE_LFN		/* LFN configuration */
; 2652	#if FF_FS_EXFAT
; 2653		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
; 2654			get_xfileinfo(fs->dirbuf, fno);
; 2655			return;
; 2656		} else
; 2657	#endif
; 2658		{	/* On the FAT/FAT32 volume */
; 2659			if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
.LINE 2659

	LD	IY,(IX+%6)
	LD	HL,(IY+%2A)
	LD	E,(IY+%2D)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	Z,L_507
; 2660				si = di = hs = 0;
.LINE 2660

	LD	(IX+%FFFFFFF6),%0
	LD	(IX+%FFFFFFF7),%0
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
; 2661				while (fs->lfnbuf[si] != 0) {
.LINE 2661

	JR	L_500
L_501:
; 2662					wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
.LINE 2662

	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFB),C
	LD	(IX+%FFFFFFFC),B
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
; 2663					if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
.LINE 2663

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_497
	LD.LIS	BC,55296
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_497
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,57343
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_497
; 2664						hs = wc; continue;		/* Get low surrogate */
.LINE 2664

	LD	BC,(IX+%FFFFFFFB)
	LD	(IX+%FFFFFFF6),C
	LD	(IX+%FFFFFFF7),B
	JR	L_500
; 2665					}
L_497:
.LINE 2665

; 2666					wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or UTF-8 encoding */
.LINE 2666

	LD	HL,255
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%16
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	PUSH	HL
	PUSH	HL
	UEXT	HL
	PUSH	HL
	INC	SP
	POP	BC
	LD	(IX+%FFFFFFDE),BC	; spill
	POP	DE
	INC	SP
	INC	SP
	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFE1),HL	; spill
	LD	HL,(IX+%FFFFFFDE)
	LD	BC,(IX+%FFFFFFE1)	; unspill
	CALL	__lor
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_put_utf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	C,A
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
; 2667					if (wc == 0) { di = 0; break; }	/* Invalid char or buffer overflow? */
.LINE 2667

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_499
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_503
L_499:
; 2668					di += wc;
.LINE 2668

	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
; 2669					hs = 0;
.LINE 2669

	LD	(IX+%FFFFFFF6),%0
	LD	(IX+%FFFFFFF7),%0
; 2670				}
L_500:
.LINE 2670

	LD	IY,(IX+%FFFFFFE4)
	LD	BC,(IY+%B)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD.LIS	BC,0
	LD	HL,(HL)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_501
L_503:
; 2671				if (hs != 0) di = 0;	/* Broken surrogate pair? */
.LINE 2671

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_504
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
L_504:
; 2672				fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
.LINE 2672

	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),%0
; 2673			}
; 2674		}
L_507:
.LINE 2674

; 2675	
; 2676		si = di = 0;
.LINE 2676

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
; 2677		while (si < 11) {		/* Get SFN from SFN entry */
.LINE 2677

	JR	L_518
L_519:
; 2678			wc = dp->dir[si++];			/* Get a char */
.LINE 2678

	LD	BC,(IX+%FFFFFFF8)
	LD	IY,(IX+%6)
	LD	HL,(IY+%1B)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
; 2679			if (wc == ' ') continue;	/* Skip padding spaces */
.LINE 2679

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_518
; 2680			if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
.LINE 2680

	LD.LIS	BC,5
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_515
	LD	(IX+%FFFFFFFB),%E5
	LD	(IX+%FFFFFFFC),%0
L_515:
; 2681			if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
.LINE 2681

	LD	BC,9
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_517
	LD	BC,12
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_517
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),%2E
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_517:
; 2682	#if FF_LFN_UNICODE >= 1	/* Unicode output */
; 2683			if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) {	/* Make a DBC if needed */
; 2684				wc = wc << 8 | dp->dir[si++];
; 2685			}
; 2686			wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
; 2687			if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
; 2688			wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
; 2689			if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
; 2690			di += wc;
; 2691	#else					/* ANSI/OEM output */
; 2692			fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
.LINE 2692

	LD	A,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%9)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2693	#endif
; 2694		}
L_518:
.LINE 2694

	LD	BC,11
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	C,L_519
; 2695		fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
.LINE 2695

	LD	IY,(IX+%9)
	LEA	BC,IY+%9
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(HL),%0
; 2696	
; 2697		if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
.LINE 2697

	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF3),BC
	LD	A,(IY+%16)
	OR	A,A
	JR	NZ,L_540
; 2698			if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
.LINE 2698

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_536
; 2699				fno->fname[di++] = '?';
.LINE 2699

	LD	IY,(IX+%9)
	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),%3F
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2700			} else {
.LINE 2700

	JR	L_537
L_536:
; 2701				for (si = di = 0; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
.LINE 2701

	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFF8),BC
	JR	L_534
L_532:
; 2702					wc = (WCHAR)fno->altname[si];
.LINE 2702

	LD	HL,(IX+%FFFFFFE7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	(IX+%FFFFFFFB),B
	LD	(IX+%FFFFFFFC),H
; 2703					if (IsUpper(wc) && (dp->dir[DIR_NTres] & ((si >= 9) ? NS_EXT : NS_BODY))) wc += 0x20;
.LINE 2703

	LD.LIS	BC,65
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_531
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,90
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_531
	LD	BC,9
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	C,L_527
	LD	BC,16
	LD	(IX+%FFFFFFEA),BC
	JR	L_528
L_527:
	LD	BC,8
	LD	(IX+%FFFFFFEA),BC
L_528:
	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	B,(IX+%FFFFFFEA)
	LD	A,(IY+%C)
	AND	A,B
	JR	Z,L_531
	LD	IY,(IX+%FFFFFFFB)
	LEA	HL,IY+%20
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
L_531:
; 2704					fno->fname[di] = (TCHAR)wc;
.LINE 2704

	LD	IY,(IX+%9)
	LEA	BC,IY+%16
	LD	(IX+%FFFFFFF3),BC
	LD	A,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFFD)
	LEA	HL,IY+%16
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF8)
	INC	BC
	LD	(IX+%FFFFFFF8),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 2705				}
L_534:
.LINE 2705

	LD	IY,(IX+%9)
	LEA	BC,IY+%9
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFF8)
	LEA	HL,IY+%9
	ADD	HL,BC
	LD	(IX+%FFFFFFE7),HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_532
; 2706			}
L_537:
.LINE 2706

; 2707			fno->fname[di] = 0;	/* Terminate the LFN */
.LINE 2707

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,BC
	LD	(HL),%0
; 2708			if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
.LINE 2708

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LD	A,(IY+%C)
	OR	A,A
	JR	NZ,L_540
	LD	HL,(IX+%FFFFFFED)
	LD	(HL),%0
; 2709		}
L_540:
.LINE 2709

; 2710	
; 2711	#else	/* Non-LFN configuration */
; 2712		si = di = 0;
; 2713		while (si < 11) {		/* Copy name body and extension */
; 2714			c = (TCHAR)dp->dir[si++];
; 2715			if (c == ' ') continue;		/* Skip padding spaces */
; 2716			if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
; 2717			if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
; 2718			fno->fname[di++] = c;
; 2719		}
; 2720		fno->fname[di] = 0;
; 2721	#endif
; 2722	
; 2723		fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
.LINE 2723

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	HL,IY+%B
	LD	A,(HL)
	LD	IY,(IX+%9)
	LD	(IY+%8),A
; 2724		fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
.LINE 2724

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%9)
	LD	(IY+%0),HL
	LD	(IY+%3),E
; 2725		fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
.LINE 2725

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%6),C
	LD	(IY+%7),B
; 2726		fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
.LINE 2726

	LD	IY,(IX+%6)
	LD	IY,(IY+%1B)
	LEA	BC,IY+%18
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%4),C
	LD	(IY+%5),B
; 2727	}
L_541:
.LINE 2727

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_fileinfo ***************************
;Name                         Addr/Register   Size   Type
;fs                                   IX-28      3   variable
;G_25                                 IX-25      3   variable
;temp525                              IX-22      3   variable
;G_29                                 IX-19      3   variable
;G_23                                 IX-16      3   variable
;G_28                                 IX-13      3   variable
;hs                                   IX-10      2   variable
;si                                    IX-8      3   variable
;wc                                    IX-5      2   variable
;di                                    IX-3      3   variable
;fno                                   IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 46 (bytes)
;       Spill Code: -2 (instruction)


.ENDFUNC "get_fileinfo",2727,"_get_fileinfo"
; 2728	
; 2729	#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
; 2730	
; 2731	
; 2732	
; 2733	#if FF_USE_FIND && FF_FS_MINIMIZE <= 1
; 2734	/*-----------------------------------------------------------------------*/
; 2735	/* Pattern matching                                                      */
; 2736	/*-----------------------------------------------------------------------*/
; 2737	
; 2738	static DWORD get_achar (	/* Get a character and advances ptr */
; 2739		const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
; 2740	)
; 2741	{
; 2742		DWORD chr;
; 2743	
; 2744	
; 2745	#if FF_USE_LFN && FF_LFN_UNICODE >= 1	/* Unicode input */
; 2746		chr = tchar2uni(ptr);
; 2747		if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
; 2748		chr = ff_wtoupper(chr);
; 2749	
; 2750	#else									/* ANSI/OEM input */
; 2751		chr = (BYTE)*(*ptr)++;				/* Get a byte */
; 2752		if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
; 2753	#if FF_CODE_PAGE == 0
; 2754		if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
; 2755	#elif FF_CODE_PAGE < 900
; 2756		if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
; 2757	#endif
; 2758	#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
; 2759		if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd byte if needed */
; 2760			chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
; 2761		}
; 2762	#endif
; 2763	
; 2764	#endif
; 2765		return chr;
; 2766	}
; 2767	
; 2768	
; 2769	static int pattern_matching (	/* 0:not matched, 1:matched */
; 2770		const TCHAR* pat,	/* Matching pattern */
; 2771		const TCHAR* nam,	/* String to be tested */
; 2772		int skip,			/* Number of pre-skip chars (number of ?s) */
; 2773		int inf				/* Infinite search (* specified) */
; 2774	)
; 2775	{
; 2776		const TCHAR *pp, *np;
; 2777		DWORD pc, nc;
; 2778		int nm, nx;
; 2779	
; 2780	
; 2781		while (skip--) {				/* Pre-skip name chars */
; 2782			if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
; 2783		}
; 2784		if (*pat == 0 && inf) return 1;	/* (short circuit) */
; 2785	
; 2786		do {
; 2787			pp = pat; np = nam;			/* Top of pattern and name to match */
; 2788			while (1) {
; 2789				if (*pp == '?' || *pp == '*') {	/* Wildcard? */
; 2790					nm = nx = 0;
; 2791					do {				/* Analyze the wildcard block */
; 2792						if (*pp++ == '?') nm++; else nx = 1;
; 2793					} while (*pp == '?' || *pp == '*');
; 2794					if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
; 2795					nc = *np; break;	/* Branch mismatched */
; 2796				}
; 2797				pc = get_achar(&pp);	/* Get a pattern char */
; 2798				nc = get_achar(&np);	/* Get a name char */
; 2799				if (pc != nc) break;	/* Branch mismatched? */
; 2800				if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
; 2801			}
; 2802			get_achar(&nam);			/* nam++ */
; 2803		} while (inf && nc);			/* Retry until end of name if infinite search is specified */
; 2804	
; 2805		return 0;
; 2806	}
; 2807	
; 2808	#endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
; 2809	
; 2810	
; 2811	
; 2812	/*-----------------------------------------------------------------------*/
; 2813	/* Pick a top segment and create the object name in directory form       */
; 2814	/*-----------------------------------------------------------------------*/
; 2815	
; 2816	static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
; 2817		DIR* dp,					/* Pointer to the directory object */
; 2818		const TCHAR** path			/* Pointer to pointer to the segment in the path string */
; 2819	)
; 2820	{
_create_name:
.DEFINE "_create_name"

.VALUE _create_name

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "create_name",2820,"_create_name"

.LINE 2820

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 1570

.ENDEF

.DEFINE "di"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "wc"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

.DEFINE "cf"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

.DEFINE "si"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "lfn"

.CLASS 65

.VALUE -16

.TYPE 45

.ENDEF

.DEFINE "uc"

.CLASS 65

.VALUE -20

.TYPE 15

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -23

.TYPE 194

.ENDEF

.DEFINE "ni"

.CLASS 65

.VALUE -26

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD1
	LD	SP,HL
; 2821	#if FF_USE_LFN		/* LFN configuration */
; 2822		BYTE b, cf;
; 2823		WCHAR wc, *lfn;
; 2824		DWORD uc;
; 2825		UINT i, ni, si, di;
; 2826		const TCHAR *p;
; 2827	
; 2828	
; 2829		/* Create LFN into LFN working buffer */
; 2830		p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
.LINE 2830

	LD	HL,(IX+%9)
	LD	BC,(HL)
	LD	(IX+%FFFFFFE9),BC
	LD	IY,(IX+%6)
	LD	IY,(IY+%0)
	LD	BC,(IY+%B)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2831		while (1) {
L_558:
.LINE 2831

; 2832			uc = tchar2uni(&p);			/* Get a character */
.LINE 2832

	PEA	IX+%FFFFFFE9
	CALL	_tchar2uni
	POP	BC
	LD	(IX+%FFFFFFEC),HL
	LD	(IX+%FFFFFFEF),E
; 2833			if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
.LINE 2833

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_545
	LD	HL,6
	JR	L_655
L_545:
; 2834			if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
.LINE 2834

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,65536
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_546
	UEXT	HL
	PUSH	HL
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	INC	SP
	POP	BC
	INC	SP
	INC	SP
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF0)
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_546:
; 2835			wc = (WCHAR)uc;
; 2836			if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is found */
.LINE 2836

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_561
	LD.LIS	BC,47
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_561
	LD.LIS	BC,92
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_561
; 2837			if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
.LINE 2837

	LD.LIS	BC,128
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_554
	LD	BC,(IX+%FFFFFFEC)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__283
	PUSH	BC
	CALL	_chk_chr
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_554
	LD	HL,6
	JR	L_655
L_554:
; 2838			if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
.LINE 2838

	LD	BC,255
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_556
	LD	HL,6
	JR	L_655
L_556:
; 2839			lfn[di++] = wc;					/* Store the Unicode character */
.LINE 2839

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFEC)
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	JR	L_558
; 2840		}
; 2841		while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
L_562:
.LINE 2841

	LD	BC,(IX+%FFFFFFE9)
	LD	(IX+%FFFFFFD1),BC
	LD	BC,(IX+%FFFFFFE9)
	INC	BC
	LD	(IX+%FFFFFFE9),BC
L_561:
	LD	HL,(IX+%FFFFFFE9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_562
	LD	HL,(IX+%FFFFFFE9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_562
; 2842		*path = p;							/* Return pointer to the next segment */
.LINE 2842

	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFE9)
	LD	(HL),BC
; 2843		cf = (wc < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
.LINE 2843

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFEC)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_567
	LD	BC,4
	LD	(IX+%FFFFFFE3),BC
	JR	L_568
L_567:
	LD	BC,0
	LD	(IX+%FFFFFFE3),BC
L_568:
	LD	A,(IX+%FFFFFFE3)
	LD	(IX+%FFFFFFFA),A
; 2844	
; 2845	#if FF_FS_RPATH != 0
; 2846		if ((di == 1 && lfn[di - 1] == '.') ||
.LINE 2846

	LD	BC,1
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_572
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFF
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	Z,L_582
L_572:
; 2847			(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
.LINE 2847

	LD	BC,2
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_587
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFF
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_587
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%FFFFFFFE
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_587
L_582:
; 2848			lfn[di] = 0;
.LINE 2848

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 2849			for (i = 0; i < 11; i++) {		/* Create dot name for SFN entry */
.LINE 2849

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_580
L_578:
; 2850				dp->fn[i] = (i < di) ? '.' : ' ';
.LINE 2850

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_576
	LD	BC,46
	LD	(IX+%FFFFFFE0),BC
	JR	L_577
L_576:
	LD	BC,32
	LD	(IX+%FFFFFFE0),BC
L_577:
	LD	A,(IX+%FFFFFFE0)
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
; 2851			}
L_580:
.LINE 2851

	LD	BC,11
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	C,L_578
; 2852			dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
.LINE 2852

	LD	A,(IX+%FFFFFFFA)
	SET	%5,A
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
; 2853			return FR_OK;
.LINE 2853

	OR	A,A
	SBC	HL,HL
	JR	L_655
; 2854		}
.LINE 2854

; 2855	#endif
; 2856		while (di) {						/* Snip off trailing spaces and dots if exist */
.LINE 2856

L_588:
; 2857			wc = lfn[di - 1];
.LINE 2857

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFDD),IY
	LD	HL,(IX+%FFFFFFDD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFB),C
	LD	(IX+%FFFFFFFC),B
; 2858			if (wc != ' ' && wc != '.') break;
.LINE 2858

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_586
	LD.LIS	BC,46
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_590
L_586:
; 2859			di--;
.LINE 2859

	LD	BC,(IX+%FFFFFFDD)
	LD	(IX+%FFFFFFFD),BC
; 2860		}
L_587:
.LINE 2860

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_588
L_590:
; 2861		lfn[di] = 0;							/* LFN is created into the working buffer */
.LINE 2861

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 2862		if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
.LINE 2862

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_596
	LD	HL,6
	JR	L_655
L_596:
; 2863	
; 2864		/* Create SFN in directory form */
; 2865		for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
.LINE 2865

	LD	(IX+%FFFFFFF3),BC
	JR	L_595
L_593:
	LD	BC,(IX+%FFFFFFF3)
	INC	BC
	LD	(IX+%FFFFFFF3),BC
L_595:
	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(IX+%FFFFFFDA),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_593
; 2866		if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
.LINE 2866

	LD	BC,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_598
	LD	HL,(IX+%FFFFFFDA)
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_602
L_598:
	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
; 2867		while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
.LINE 2867

	JR	L_602
L_603:
	LD	BC,(IX+%FFFFFFD7)
	LD	(IX+%FFFFFFFD),BC
L_602:
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_605
	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFD7),IY
	LD	HL,(IX+%FFFFFFD7)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_603
L_605:
; 2868	
; 2869		mem_set(dp->fn, ' ', 11);
.LINE 2869

	LD	BC,11
	PUSH	BC
	LD	BC,32
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%1E
	CALL	_mem_set
	POP	BC
	POP	BC
	POP	BC
; 2870		i = b = 0; ni = 8;
.LINE 2870

	LD	(IX+%FFFFFFF6),%0
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	LD	BC,8
	LD	(IX+%FFFFFFE6),BC
; 2871		while (1) {
L_641:
.LINE 2871

; 2872			wc = lfn[si++];					/* Get an LFN character */
.LINE 2872

	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFB),C
	LD	(IX+%FFFFFFFC),B
	LD	BC,(IX+%FFFFFFF3)
	INC	BC
	LD	(IX+%FFFFFFF3),BC
; 2873			if (wc == 0) break;				/* Break on end of the LFN */
.LINE 2873

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_643
; 2874			if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
.LINE 2874

	LD.LIS	BC,32
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_610
	LD.LIS	BC,46
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_620
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_620
L_610:
; 2875				cf |= NS_LOSS | NS_LFN;
.LINE 2875

	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
; 2876				continue;
.LINE 2876

	JR	L_641
; 2877			}
L_620:
.LINE 2877

; 2878	
; 2879			if (i >= ni || si == di) {		/* End of field? */
.LINE 2879

	LD	BC,(IX+%FFFFFFE6)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_619
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_623
L_619:
; 2880				if (ni == 11) {				/* Name extension overflow? */
.LINE 2880

	LD	BC,11
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_615
; 2881					cf |= NS_LOSS | NS_LFN;
.LINE 2881

	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
; 2882					break;
.LINE 2882

	JR	L_643
; 2883				}
L_615:
.LINE 2883

; 2884				if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
.LINE 2884

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_617
	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
L_617:
; 2885				if (si > di) break;						/* No name extension? */
.LINE 2885

	LD	BC,(IX+%FFFFFFF3)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_643
; 2886				si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
.LINE 2886

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,8
	LD	(IX+%FFFFFFF7),BC
	LD	BC,11
	LD	(IX+%FFFFFFE6),BC
	LD	A,(IX+%FFFFFFF6)
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFF6),A
; 2887				continue;
.LINE 2887

	JR	L_641
; 2888			}
L_623:
.LINE 2888

; 2889	
; 2890			if (wc >= 0x80) {	/* Is this a non-ASCII character? */
.LINE 2890

	LD.LIS	BC,128
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_637
; 2891				cf |= NS_LFN;	/* LFN entry needs to be created */
.LINE 2891

	LD	A,(IX+%FFFFFFFA)
	SET	%1,A
	LD	(IX+%FFFFFFFA),A
; 2892	#if FF_CODE_PAGE == 0
; 2893				if (ExCvt) {	/* At SBCS */
; 2894					wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
; 2895					if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
; 2896				} else {		/* At DBCS */
; 2897					wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
; 2898				}
; 2899	#elif FF_CODE_PAGE < 900	/* SBCS cfg */
; 2900				wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
.LINE 2900

	LD	BC,437
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	LD	C,%0
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_ff_uni2oem
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
; 2901				if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
.LINE 2901

	LD	A,(IX+%FFFFFFFB)
	AND	A,%80
	LD	C,A
	LD	B,%0
	LD.LIS	DE,0
	LD	HL,BC
	OR	A,A
	SBC.SIS	HL,DE
	JR	Z,L_637
	LD	A,(IX+%FFFFFFFB)
	RES	%7,A
	LD	C,A
	CALL	__stoiu
	LD	BC,_ExCvt
	ADD	HL,BC
	LD	C,(HL)
	LD	B,%0
	LD	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
; 2902	#else						/* DBCS cfg */
; 2903				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
; 2904	#endif
; 2905			}
L_637:
.LINE 2905

; 2906	
; 2907			if (wc >= 0x100) {				/* Is this a DBC? */
.LINE 2907

	LD.LIS	BC,256
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_636
; 2908				if (i >= ni - 1) {			/* Field overflow? */
.LINE 2908

	LD	IY,(IX+%FFFFFFE6)
	LEA	BC,IY+%FFFFFFFF
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	C,L_626
; 2909					cf |= NS_LOSS | NS_LFN;
.LINE 2909

	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
; 2910					i = ni; continue;		/* Next field */
.LINE 2910

	LD	BC,(IX+%FFFFFFE6)
	LD	(IX+%FFFFFFF7),BC
	JR	L_641
; 2911				}
L_626:
.LINE 2911

; 2912				dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
.LINE 2912

	LD	DE,(IX+%FFFFFFF7)
	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	LD	BC,HL
	DEC	SP
	PUSH	BC
	INC	SP
	POP	AF
	SEXT	HL
	PUSH	HL
	PUSH	BC
	INC	SP
	POP	HL
	INC	SP
	INC	SP
	LD	A,L
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,DE
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
; 2913			} else {						/* SBC */
.LINE 2913

	JR	L_639
L_636:
; 2914				if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
.LINE 2914

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_633
	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	PUSH	HL
	LD	BC,L__319
	PUSH	BC
	CALL	_chk_chr
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_634
L_633:
; 2915					wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
.LINE 2915

	LD	(IX+%FFFFFFFB),%5F
	LD	(IX+%FFFFFFFC),%0
	LD	A,(IX+%FFFFFFFA)
	OR	A,%3
	LD	(IX+%FFFFFFFA),A
; 2916				} else {
.LINE 2916

	JR	L_639
L_634:
; 2917					if (IsUpper(wc)) {		/* ASCII upper case? */
.LINE 2917

	LD.LIS	BC,65
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_632
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,90
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_632
; 2918						b |= 2;
.LINE 2918

	LD	A,(IX+%FFFFFFF6)
	SET	%1,A
	LD	(IX+%FFFFFFF6),A
; 2919					}
L_632:
.LINE 2919

; 2920					if (IsLower(wc)) {		/* ASCII lower case? */
.LINE 2920

	LD.LIS	BC,97
	LD	HL,(IX+%FFFFFFFB)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_639
	LD	BC,(IX+%FFFFFFFB)
	LD.LIS	HL,122
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_639
; 2921						b |= 1; wc -= 0x20;
.LINE 2921

	LD	A,(IX+%FFFFFFF6)
	SET	%0,A
	LD	(IX+%FFFFFFF6),A
	LD	IY,(IX+%FFFFFFFB)
	LEA	HL,IY+%FFFFFFE0
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
; 2922					}
; 2923				}
; 2924			}
L_639:
.LINE 2924

; 2925			dp->fn[i++] = (BYTE)wc;
.LINE 2925

	LD	A,(IX+%FFFFFFFB)
	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%6)
	LEA	HL,IY+%1E
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
	JR	L_641
; 2926		}
L_643:
.LINE 2926

; 2927	
; 2928		if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
.LINE 2928

	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFD4),BC
	LD	A,(IY+%1E)
	UEXT	HL
	LD	L,A
	LD	BC,229
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_645
	LD	IY,(IX+%6)
	LEA	BC,IY+%1E
	LD	(IX+%FFFFFFD4),BC
	LD	(IY+%1E),%5
L_645:
; 2929	
; 2930		if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
.LINE 2930

	LD	BC,8
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_648
	LD	A,(IX+%FFFFFFF6)
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFF6),A
L_648:
; 2931		if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
.LINE 2931

	LD	A,(IX+%FFFFFFF6)
	AND	A,%C
	CP	A,%C
	JR	Z,L_647
	LD	A,(IX+%FFFFFFF6)
	AND	A,%3
	CP	A,%3
	JR	NZ,L_653
L_647:
	LD	A,(IX+%FFFFFFFA)
	SET	%1,A
	LD	(IX+%FFFFFFFA),A
L_653:
; 2932		if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
.LINE 2932

	LD	A,(IX+%FFFFFFFA)
	AND	A,%2
	JR	NZ,L_654
; 2933			if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
.LINE 2933

	LD	A,(IX+%FFFFFFF6)
	AND	A,%1
	JR	Z,L_651
	LD	A,(IX+%FFFFFFFA)
	SET	%4,A
	LD	(IX+%FFFFFFFA),A
L_651:
; 2934			if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
.LINE 2934

	LD	A,(IX+%FFFFFFF6)
	AND	A,%4
	JR	Z,L_654
	LD	A,(IX+%FFFFFFFA)
	SET	%3,A
	LD	(IX+%FFFFFFFA),A
; 2935		}
L_654:
.LINE 2935

; 2936	
; 2937		dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
.LINE 2937

	LD	IY,(IX+%FFFFFFD4)
	LEA	HL,IY+%B
	LD	A,(IX+%FFFFFFFA)
	LD	(HL),A
; 2938	
; 2939		return FR_OK;
.LINE 2939

	OR	A,A
	SBC	HL,HL
; 2940	
; 2941	
; 2942	#else	/* FF_USE_LFN : Non-LFN configuration */
; 2943		BYTE c, d, *sfn;
; 2944		UINT ni, si, i;
; 2945		const char *p;
; 2946	
; 2947		/* Create file name in directory form */
; 2948		p = *path; sfn = dp->fn;
; 2949		mem_set(sfn, ' ', 11);
; 2950		si = i = 0; ni = 8;
; 2951	#if FF_FS_RPATH != 0
; 2952		if (p[si] == '.') { /* Is this a dot entry? */
; 2953			while (1) {
; 2954				c = (BYTE)p[si++];
; 2955				if (c != '.' || si >= 3) break;
; 2956				sfn[i++] = c;
; 2957			}
; 2958			if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
; 2959			*path = p + si;								/* Return pointer to the next segment */
; 2960			sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
; 2961			return FR_OK;
; 2962		}
; 2963	#endif
; 2964		while (1) {
; 2965			c = (BYTE)p[si++];				/* Get a byte */
; 2966			if (c <= ' ') break; 			/* Break if end of the path name */
; 2967			if (c == '/' || c == '\\') {	/* Break if a separator is found */
; 2968				while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
; 2969				break;
; 2970			}
; 2971			if (c == '.' || i >= ni) {		/* End of body or field overflow? */
; 2972				if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
; 2973				i = 8; ni = 11;				/* Enter file extension field */
; 2974				continue;
; 2975			}
; 2976	#if FF_CODE_PAGE == 0
; 2977			if (ExCvt && c >= 0x80) {		/* Is SBC extended character? */
; 2978				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
; 2979			}
; 2980	#elif FF_CODE_PAGE < 900
; 2981			if (c >= 0x80) {				/* Is SBC extended character? */
; 2982				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
; 2983			}
; 2984	#endif
; 2985			if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
; 2986				d = (BYTE)p[si++];			/* Get 2nd byte */
; 2987				if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
; 2988				sfn[i++] = c;
; 2989				sfn[i++] = d;
; 2990			} else {						/* SBC */
; 2991				if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
; 2992				if (IsLower(c)) c -= 0x20;	/* To upper */
; 2993				sfn[i++] = c;
; 2994			}
; 2995		}
; 2996		*path = p + si;						/* Return pointer to the next segment */
; 2997		if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
; 2998	
; 2999		if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
; 3000		sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
; 3001	
; 3002		return FR_OK;
; 3003	#endif /* FF_USE_LFN */
; 3004	}
L_655:
.LINE 3004

	LD	SP,IX
	POP	IX
	RET	


;**************************** _create_name ***************************
;Name                         Addr/Register   Size   Type
;_ExCvt                              STATIC    128   variable
;_ff_uni2oem                         IMPORT  -----   function
;G_34                                 IX-44      3   variable
;G_32                                 IX-41      3   variable
;G_31                                 IX-38      3   variable
;G_30                                 IX-35      3   variable
;temp574                              IX-32      3   variable
;temp565                              IX-29      3   variable
;ni                                   IX-26      3   variable
;p                                    IX-23      3   variable
;uc                                   IX-20      4   variable
;lfn                                  IX-16      3   variable
;si                                   IX-13      3   variable
;b                                    IX-10      1   variable
;i                                     IX-9      3   variable
;cf                                    IX-6      1   variable
;wc                                    IX-5      2   variable
;di                                    IX-3      3   variable
;path                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 59 (bytes)
;       Spill Code: -2 (instruction)


.ENDFUNC "create_name",3004,"_create_name"
	SEGMENT STRSECT
L__283:
	DB	"\"*:<>?|"
	DB	127,0
L__319:
	DB	"+,;=[]"
	DB	0
	SEGMENT CODE
; 3005	
; 3006	
; 3007	
; 3008	
; 3009	/*-----------------------------------------------------------------------*/
; 3010	/* Follow a file path                                                    */
; 3011	/*-----------------------------------------------------------------------*/
; 3012	
; 3013	static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
; 3014		DIR* dp,					/* Directory object to return last directory and found object */
; 3015		const TCHAR* path			/* Full-path string to find a file or directory */
; 3016	)
; 3017	{
_follow_path:
.DEFINE "_follow_path"

.VALUE _follow_path

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "follow_path",3017,"_follow_path"

.LINE 3017

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "ns"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -7

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
; 3018		FRESULT res;
; 3019		BYTE ns;
; 3020		FATFS *fs = dp->obj.fs;
.LINE 3020

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
; 3021	
; 3022	
; 3023	#if FF_FS_RPATH != 0
; 3024		if (*path != '/' && *path != '\\') {	/* Without heading separator */
.LINE 3024

	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_659
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_659
; 3025			dp->obj.sclust = fs->cdir;				/* Start from current directory */
.LINE 3025

	LD	IY,(IX+%FFFFFFF9)
	LD	BC,(IY+%16)
	LD	A,(IY+%19)
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 3026		} else
.LINE 3026

	JR	L_683
; 3027	#endif
; 3028		{										/* With heading separator */
; 3029			while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
.LINE 3029

L_660:
	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%9)
	INC	BC
	LD	(IX+%9),BC
L_659:
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JR	Z,L_660
	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	Z,L_660
; 3030			dp->obj.sclust = 0;					/* Start from root directory */
.LINE 3030

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),%0
; 3031		}
L_683:
.LINE 3031

; 3032	#if FF_FS_EXFAT
; 3033		dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
; 3034	#if FF_FS_RPATH != 0
; 3035		if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {	/* exFAT: Retrieve the sub-directory's status */
; 3036			DIR dj;
; 3037	
; 3038			dp->obj.c_scl = fs->cdc_scl;
; 3039			dp->obj.c_size = fs->cdc_size;
; 3040			dp->obj.c_ofs = fs->cdc_ofs;
; 3041			res = load_obj_xdir(&dj, &dp->obj);
; 3042			if (res != FR_OK) return res;
; 3043			dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
; 3044			dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
; 3045		}
; 3046	#endif
; 3047	#endif
; 3048	
; 3049		if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
.LINE 3049

	LD	HL,(IX+%9)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	NC,L_680
; 3050			dp->fn[NSFLAG] = NS_NONAME;
.LINE 3050

	LD	IY,(IX+%6)
	LEA	HL,IY+%29
	LD	(HL),%80
; 3051			res = dir_sdi(dp, 0);
.LINE 3051

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3052	
; 3053		} else {								/* Follow path */
.LINE 3053

	JR	L_684
; 3054			while (1) {
L_680:
.LINE 3054

; 3055				res = create_name(dp, &path);	/* Get a segment name of the path */
.LINE 3055

	PEA	IX+%9
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_create_name
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3056				if (res != FR_OK) break;
.LINE 3056

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_684
; 3057				res = dir_find(dp);				/* Find an object with the segment name */
.LINE 3057

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_find
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3058				ns = dp->fn[NSFLAG];
.LINE 3058

	LD	IY,(IX+%6)
	LEA	IY,IY+%29
	LD	(IX+%FFFFFFF6),IY
	LD	HL,(IX+%FFFFFFF6)
	LD	A,(HL)
	LD	(IX+%FFFFFFFC),A
; 3059				if (res != FR_OK) {				/* Failed to find the object */
.LINE 3059

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_675
; 3060					if (res == FR_NO_FILE) {	/* Object is not found */
.LINE 3060

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_684
; 3061						if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
.LINE 3061

	LD	A,(IX+%FFFFFFFC)
	AND	A,%20
	JR	Z,L_670
; 3062							if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
.LINE 3062

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	Z,L_680
; 3063							dp->fn[NSFLAG] = NS_NONAME;
.LINE 3063

	LD	HL,(IX+%FFFFFFF6)
	LD	(HL),%80
; 3064							res = FR_OK;
.LINE 3064

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 3065						} else {							/* Could not find the object */
.LINE 3065

	JR	L_684
L_670:
; 3066							if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
.LINE 3066

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	NZ,L_684
	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 3067						}
; 3068					}
.LINE 3068

; 3069					break;
.LINE 3069

	JR	L_684
; 3070				}
L_675:
.LINE 3070

; 3071				if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
.LINE 3071

	LD	A,(IX+%FFFFFFFC)
	AND	A,%4
	JR	NZ,L_684
; 3072				/* Get into the sub-directory */
; 3073				if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
.LINE 3073

	LD	IY,(IX+%6)
	LD	A,(IY+%5)
	AND	A,%10
	JR	NZ,L_678
; 3074					res = FR_NO_PATH; break;
.LINE 3074

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
	JR	L_684
; 3075				}
L_678:
.LINE 3075

; 3076	#if FF_FS_EXFAT
; 3077				if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
; 3078					dp->obj.c_scl = dp->obj.sclust;
; 3079					dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
; 3080					dp->obj.c_ofs = dp->blk_ofs;
; 3081					init_alloc_info(fs, &dp->obj);	/* Open next directory */
; 3082				} else
; 3083	#endif
; 3084				{
; 3085					dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
.LINE 3085

	LD	IY,(IX+%6)
	LD	HL,(IY+%F)
	LD	E,(IY+%12)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFF9)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%7),HL
	LD	(IY+%A),E
	JR	L_680
; 3086				}
; 3087			}
; 3088		}
L_684:
.LINE 3088

; 3089	
; 3090		return res;
.LINE 3090

	LD	HL,(IX+%FFFFFFFD)
; 3091	}
.LINE 3091

	LD	SP,IX
	POP	IX
	RET	


;**************************** _follow_path ***************************
;Name                         Addr/Register   Size   Type
;G_36                                 IX-10      3   variable
;fs                                    IX-7      3   variable
;ns                                    IX-4      1   variable
;res                                   IX-3      3   variable
;path                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: -2 (instruction)


.ENDFUNC "follow_path",3091,"_follow_path"
; 3092	
; 3093	
; 3094	
; 3095	
; 3096	/*-----------------------------------------------------------------------*/
; 3097	/* Get logical drive number from path name                               */
; 3098	/*-----------------------------------------------------------------------*/
; 3099	
; 3100	static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
; 3101		const TCHAR** path		/* Pointer to pointer to the path name */
; 3102	)
; 3103	{
_get_ldnumber:
.DEFINE "_get_ldnumber"

.VALUE _get_ldnumber

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "get_ldnumber",3103,"_get_ldnumber"

.LINE 3103

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "tp"

.CLASS 65

.VALUE -3

.TYPE 194

.ENDEF

.DEFINE "tt"

.CLASS 65

.VALUE -6

.TYPE 194

.ENDEF

.DEFINE "tc"

.CLASS 65

.VALUE -7

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -10

.TYPE 4

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -13

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 3104		const TCHAR *tp, *tt;
; 3105		TCHAR tc;
; 3106		int i, vol = -1;
.LINE 3106

	LD	BC,16777215
	LD	(IX+%FFFFFFF3),BC
; 3107	#if FF_STR_VOLUME_ID		/* Find string volume ID */
; 3108		const char *sp;
; 3109		char c;
; 3110	#endif
; 3111	
; 3112		tt = tp = *path;
.LINE 3112

	LD	HL,(IX+%6)
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFFA),BC
; 3113		if (!tp) return vol;	/* Invalid path name? */
.LINE 3113

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_689
	LD	HL,16777215
	JR	L_701
; 3114		do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
L_689:
.LINE 3114

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	A,(IX+%FFFFFFF9)
	CP	A,%20
	JR	C,L_699
	LD	A,(IX+%FFFFFFF9)
	CP	A,%3A
	JR	NZ,L_689
L_699:
; 3115	
; 3116		if (tc == ':') {	/* DOS/Windows style volume ID? */
.LINE 3116

	LD	A,(IX+%FFFFFFF9)
	CP	A,%3A
	JR	NZ,L_700
; 3117			i = FF_VOLUMES;
.LINE 3117

	LD	BC,1
	LD	(IX+%FFFFFFF6),BC
; 3118			if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
.LINE 3118

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L_696
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	M,L__355
	JP	PE,L_696
	JR	L__356
L__355:
	JP	PO,L_696
L__356:
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2
	LD	BC,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_696
; 3119				i = (int)*tp - '0';	/* Get the LD number */
.LINE 3119

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	IY,IY+%FFFFFFD0
	LD	(IX+%FFFFFFF6),IY
; 3120			}
L_696:
.LINE 3120

; 3121	#if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
; 3122			else {
; 3123				i = 0;
; 3124				do {
; 3125					sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
; 3126					do {	/* Compare the volume ID with path name */
; 3127						c = *sp++; tc = *tp++;
; 3128						if (IsLower(c)) c -= 0x20;
; 3129						if (IsLower(tc)) tc -= 0x20;
; 3130					} while (c && (TCHAR)c == tc);
; 3131				} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
; 3132			}
; 3133	#endif
; 3134			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
.LINE 3134

	LD	BC,1
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC	HL,BC
	JP	P,L__357
	JP	PE,L_697
	JR	L__358
L__357:
	JP	PO,L_697
L__358:
; 3135				vol = i;		/* Drive number */
.LINE 3135

	LD	BC,(IX+%FFFFFFF6)
	LD	(IX+%FFFFFFF3),BC
; 3136				*path = tt;		/* Snip the drive prefix off */
.LINE 3136

	LD	HL,(IX+%6)
	LD	BC,(IX+%FFFFFFFA)
	LD	(HL),BC
; 3137			}
L_697:
.LINE 3137

; 3138			return vol;
.LINE 3138

	LD	HL,(IX+%FFFFFFF3)
	JR	L_701
; 3139		}
L_700:
.LINE 3139

; 3140	#if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
; 3141		if (*tp == '/') {
; 3142			i = 0;
; 3143			do {
; 3144				sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
; 3145				do {	/* Compare the volume ID with path name */
; 3146					c = *sp++; tc = *(++tp);
; 3147					if (IsLower(c)) c -= 0x20;
; 3148					if (IsLower(tc)) tc -= 0x20;
; 3149				} while (c && (TCHAR)c == tc);
; 3150			} while ((c || (tc != '/' && (UINT)tc >= (FF_USE_LFN ? ' ' : '!'))) && ++i < FF_VOLUMES);	/* Repeat for each ID until pattern match */
; 3151			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
; 3152				vol = i;		/* Drive number */
; 3153				*path = tp;		/* Snip the drive prefix off */
; 3154				return vol;
; 3155			}
; 3156		}
; 3157	#endif
; 3158		/* No drive prefix is found */
; 3159	#if FF_FS_RPATH != 0
; 3160		vol = CurrVol;	/* Default drive is current drive */
.LINE 3160

	LD	A,(_CurrVol)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF3),HL
; 3161	#else
; 3162		vol = 0;		/* Default drive is 0 */
; 3163	#endif
; 3164		return vol;		/* Return the default drive */
.LINE 3164

	LD	A,(_CurrVol)
	UEXT	HL
	LD	L,A
; 3165	}
L_701:
.LINE 3165

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_ldnumber ***************************
;Name                         Addr/Register   Size   Type
;_CurrVol                            STATIC      1   variable
;vol                                  IX-13      3   variable
;i                                    IX-10      3   variable
;tc                                    IX-7      1   variable
;tt                                    IX-6      3   variable
;tp                                    IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: -2 (instruction)


.ENDFUNC "get_ldnumber",3165,"_get_ldnumber"
; 3166	
; 3167	
; 3168	
; 3169	
; 3170	/*-----------------------------------------------------------------------*/
; 3171	/* Load a sector and check if it is an FAT VBR                           */
; 3172	/*-----------------------------------------------------------------------*/
; 3173	
; 3174	static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
; 3175		FATFS* fs,			/* Filesystem object */
; 3176		DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
; 3177	)
; 3178	{
_check_fs:
.DEFINE "_check_fs"

.VALUE _check_fs

.CLASS 3

.TYPE 76

.ENDEF

.BEGFUNC "check_fs",3178,"_check_fs"

.LINE 3178

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 3179		fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
.LINE 3179

	LD	IY,(IX+%6)
	LD	(IY+%3),%0
	LD	BC,16777215
	LD	(IY+%32),BC
	LD	(IY+%35),%FF
; 3180		if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
.LINE 3180

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_704
	LD	A,%4
	JR	L_713
L_704:
; 3181	
; 3182		if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
.LINE 3182

	LD	IY,(IX+%6)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFFD),BC
	LD	BC,510
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,43605
	OR	A,A
	SBC	HL,BC
	JR	Z,L_711
	LD	A,%3
	JR	L_713
L_711:
; 3183	
; 3184	#if FF_FS_EXFAT
; 3185		if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
; 3186	#endif
; 3187		if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
.LINE 3187

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,233
	OR	A,A
	SBC	HL,BC
	JR	Z,L_710
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,235
	OR	A,A
	SBC	HL,BC
	JR	Z,L_710
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,232
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_712
L_710:
; 3188			if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
.LINE 3188

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,3
	PUSH	BC
	LD	BC,L__365
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%36
	PUSH	BC
	CALL	_mem_cmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_709
	XOR	A,A
	JR	L_713
L_709:
; 3189			if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
.LINE 3189

	LD	BC,5
	PUSH	BC
	LD	BC,L__367
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%52
	PUSH	BC
	CALL	_mem_cmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_712
	XOR	A,A
	JR	L_713
; 3190		}
L_712:
.LINE 3190

; 3191		return 2;	/* Valid BS but not FAT */
.LINE 3191

	LD	A,%2
; 3192	}
L_713:
.LINE 3192

	LD	SP,IX
	POP	IX
	RET	


;**************************** _check_fs ***************************
;Name                         Addr/Register   Size   Type
;G_42                                  IX-9      3   variable
;G_41                                  IX-6      3   variable
;G_38                                  IX-3      3   variable
;sect                                  IX+9      4   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: -2 (instruction)


.ENDFUNC "check_fs",3192,"_check_fs"
	SEGMENT STRSECT
L__365:
	DB	"FAT"
	DB	0
L__367:
	DB	"FAT32"
	DB	0
	SEGMENT CODE
; 3193	
; 3194	
; 3195	
; 3196	
; 3197	/*-----------------------------------------------------------------------*/
; 3198	/* Determine logical drive number and mount the volume if needed         */
; 3199	/*-----------------------------------------------------------------------*/
; 3200	
; 3201	static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
; 3202		const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
; 3203		FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
; 3204		BYTE mode					/* !=0: Check write protection for write access */
; 3205	)
; 3206	{
_find_volume:
.DEFINE "_find_volume"

.VALUE _find_volume

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "find_volume",3206,"_find_volume"

.LINE 3206

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 1570

.ENDEF

.DEFINE "rfs"

.CLASS 65

.VALUE 9

.TAG "NONAME0"

.TYPE 296

.ENDEF

.DEFINE "mode"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "fmt"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "stat"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "bsect"

.CLASS 65

.VALUE -12

.TYPE 15

.ENDEF

.DEFINE "fasize"

.CLASS 65

.VALUE -16

.TYPE 15

.ENDEF

.DEFINE "nclst"

.CLASS 65

.VALUE -27

.TYPE 15

.ENDEF

.DEFINE "nrsv"

.CLASS 65

.VALUE -29

.TYPE 13

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -38

.TYPE 4

.ENDEF

.DEFINE "tsect"

.CLASS 65

.VALUE -42

.TYPE 15

.ENDEF

.DEFINE "pt"

.CLASS 65

.VALUE -45

.TYPE 44

.ENDEF

.DEFINE "sysect"

.CLASS 65

.VALUE -52

.TYPE 15

.ENDEF

.DEFINE "szbfat"

.CLASS 65

.VALUE -69

.TYPE 15

.ENDEF

.DEFINE "br"

.CLASS 65

.VALUE -89

.DIM 4

.TYPE 111

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFF97
	LD	SP,HL
; 3207		BYTE fmt, *pt;
; 3208		int vol;
; 3209		DSTATUS stat;
; 3210		DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
; 3211		WORD nrsv;
; 3212		FATFS *fs;
; 3213		UINT i;
; 3214	
; 3215	
; 3216		/* Get logical drive number */
; 3217		*rfs = 0;
.LINE 3217

	LD	HL,(IX+%9)
	LD	BC,0
	LD	(HL),BC
; 3218		vol = get_ldnumber(path);
.LINE 3218

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFDA),HL
; 3219		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 3219

	LD	BC,0
	LD	HL,(IX+%FFFFFFDA)
	OR	A,A
	SBC	HL,BC
	JP	P,L__415
	JP	PE,L_715
	JR	L__416
L__415:
	JP	PO,L_715
L__416:
	LD	HL,11
	JR	L_806
L_715:
; 3220	
; 3221		/* Check if the filesystem object is valid or not */
; 3222		fs = FatFs[vol];					/* Get pointer to the filesystem object */
.LINE 3222

	LD	HL,(IX+%FFFFFFDA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_FatFs
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
; 3223		if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
.LINE 3223

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_717
	LD	HL,12
	JR	L_806
L_717:
; 3224	#if FF_FS_REENTRANT
; 3225		if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
; 3226	#endif
; 3227		*rfs = fs;							/* Return pointer to the filesystem object */
.LINE 3227

	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFFD)
	LD	(HL),BC
; 3228	
; 3229		mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
.LINE 3229

	LD	A,(IX+%C)
	RES	%0,A
	LD	(IX+%C),A
; 3230		if (fs->fs_type != 0) {				/* If the volume has been mounted */
.LINE 3230

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	OR	A,A
	JR	Z,L_723
; 3231			stat = disk_status(fs->pdrv);
.LINE 3231

	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_status
	POP	BC
	LD	(IX+%FFFFFFF8),A
; 3232			if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
.LINE 3232

	AND	A,%1
	JR	NZ,L_723
; 3233				if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
.LINE 3233

	LD	A,(IX+%C)
	OR	A,A
	JR	Z,L_720
	LD	A,(IX+%FFFFFFF8)
	AND	A,%4
	JR	Z,L_720
; 3234					return FR_WRITE_PROTECTED;
.LINE 3234

	LD	HL,10
	JR	L_806
; 3235				}
L_720:
.LINE 3235

; 3236				return FR_OK;				/* The filesystem object is valid */
.LINE 3236

	OR	A,A
	SBC	HL,HL
	JR	L_806
; 3237			}
; 3238		}
L_723:
.LINE 3238

; 3239	
; 3240		/* The filesystem object is not valid. */
; 3241		/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */
; 3242	
; 3243		fs->fs_type = 0;					/* Clear the filesystem object */
.LINE 3243

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),%0
; 3244		fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
.LINE 3244

	LD	A,(IX+%FFFFFFDA)
	LD	(IY+%1),A
; 3245		stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
.LINE 3245

	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_initialize
	POP	BC
	LD	(IX+%FFFFFFF8),A
; 3246		if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
.LINE 3246

	AND	A,%1
	JR	Z,L_727
; 3247			return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
.LINE 3247

	LD	HL,3
	JR	L_806
; 3248		}
L_727:
.LINE 3248

; 3249		if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
.LINE 3249

	LD	A,(IX+%C)
	OR	A,A
	JR	Z,L_728
	LD	A,(IX+%FFFFFFF8)
	AND	A,%4
	JR	Z,L_728
; 3250			return FR_WRITE_PROTECTED;
.LINE 3250

	LD	HL,10
	JR	L_806
; 3251		}
L_728:
.LINE 3251

; 3252	#if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
; 3253		if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
; 3254		if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
; 3255	#endif
; 3256	
; 3257		/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
; 3258		bsect = 0;
.LINE 3258

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF4),BC
	LD	(IX+%FFFFFFF7),A
; 3259		fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
.LINE 3259

	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_check_fs
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
; 3260		if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
.LINE 3260

	CP	A,%2
	JR	Z,L_750
	LD	A,(IX+%FFFFFFFC)
	CP	A,%2
	JR	C,L_752
	JR	L_752
L_750:
; 3261			for (i = 0; i < 4; i++) {		/* Get partition offset */
.LINE 3261

	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
	JR	L_738
L_736:
; 3262				pt = fs->win + (MBR_Table + i * SZ_PTE);
.LINE 3262

	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	LD	BC,446
	ADD	HL,BC
	LD	(IX+%FFFFFFD3),HL
; 3263				br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
.LINE 3263

	LD	IY,(IX+%FFFFFFD3)
	LD	A,(IY+%4)
	OR	A,A
	JR	Z,L_734
	LD	IY,(IX+%FFFFFFD3)
	LEA	BC,IY+%8
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	(IX+%FFFFFFBF),HL
	LD	(IX+%FFFFFFC2),E
	JR	L_735
L_734:
	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFBF),BC
	LD	(IX+%FFFFFFC2),A
L_735:
	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+%FFFFFFA7
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFBF)
	LD	A,(IX+%FFFFFFC2)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	LD	BC,(IX+%FFFFFFF9)
	INC	BC
	LD	(IX+%FFFFFFF9),BC
; 3264			}
L_738:
.LINE 3264

	LD	BC,4
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_736
; 3265			i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
.LINE 3265

	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
; 3266			if (i != 0) i--;
.LINE 3266

; 3267			do {							/* Find an FAT volume */
L_747:
.LINE 3267

; 3268				bsect = br[i];
.LINE 3268

	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+%FFFFFFA7
	ADD	HL,BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF4),BC
	LD	(IX+%FFFFFFF7),A
; 3269				fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
.LINE 3269

	LD	HL,BC
	LD	E,(IX+%FFFFFFF7)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_744
	LD	C,(IX+%FFFFFFF7)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_check_fs
	POP	BC
	POP	BC
	POP	BC
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFC3),HL
	JR	L_745
L_744:
	LD	BC,3
	LD	(IX+%FFFFFFC3),BC
L_745:
	LD	A,(IX+%FFFFFFC3)
	LD	(IX+%FFFFFFFC),A
; 3270			} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
.LINE 3270

	CP	A,%2
	JR	C,L_752
	LD	BC,(IX+%FFFFFFF9)
	INC	BC
	LD	(IX+%FFFFFFF9),BC
	LD	BC,4
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_747
; 3271		}
L_752:
.LINE 3271

; 3272		if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
.LINE 3272

	LD	A,(IX+%FFFFFFFC)
	CP	A,%4
	JR	NZ,L_754
	LD	HL,1
	JR	L_806
L_754:
; 3273		if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
.LINE 3273

	LD	A,(IX+%FFFFFFFC)
	CP	A,%2
	JR	C,L_804
	LD	HL,13
	JR	L_806
L_804:
; 3274	
; 3275		/* An FAT volume is found (bsect). Following code initializes the filesystem object */
; 3276	
; 3277	#if FF_FS_EXFAT
; 3278		if (fmt == 1) {
; 3279			QWORD maxlba;
; 3280	
; 3281			for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
; 3282			if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
; 3283	
; 3284			if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
; 3285	
; 3286			if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
; 3287				return FR_NO_FILESYSTEM;
; 3288			}
; 3289	
; 3290			maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
; 3291			if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
; 3292	
; 3293			fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
; 3294	
; 3295			fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
; 3296			if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
; 3297	
; 3298			fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
; 3299			if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
; 3300	
; 3301			nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
; 3302			if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
; 3303			fs->n_fatent = nclst + 2;
; 3304	
; 3305			/* Boundaries and Limits */
; 3306			fs->volbase = bsect;
; 3307			fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
; 3308			fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
; 3309			if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
; 3310			fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
; 3311	
; 3312			/* Check if bitmap location is in assumption (at the first cluster) */
; 3313			if (move_window(fs, clst2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
; 3314			for (i = 0; i < SS(fs); i += SZDIRE) {
; 3315				if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
; 3316			}
; 3317			if (i == SS(fs)) return FR_NO_FILESYSTEM;
; 3318	#if !FF_FS_READONLY
; 3319			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
; 3320	#endif
; 3321			fmt = FS_EXFAT;			/* FAT sub-type */
; 3322		} else
; 3323	#endif	/* FF_FS_EXFAT */
; 3324		{
; 3325			if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
.LINE 3325

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFEA),BC
	LD	IY,(IX+%FFFFFFEA)
	LEA	BC,IY+%B
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,512
	OR	A,A
	SBC	HL,BC
	JR	Z,L_756
	LD	HL,13
	JR	L_806
L_756:
; 3326	
; 3327			fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
.LINE 3327

	LD	IY,(IX+%FFFFFFEA)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFF0),HL
	LD	(IX+%FFFFFFF3),A
; 3328			if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
.LINE 3328

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_758
	LD	IY,(IX+%FFFFFFEA)
	LEA	BC,IY+%24
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	(IX+%FFFFFFF0),HL
	LD	(IX+%FFFFFFF3),E
L_758:
; 3329			fs->fsize = fasize;
.LINE 3329

	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%1E),BC
	LD	(IY+%21),A
; 3330	
; 3331			fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
.LINE 3331

	LD	A,(IY+%46)
	LD	(IY+%2),A
; 3332			if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
.LINE 3332

	LD	A,(IY+%2)
	LD	(IX+%FFFFFFEF),A
	LD	(IX+%FFFFFFE9),A
	LD	A,(IX+%FFFFFFEF)
	CP	A,%1
	JR	Z,L_761
	LD	A,(IX+%FFFFFFEF)
	LD	(IX+%FFFFFFE9),A
	LD	A,(IX+%FFFFFFEF)
	CP	A,%2
	JR	Z,L_761
	LD	HL,13
	JR	L_806
L_761:
; 3333			fasize *= fs->n_fats;							/* Number of sectors for FAT area */
.LINE 3333

	UEXT	HL
	LD	L,(IX+%FFFFFFE9)
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	CALL	__lmulu
	LD	(IX+%FFFFFFF0),HL
	LD	(IX+%FFFFFFF3),E
; 3334	
; 3335			fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
.LINE 3335

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	LD	C,(HL)
	LD	(IY+%9),C
	LD	(IY+%A),%0
; 3336			if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
.LINE 3336

	LD	BC,(IY+%9)
	LD	(IX+%FFFFFFED),C
	LD	(IX+%FFFFFFEE),B
	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFED)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_763
	LD	BC,(IX+%FFFFFFED)
	CALL	__stoiu
	DEC	HL
	LD	BC,(IX+%FFFFFFED)
	CALL	__sand
	LD.LIS	BC,0
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_764
L_763:
	LD	HL,13
	JR	L_806
L_764:
; 3337	
; 3338			fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
.LINE 3338

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%47
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
; 3339			if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
.LINE 3339

	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	A,L
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_766
	LD	HL,13
	JR	L_806
L_766:
; 3340	
; 3341			tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
.LINE 3341

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFE0),BC
	LD	(IX+%FFFFFFD0),BC
	LD	IY,(IX+%FFFFFFE0)
	LEA	BC,IY+%13
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	XOR	A,A
	LD	(IX+%FFFFFFD6),HL
	LD	(IX+%FFFFFFD9),A
; 3342			if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
.LINE 3342

	LD	HL,(IX+%FFFFFFD6)
	LD	E,(IX+%FFFFFFD9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_768
	LD	BC,(IX+%FFFFFFE0)
	LD	(IX+%FFFFFFD0),BC
	LD	IY,(IX+%FFFFFFE0)
	LEA	BC,IY+%20
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	(IX+%FFFFFFD6),HL
	LD	(IX+%FFFFFFD9),E
L_768:
; 3343	
; 3344			nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
.LINE 3344

	LD	IY,(IX+%FFFFFFD0)
	LEA	BC,IY+%E
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	(IX+%FFFFFFE3),L
	LD	(IX+%FFFFFFE4),H
; 3345			if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
.LINE 3345

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFE3)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_770
	LD	HL,13
	JR	L_806
L_770:
; 3346	
; 3347			/* Determine the FAT sub type */
; 3348			sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
.LINE 3348

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%7)
	CALL	__stoiu
	LD	A,%4
	CALL	__ishru_b
	XOR	A,A
	LD	(IX+%FFFFFF9A),A
	LD	(IX+%FFFFFF97),HL
	LD	BC,(IX+%FFFFFFE3)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFF9A)
	LD	HL,(IX+%FFFFFF97)
	CALL	__ladd
	LD	(IX+%FFFFFFCC),HL
	LD	(IX+%FFFFFFCF),E
; 3349			if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
.LINE 3349

	LD	HL,(IX+%FFFFFFD6)
	LD	E,(IX+%FFFFFFD9)
	LD	BC,(IX+%FFFFFFCC)
	LD	A,(IX+%FFFFFFCF)
	CALL	__lcmpu
	JR	NC,L_772
	LD	HL,13
	JR	L_806
L_772:
; 3350			nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
.LINE 3350

	LD	HL,(IX+%FFFFFFD6)
	LD	E,(IX+%FFFFFFD9)
	LD	BC,(IX+%FFFFFFCC)
	LD	A,(IX+%FFFFFFCF)
	CALL	__lsub
	LD	(IX+%FFFFFF9B),HL
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFF9B)
	CALL	__ldivu
	LD	(IX+%FFFFFFE5),HL
	LD	(IX+%FFFFFFE8),E
; 3351			if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
.LINE 3351

	LD	HL,(IX+%FFFFFFE5)
	LD	E,(IX+%FFFFFFE8)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_774
	LD	HL,13
	JR	L_806
L_774:
; 3352			fmt = 0;
.LINE 3352

	LD	(IX+%FFFFFFFC),%0
; 3353			if (nclst <= MAX_FAT32) fmt = FS_FAT32;
.LINE 3353

	LD	HL,16777205
	LD	E,%F
	LD	BC,(IX+%FFFFFFE5)
	LD	A,(IX+%FFFFFFE8)
	CALL	__lcmpu
	JR	C,L_777
	LD	(IX+%FFFFFFFC),%3
L_777:
; 3354			if (nclst <= MAX_FAT16) fmt = FS_FAT16;
.LINE 3354

	LD	HL,65525
	LD	E,%0
	LD	BC,(IX+%FFFFFFE5)
	LD	A,(IX+%FFFFFFE8)
	CALL	__lcmpu
	JR	C,L_779
	LD	(IX+%FFFFFFFC),%2
L_779:
; 3355			if (nclst <= MAX_FAT12) fmt = FS_FAT12;
.LINE 3355

	LD	HL,4085
	LD	BC,(IX+%FFFFFFE5)
	LD	A,(IX+%FFFFFFE8)
	CALL	__lcmpu
	JR	C,L_781
	LD	(IX+%FFFFFFFC),%1
L_781:
; 3356			if (fmt == 0) return FR_NO_FILESYSTEM;
.LINE 3356

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	NZ,L_782
	LD	HL,13
	JR	L_806
L_782:
; 3357	
; 3358			/* Boundaries and Limits */
; 3359			fs->n_fatent = nclst + 2;						/* Number of FAT entries */
.LINE 3359

	LD	HL,(IX+%FFFFFFE5)
	LD	E,(IX+%FFFFFFE8)
	LD	A,%2
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%1A),HL
	LD	(IY+%1D),E
; 3360			fs->volbase = bsect;							/* Volume start sector */
.LINE 3360

	LD	BC,(IX+%FFFFFFF4)
	LD	A,(IX+%FFFFFFF7)
	LD	(IY+%22),BC
	LD	(IY+%25),A
; 3361			fs->fatbase = bsect + nrsv; 					/* FAT start sector */
.LINE 3361

	LD	BC,(IX+%FFFFFFE3)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFF4)
	LD	E,(IX+%FFFFFFF7)
	CALL	__ladd
	LD	(IY+%26),HL
	LD	(IY+%29),E
; 3362			fs->database = bsect + sysect;					/* Data start sector */
.LINE 3362

	LD	HL,(IX+%FFFFFFCC)
	LD	E,(IX+%FFFFFFCF)
	LD	BC,(IX+%FFFFFFF4)
	LD	A,(IX+%FFFFFFF7)
	CALL	__ladd
	LD	(IY+%2E),HL
	LD	(IY+%31),E
; 3363			if (fmt == FS_FAT32) {
.LINE 3363

	LD	A,(IX+%FFFFFFFC)
	CP	A,%3
	JR	NZ,L_794
; 3364				if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
.LINE 3364

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFC9),BC
	LD	IY,(IX+%FFFFFFC9)
	LEA	BC,IY+%2A
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD.LIS	BC,0
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_785
	LD	HL,13
	JR	L_806
L_785:
; 3365				if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
.LINE 3365

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%7)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_786
	LD	HL,13
	JR	L_806
L_786:
; 3366				fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
.LINE 3366

	LD	IY,(IX+%FFFFFFC9)
	LEA	BC,IY+%2C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2A),HL
	LD	(IY+%2D),E
; 3367				szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
.LINE 3367

	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,4
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFBB),HL
	LD	(IX+%FFFFFFBE),E
; 3368			} else {
.LINE 3368

	JR	L_796
L_794:
; 3369				if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
.LINE 3369

	LD.LIS	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%7)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_788
	LD	HL,13
	JR	L_806
L_788:
; 3370				fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
.LINE 3370

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%26)
	LD	E,(IY+%29)
	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	CALL	__ladd
	LD	(IY+%2A),HL
	LD	(IY+%2D),E
; 3371				szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
.LINE 3371

	LD	A,(IX+%FFFFFFFC)
	CP	A,%2
	JR	NZ,L_791
; 3372					fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
.LINE 3372

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,2
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFB7),HL
	LD	(IX+%FFFFFFBA),E
	JR	L_792
L_791:
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%1A)
	LD	(IX+%FFFFFFA1),DE	; spill
	LD	E,(IY+%1D)
	LD	(IX+%FFFFFFA4),DE	; spill
	LD	HL,(IX+%FFFFFFA1)
	LD	DE,(IX+%FFFFFFA4)	; unspill
	LD	BC,3
	XOR	A,A
	CALL	__lmulu
	LD	A,E
	LD	BC,HL
	LD	L,%1
	CALL	__lshru
	LD	(IX+%FFFFFF9E),BC
	LD	E,A
	LD	(IX+%FFFFFFA4),DE	; spill
	LD	DE,(IX+%FFFFFFA1)	; unspill
	LD	BC,DE
	LD	DE,(IX+%FFFFFFA4)	; unspill
	LD	A,C
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFF9E)
	CALL	__ladd
	LD	(IX+%FFFFFFB7),HL
	LD	(IX+%FFFFFFBA),E
L_792:
	LD	BC,(IX+%FFFFFFB7)
	LD	A,(IX+%FFFFFFBA)
	LD	(IX+%FFFFFFBB),BC
	LD	(IX+%FFFFFFBE),A
; 3373			}
L_796:
.LINE 3373

; 3374			if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
.LINE 3374

	LD	HL,(IX+%FFFFFFBB)
	LD	E,(IX+%FFFFFFBE)
	LD	BC,511
	XOR	A,A
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	L,%9
	CALL	__lshru
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1E)
	LD	E,(IY+%21)
	CALL	__lcmpu
	JR	NC,L_797
	LD	HL,13
	JR	L_806
L_797:
; 3375	
; 3376	#if !FF_FS_READONLY
; 3377			/* Get FSInfo if available */
; 3378			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
.LINE 3378

	LD	BC,16777215
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%12),BC
	LD	(IY+%15),%FF
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	LD	(IY+%E),BC
	LD	(IY+%11),A
; 3379			fs->fsi_flag = 0x80;
.LINE 3379

	LD	(IY+%4),%80
; 3380	#if (FF_FS_NOFSINFO & 3) != 3
; 3381			if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
; 3382				&& ld_word(fs->win + BPB_FSInfo32) == 1
.LINE 3382

	LD	A,(IX+%FFFFFFFC)
	CP	A,%3
	JR	NZ,L_805
; 3383				&& move_window(fs, bsect + 1) == FR_OK)
.LINE 3383

	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%66
	PUSH	BC
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,1
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_805
	LD	HL,(IX+%FFFFFFF4)
	LD	E,(IX+%FFFFFFF7)
	LD	A,%1
	CALL	__ladd_b
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_805
; 3384			{
; 3385				fs->fsi_flag = 0;
.LINE 3385

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%4),%0
; 3386				if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
; 3387					&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
.LINE 3387

	LEA	BC,IY+%36
	LD	(IX+%FFFFFFC6),BC
	LD	BC,510
	LD	HL,(IX+%FFFFFFC6)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	BC,43605
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_805
; 3388					&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
.LINE 3388

	LD	BC,(IX+%FFFFFFC6)
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	BC,6378066
	LD	A,%41
	CALL	__lcmpu
	JR	NZ,L_805
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFDD),BC
	LD	BC,484
	LD	HL,(IX+%FFFFFFDD)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	BC,4289138
	LD	A,%61
	CALL	__lcmpu
	JR	NZ,L_805
; 3389				{
; 3390	#if (FF_FS_NOFSINFO & 1) == 0
; 3391					fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
.LINE 3391

	LD	BC,488
	LD	HL,(IX+%FFFFFFDD)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%12),HL
	LD	(IY+%15),E
; 3392	#endif
; 3393	#if (FF_FS_NOFSINFO & 2) == 0
; 3394					fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
.LINE 3394

	LD	BC,492
	LD	HL,(IX+%FFFFFFDD)
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%E),HL
	LD	(IY+%11),E
; 3395	#endif
; 3396				}
; 3397			}
; 3398	#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
; 3399	#endif	/* !FF_FS_READONLY */
; 3400		}
L_805:
.LINE 3400

; 3401	
; 3402		fs->fs_type = fmt;		/* FAT sub-type */
.LINE 3402

	LD	A,(IX+%FFFFFFFC)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),A
; 3403		fs->id = ++Fsid;		/* Volume mount ID */
.LINE 3403

	LD	BC,(_Fsid)
	INC	BC
	LD	HL,_Fsid
	LD	(HL),C
	INC	HL
	LD	(HL),B
	LD	BC,(_Fsid)
	LD	(IY+%5),C
	LD	(IY+%6),B
; 3404	#if FF_USE_LFN == 1
; 3405		fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
.LINE 3405

	LD	BC,_LfnBuf
	LD	(IY+%B),BC
; 3406	#if FF_FS_EXFAT
; 3407		fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
; 3408	#endif
; 3409	#endif
; 3410	#if FF_FS_RPATH != 0
; 3411		fs->cdir = 0;			/* Initialize current directory */
.LINE 3411

	LD	BC,0
	LD	(IY+%16),BC
	LD	(IY+%19),%0
; 3412	#endif
; 3413	#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
; 3414		clear_lock(fs);
; 3415	#endif
; 3416		return FR_OK;
.LINE 3416

	OR	A,A
	SBC	HL,HL
; 3417	}
L_806:
.LINE 3417

	LD	SP,IX
	POP	IX
	RET	


;**************************** _find_volume ***************************
;Name                         Addr/Register   Size   Type
;_LfnBuf                             STATIC    512   variable
;_Fsid                               STATIC      2   variable
;_disk_initialize                    IMPORT  -----   function
;_disk_status                        IMPORT  -----   function
;_FatFs                              STATIC      3   variable
;br                                   IX-89     16   variable
;temp789                              IX-73      4   variable
;szbfat                               IX-69      4   variable
;temp732                              IX-65      4   variable
;temp742                              IX-61      3   variable
;G_51                                 IX-58      3   variable
;G_50                                 IX-55      3   variable
;sysect                               IX-52      4   variable
;G_49                                 IX-48      3   variable
;pt                                   IX-45      3   variable
;tsect                                IX-42      4   variable
;vol                                  IX-38      3   variable
;G_52                                 IX-35      3   variable
;G_48                                 IX-32      3   variable
;nrsv                                 IX-29      2   variable
;nclst                                IX-27      4   variable
;G_46                                 IX-23      1   variable
;G_43                                 IX-22      3   variable
;G_47                                 IX-19      2   variable
;G_45                                 IX-17      1   variable
;fasize                               IX-16      4   variable
;bsect                                IX-12      4   variable
;stat                                  IX-8      1   variable
;i                                     IX-7      3   variable
;fmt                                   IX-4      1   variable
;fs                                    IX-3      3   variable
;mode                                 IX+12      1   parameter
;rfs                                   IX+9      3   parameter
;path                                  IX+6      3   parameter


; Stack Frame Size: 120 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "find_volume",3417,"_find_volume"
; 3418	
; 3419	
; 3420	
; 3421	
; 3422	/*-----------------------------------------------------------------------*/
; 3423	/* Check if the file/directory object is valid or not                    */
; 3424	/*-----------------------------------------------------------------------*/
; 3425	
; 3426	static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
; 3427		FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
; 3428		FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
; 3429	)
; 3430	{
_validate:
.DEFINE "_validate"

.VALUE _validate

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "validate",3430,"_validate"

.LINE 3430

.DEFINE "obj"

.CLASS 65

.VALUE 6

.TAG "NONAME1"

.TYPE 40

.ENDEF

.DEFINE "rfs"

.CLASS 65

.VALUE 9

.TAG "NONAME0"

.TYPE 296

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 3431		FRESULT res = FR_INVALID_OBJECT;
.LINE 3431

	LD	BC,9
	LD	(IX+%FFFFFFFA),BC
; 3432	
; 3433	
; 3434		if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
.LINE 3434

	LD	BC,0
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_816
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFFD),BC
	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_816
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	OR	A,A
	JR	Z,L_816
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%5)
	LD	IY,(IX+%6)
	LD	HL,(IY+%3)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_816
; 3435	#if FF_FS_REENTRANT
; 3436			if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
; 3437				if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
; 3438					res = FR_OK;
; 3439				} else {
; 3440					unlock_fs(obj->fs, FR_OK);
; 3441				}
; 3442			} else {
; 3443				res = FR_TIMEOUT;
; 3444			}
; 3445	#else
; 3446			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
.LINE 3446

	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_status
	POP	BC
	AND	A,%1
	JR	NZ,L_816
; 3447				res = FR_OK;
.LINE 3447

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 3448			}
; 3449	#endif
; 3450		}
L_816:
.LINE 3450

; 3451		*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
.LINE 3451

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_814
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF7),BC
	JR	L_815
L_814:
	LD	(IX+%FFFFFFF7),BC
L_815:
	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFF7)
	LD	(HL),BC
; 3452		return res;
.LINE 3452

	LD	HL,(IX+%FFFFFFFA)
; 3453	}
.LINE 3453

	LD	SP,IX
	POP	IX
	RET	


;**************************** _validate ***************************
;Name                         Addr/Register   Size   Type
;_disk_status                        IMPORT  -----   function
;temp812                               IX-9      3   variable
;res                                   IX-6      3   variable
;G_53                                  IX-3      3   variable
;rfs                                   IX+9      3   parameter
;obj                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "validate",3453,"_validate"
; 3454	
; 3455	
; 3456	
; 3457	
; 3458	/*---------------------------------------------------------------------------
; 3459	
; 3460	   Public Functions (FatFs API)
; 3461	
; 3462	----------------------------------------------------------------------------*/
; 3463	
; 3464	
; 3465	
; 3466	/*-----------------------------------------------------------------------*/
; 3467	/* Mount/Unmount a Logical Drive                                         */
; 3468	/*-----------------------------------------------------------------------*/
; 3469	
; 3470	FRESULT f_mount (
; 3471		FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
; 3472		const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
; 3473		BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
; 3474	)
; 3475	{
_f_mount:
.DEFINE "_f_mount"

.VALUE _f_mount

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_mount",3475,"_f_mount"

.LINE 3475

.DEFINE "fs"

.CLASS 65

.VALUE 6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "opt"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "cfs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

.DEFINE "rp"

.CLASS 65

.VALUE -15

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
; 3476		FATFS *cfs;
; 3477		int vol;
; 3478		FRESULT res;
; 3479		const TCHAR *rp = path;
.LINE 3479

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFF1),BC
; 3480	
; 3481	
; 3482		/* Get logical drive number */
; 3483		vol = get_ldnumber(&rp);
.LINE 3483

	PEA	IX+%FFFFFFF1
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3484		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 3484

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	P,L_819
	LD	HL,11
	JR	L_826
L_819:
; 3485		cfs = FatFs[vol];					/* Pointer to fs object */
.LINE 3485

	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_FatFs
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
	LD	BC,(HL)
	LD	(IX+%FFFFFFFD),BC
; 3486	
; 3487		if (cfs) {
.LINE 3487

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_822
; 3488	#if FF_FS_LOCK != 0
; 3489			clear_lock(cfs);
; 3490	#endif
; 3491	#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
; 3492			if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
; 3493	#endif
; 3494			cfs->fs_type = 0;				/* Clear old fs object */
.LINE 3494

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%0),%0
; 3495		}
L_822:
.LINE 3495

; 3496	
; 3497		if (fs) {
.LINE 3497

	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_823
; 3498			fs->fs_type = 0;				/* Clear new fs object */
.LINE 3498

	LD	IY,(IX+%6)
	LD	(IY+%0),%0
; 3499	#if FF_FS_REENTRANT						/* Create sync object for the new volume */
; 3500			if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
; 3501	#endif
; 3502		}
L_823:
.LINE 3502

; 3503		FatFs[vol] = fs;					/* Register new fs object */
.LINE 3503

	LD	HL,(IX+%FFFFFFF7)
	LD	BC,(IX+%6)
	LD	(HL),BC
; 3504	
; 3505		if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
.LINE 3505

	LD	A,(IX+%C)
	OR	A,A
	JR	NZ,L_825
	OR	A,A
	SBC	HL,HL
	JR	L_826
L_825:
; 3506	
; 3507		res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
.LINE 3507

	LD	BC,0
	PUSH	BC
	PEA	IX+%6
	PEA	IX+%9
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF4),HL
; 3508		LEAVE_FF(fs, res);
.LINE 3508

; 3509	}
L_826:
.LINE 3509

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_mount ***************************
;Name                         Addr/Register   Size   Type
;_FatFs                              STATIC      3   variable
;rp                                   IX-15      3   variable
;res                                  IX-12      3   variable
;G_56                                  IX-9      3   variable
;vol                                   IX-6      3   variable
;cfs                                   IX-3      3   variable
;opt                                  IX+12      1   parameter
;path                                  IX+9      3   parameter
;fs                                    IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_mount",3509,"_f_mount"
; 3510	
; 3511	
; 3512	
; 3513	
; 3514	/*-----------------------------------------------------------------------*/
; 3515	/* Open or Create a File                                                 */
; 3516	/*-----------------------------------------------------------------------*/
; 3517	
; 3518	FRESULT f_open (
; 3519		FIL* fp,			/* Pointer to the blank file object */
; 3520		const TCHAR* path,	/* Pointer to the file name */
; 3521		BYTE mode			/* Access mode and file open mode flags */
; 3522	)
; 3523	{
_f_open:
.DEFINE "_f_open"

.VALUE _f_open

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_open",3523,"_f_open"

.LINE 3523

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "mode"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE -14

.TYPE 15

.ENDEF

.DEFINE "cl"

.CLASS 65

.VALUE -24

.TYPE 15

.ENDEF

.DEFINE "sc"

.CLASS 65

.VALUE -28

.TYPE 15

.ENDEF

.DEFINE "bcs"

.CLASS 65

.VALUE -32

.TYPE 15

.ENDEF

.DEFINE "dw"

.CLASS 65

.VALUE -36

.TYPE 15

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -82

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFA8
	LD	SP,HL
; 3524		FRESULT res;
; 3525		DIR dj;
; 3526		FATFS *fs;
; 3527	#if !FF_FS_READONLY
; 3528		DWORD dw, cl, bcs, clst, sc;
; 3529		FSIZE_t ofs;
; 3530	#endif
; 3531		DEF_NAMBUF
; 3532	
; 3533	
; 3534		if (!fp) return FR_INVALID_OBJECT;
.LINE 3534

	LD	BC,0
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_828
	LD	HL,9
	JR	L_876
L_828:
; 3535	
; 3536		/* Get logical drive number */
; 3537		mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
.LINE 3537

	LD	A,(IX+%C)
	AND	A,%3F
	LD	(IX+%C),A
; 3538		res = find_volume(&path, &fs, mode);
.LINE 3538

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%9
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3539		if (res == FR_OK) {
.LINE 3539

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_874
; 3540			dj.obj.fs = fs;
.LINE 3540

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFAE),BC
; 3541			INIT_NAMBUF(fs);
; 3542			res = follow_path(&dj, path);	/* Follow the file path */
.LINE 3542

	LD	BC,(IX+%9)
	PUSH	BC
	PEA	IX+%FFFFFFAE
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3543	#if !FF_FS_READONLY	/* Read/Write configuration */
; 3544			if (res == FR_OK) {
.LINE 3544

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_850
; 3545				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
.LINE 3545

	LEA	IY,IX+%FFFFFFCC
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_850
; 3546					res = FR_INVALID_NAME;
.LINE 3546

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 3547				}
; 3548	#if FF_FS_LOCK != 0
; 3549				else {
; 3550					res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
; 3551				}
; 3552	#endif
; 3553			}
L_850:
.LINE 3553

; 3554			/* Create or Open a file */
; 3555			if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
.LINE 3555

	LD	A,(IX+%C)
	AND	A,%1C
	JR	Z,L_849
; 3556				if (res != FR_OK) {					/* No file, create new */
.LINE 3556

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_837
; 3557					if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
.LINE 3557

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_832
; 3558	#if FF_FS_LOCK != 0
; 3559						res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
; 3560	#else
; 3561						res = dir_register(&dj);
.LINE 3561

	PEA	IX+%FFFFFFAE
	CALL	_dir_register
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3562	#endif
; 3563					}
L_832:
.LINE 3563

; 3564					mode |= FA_CREATE_ALWAYS;		/* File is created */
.LINE 3564

	LD	A,(IX+%C)
	SET	%3,A
	LD	(IX+%C),A
; 3565				}
; 3566				else {								/* Any object with the same name is already existing */
.LINE 3566

	JR	L_842
L_837:
; 3567					if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
.LINE 3567

	LD	A,(IX+%FFFFFFB3)
	AND	A,%11
	JR	Z,L_835
; 3568						res = FR_DENIED;
.LINE 3568

	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
; 3569					} else {
.LINE 3569

	JR	L_842
L_835:
; 3570						if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
.LINE 3570

	LD	A,(IX+%C)
	AND	A,%4
	JR	Z,L_842
	LD	BC,8
	LD	(IX+%FFFFFFFD),BC
; 3571					}
; 3572				}
L_842:
.LINE 3572

; 3573				if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
.LINE 3573

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_854
	LD	A,(IX+%C)
	AND	A,%8
	JR	Z,L_854
; 3574	#if FF_FS_EXFAT
; 3575					if (fs->fs_type == FS_EXFAT) {
; 3576						/* Get current allocation info */
; 3577						fp->obj.fs = fs;
; 3578						init_alloc_info(fs, &fp->obj);
; 3579						/* Set directory entry block initial state */
; 3580						mem_set(fs->dirbuf + 2, 0, 30);		/* Clear 85 entry except for NumSec */
; 3581						mem_set(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
; 3582						fs->dirbuf[XDIR_Attr] = AM_ARC;
; 3583						st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
; 3584						fs->dirbuf[XDIR_GenFlags] = 1;
; 3585						res = store_xdir(&dj);
; 3586						if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
; 3587							res = remove_chain(&fp->obj, fp->obj.sclust, 0);
; 3588							fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
; 3589						}
; 3590					} else
; 3591	#endif
; 3592					{
; 3593						/* Set directory entry initial state */
; 3594						cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
.LINE 3594

	LD	BC,(IX+%FFFFFFC9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE8),HL
	LD	(IX+%FFFFFFEB),E
; 3595						st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
.LINE 3595

	CALL	_get_fattime
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	IY,(IX+%FFFFFFC9)
	LEA	BC,IY+%E
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 3596						dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
.LINE 3596

	LD	IY,(IX+%FFFFFFC9)
	LEA	HL,IY+%B
	LD	(HL),%20
; 3597						st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
.LINE 3597

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%FFFFFFC9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 3598						st_dword(dj.dir + DIR_FileSize, 0);
.LINE 3598

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	IY,(IX+%FFFFFFC9)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 3599						fs->wflag = 1;
.LINE 3599

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 3600						if (cl != 0) {						/* Remove the cluster chain if exist */
.LINE 3600

	LD	HL,(IX+%FFFFFFE8)
	LD	E,(IX+%FFFFFFEB)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_854
; 3601							dw = fs->winsect;
.LINE 3601

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%32)
	LD	A,(IY+%35)
	LD	(IX+%FFFFFFDC),BC
	LD	(IX+%FFFFFFDF),A
; 3602							res = remove_chain(&dj.obj, cl, 0);
.LINE 3602

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFEB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	PEA	IX+%FFFFFFAE
	CALL	_remove_chain
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3603							if (res == FR_OK) {
.LINE 3603

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_854
; 3604								res = move_window(fs, dw);
.LINE 3604

	LD	C,(IX+%FFFFFFDF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFDC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 3605								fs->last_clst = cl - 1;		/* Reuse the cluster hole */
.LINE 3605

	LD	HL,(IX+%FFFFFFE8)
	LD	E,(IX+%FFFFFFEB)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%E),HL
	LD	(IY+%11),E
; 3606							}
; 3607						}
; 3608					}
; 3609				}
; 3610			}
; 3611			else {	/* Open an existing file */
.LINE 3611

	JR	L_854
L_849:
; 3612				if (res == FR_OK) {					/* Is the object exsiting? */
.LINE 3612

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_854
; 3613					if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
.LINE 3613

	LEA	BC,IX+%FFFFFFAE
	LD	(IX+%FFFFFFEF),BC
	LD	IY,(IX+%FFFFFFEF)
	LD	A,(IY+%5)
	AND	A,%10
	JR	Z,L_846
; 3614						res = FR_NO_FILE;
.LINE 3614

	LD	BC,4
	LD	(IX+%FFFFFFFD),BC
; 3615					} else {
.LINE 3615

	JR	L_854
L_846:
; 3616						if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
.LINE 3616

	LD	A,(IX+%C)
	AND	A,%2
	JR	Z,L_854
	LD	IY,(IX+%FFFFFFEF)
	LD	A,(IY+%5)
	AND	A,%1
	JR	Z,L_854
; 3617							res = FR_DENIED;
.LINE 3617

	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
; 3618						}
; 3619					}
; 3620				}
; 3621			}
L_854:
.LINE 3621

; 3622			if (res == FR_OK) {
.LINE 3622

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_870
; 3623				if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
.LINE 3623

	LD	A,(IX+%C)
	AND	A,%8
	JR	Z,L_852
	LD	A,(IX+%C)
	SET	%6,A
	LD	(IX+%C),A
L_852:
; 3624				fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
.LINE 3624

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%32)
	LD	A,(IY+%35)
	LD	IY,(IX+%6)
	LD	(IY+%1D),BC
	LD	(IY+%20),A
; 3625				fp->dir_ptr = dj.dir;
.LINE 3625

	LD	BC,(IX+%FFFFFFC9)
	LD	(IY+%21),BC
; 3626	#if FF_FS_LOCK != 0
; 3627				fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
; 3628				if (fp->obj.lockid == 0) res = FR_INT_ERR;
; 3629	#endif
; 3630			}
L_870:
.LINE 3630

; 3631	#else		/* R/O configuration */
; 3632			if (res == FR_OK) {
; 3633				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it origin directory itself? */
; 3634					res = FR_INVALID_NAME;
; 3635				} else {
; 3636					if (dj.obj.attr & AM_DIR) {		/* Is it a directory? */
; 3637						res = FR_NO_FILE;
; 3638					}
; 3639				}
; 3640			}
; 3641	#endif
; 3642	
; 3643			if (res == FR_OK) {
.LINE 3643

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_871
; 3644	#if FF_FS_EXFAT
; 3645				if (fs->fs_type == FS_EXFAT) {
; 3646					fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
; 3647					fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
; 3648					fp->obj.c_ofs = dj.blk_ofs;
; 3649					init_alloc_info(fs, &fp->obj);
; 3650				} else
; 3651	#endif
; 3652				{
; 3653					fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
.LINE 3653

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFAB),BC
	LD	BC,(IX+%FFFFFFC9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%FFFFFFAB)
	LD	(IY+%7),HL
	LD	(IY+%A),E
; 3654					fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
.LINE 3654

	LD	IY,(IX+%FFFFFFC9)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_ld_dword
	POP	BC
	LD	IY,(IX+%FFFFFFAB)
	LD	(IY+%B),HL
	LD	(IY+%E),E
; 3655				}
; 3656	#if FF_USE_FASTSEEK
; 3657				fp->cltbl = 0;			/* Disable fast seek mode */
; 3658	#endif
; 3659				fp->obj.fs = fs;	 	/* Validate the file object */
.LINE 3659

	LD	BC,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 3660				fp->obj.id = fs->id;
.LINE 3660

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%5)
	LD	IY,(IX+%FFFFFFAB)
	LD	(IY+%3),C
	LD	(IY+%4),B
; 3661				fp->flag = mode;		/* Set file access mode */
.LINE 3661

	LD	A,(IX+%C)
	LD	IY,(IX+%6)
	LD	(IY+%F),A
; 3662				fp->err = 0;			/* Clear error flag */
.LINE 3662

	LD	(IY+%10),%0
; 3663				fp->sect = 0;			/* Invalidate current data sector */
.LINE 3663

	LD	BC,0
	LD	(IY+%19),BC
	LD	(IY+%1C),%0
; 3664				fp->fptr = 0;			/* Set file pointer top of the file */
.LINE 3664

	LD	(IY+%11),BC
	LD	(IY+%14),%0
; 3665	#if !FF_FS_READONLY
; 3666	#if !FF_FS_TINY
; 3667				mem_set(fp->buf, 0, FF_MAX_SS);	/* Clear sector buffer */
; 3668	#endif
; 3669				if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
.LINE 3669

	LD	A,(IX+%C)
	AND	A,%20
	JR	Z,L_871
	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFEC),BC
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	IY,(IX+%FFFFFFEC)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	CALL	__lcmpu
	JR	NC,L_871
; 3670					fp->fptr = fp->obj.objsize;			/* Offset to seek */
.LINE 3670

	LD	IY,(IX+%FFFFFFEC)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	IY,(IX+%6)
	LD	(IY+%11),BC
	LD	(IY+%14),A
; 3671					bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
.LINE 3671

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFE0),HL
	LD	(IX+%FFFFFFE3),E
; 3672					clst = fp->obj.sclust;				/* Follow the cluster chain */
.LINE 3672

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFA8),BC
	LD	IY,(IX+%FFFFFFA8)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 3673					for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
.LINE 3673

	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	(IX+%FFFFFFF2),BC
	LD	(IX+%FFFFFFF5),A
	JR	L_862
L_860:
; 3674						clst = get_fat(&fp->obj, clst);
.LINE 3674

	LD	C,(IX+%FFFFFFF9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),E
; 3675						if (clst <= 1) res = FR_INT_ERR;
.LINE 3675

	LD	HL,1
	LD	E,%0
	LD	A,(IX+%FFFFFFF9)
	CALL	__lcmpu
	JR	C,L_859
	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
L_859:
; 3676						if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
.LINE 3676

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_861
	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 3677					}
L_861:
.LINE 3677

	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	BC,(IX+%FFFFFFE0)
	LD	A,(IX+%FFFFFFE3)
	CALL	__lsub
	LD	(IX+%FFFFFFF2),HL
	LD	(IX+%FFFFFFF5),E
L_862:
	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_863
	LD	HL,(IX+%FFFFFFE0)
	LD	E,(IX+%FFFFFFE3)
	LD	BC,(IX+%FFFFFFF2)
	LD	A,(IX+%FFFFFFF5)
	CALL	__lcmpu
	JR	C,L_860
L_863:
; 3678					fp->clust = clst;
.LINE 3678

	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 3679					if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
.LINE 3679

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_871
	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_871
; 3680						if ((sc = clst2sect(fs, clst)) == 0) {
.LINE 3680

	LD	C,(IX+%FFFFFFF9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE4),HL
	LD	(IX+%FFFFFFE7),E
	LD	HL,(IX+%FFFFFFE4)
	LD	E,(IX+%FFFFFFE7)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_866
; 3681							res = FR_INT_ERR;
.LINE 3681

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 3682						} else {
.LINE 3682

	JR	L_871
L_866:
; 3683							fp->sect = sc + (DWORD)(ofs / SS(fs));
.LINE 3683

	LD	BC,(IX+%FFFFFFF2)
	LD	A,(IX+%FFFFFFF5)
	LD	L,%9
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFE4)
	LD	A,(IX+%FFFFFFE7)
	CALL	__ladd
	LD	IY,(IX+%6)
	LD	(IY+%19),HL
	LD	(IY+%1C),E
; 3684	#if !FF_FS_TINY
; 3685							if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
; 3686	#endif
; 3687						}
; 3688					}
; 3689				}
; 3690	#endif
; 3691			}
L_871:
.LINE 3691

; 3692	
; 3693			FREE_NAMBUF();
; 3694		}
L_874:
.LINE 3694

; 3695	
; 3696		if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
.LINE 3696

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_875
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
L_875:
; 3697	
; 3698		LEAVE_FF(fs, res);
.LINE 3698

	LD	HL,(IX+%FFFFFFFD)
; 3699	}
L_876:
.LINE 3699

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_open ***************************
;Name                         Addr/Register   Size   Type
;_get_fattime                        IMPORT  -----   function
;dj                                   IX-82     46   variable
;dw                                   IX-36      4   variable
;bcs                                  IX-32      4   variable
;sc                                   IX-28      4   variable
;cl                                   IX-24      4   variable
;G_58                                 IX-20      3   variable
;G_57                                 IX-17      3   variable
;ofs                                  IX-14      4   variable
;clst                                 IX-10      4   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;mode                                 IX+12      1   parameter
;path                                  IX+9      3   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 103 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_open",3699,"_f_open"
; 3700	
; 3701	
; 3702	
; 3703	
; 3704	/*-----------------------------------------------------------------------*/
; 3705	/* Read File                                                             */
; 3706	/*-----------------------------------------------------------------------*/
; 3707	
; 3708	FRESULT f_read (
; 3709		FIL* fp, 	/* Pointer to the file object */
; 3710		void* buff,	/* Pointer to data buffer */
; 3711		UINT btr,	/* Number of bytes to read */
; 3712		UINT* br	/* Pointer to number of bytes read */
; 3713	)
; 3714	{
_f_read:
.DEFINE "_f_read"

.VALUE _f_read

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_read",3714,"_f_read"

.LINE 3714

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "btr"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "br"

.CLASS 65

.VALUE 15

.TYPE 46

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "rcnt"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "cc"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "rbuff"

.CLASS 65

.VALUE -16

.TYPE 44

.ENDEF

.DEFINE "csect"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -22

.TYPE 4

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -26

.TYPE 15

.ENDEF

.DEFINE "remain"

.CLASS 65

.VALUE -34

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDA
	LD	SP,HL
; 3715		FRESULT res;
; 3716		FATFS *fs;
; 3717		DWORD clst, sect;
; 3718		FSIZE_t remain;
; 3719		UINT rcnt, cc, csect;
; 3720		BYTE *rbuff = (BYTE*)buff;
.LINE 3720

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFF0),BC
; 3721	
; 3722	
; 3723		*br = 0;	/* Clear read byte counter */
.LINE 3723

	LD	HL,(IX+%F)
	LD	BC,0
	LD	(HL),BC
; 3724		res = validate(&fp->obj, &fs);				/* Check validity of the file object */
.LINE 3724

	PEA	IX+%FFFFFFFD
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEA),HL
; 3725		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
.LINE 3725

	LD	BC,0
	LD	HL,(IX+%FFFFFFEA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_878
	LD	IY,(IX+%6)
	LD	A,(IY+%10)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFEA),HL
	LD	HL,(IX+%FFFFFFEA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_880
L_878:
	LD	HL,(IX+%FFFFFFEA)
	JR	L_914
L_880:
; 3726		if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
.LINE 3726

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%1
	JR	NZ,L_881
	LD	HL,7
	JR	L_914
L_881:
; 3727		remain = fp->obj.objsize - fp->fptr;
.LINE 3727

	LD	IY,(IX+%6)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	CALL	__lsub
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
; 3728		if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
.LINE 3728

	LD	BC,(IX+%C)
	XOR	A,A
	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	CALL	__lcmpu
	JR	NC,L_911
	LD	BC,(IX+%FFFFFFDE)
	LD	(IX+%C),BC
; 3729	
; 3730		for ( ;  btr;								/* Repeat until btr bytes read */
.LINE 3730

	JR	L_911
; 3731			btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
L_909:
.LINE 3731

; 3732			if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
.LINE 3732

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFE2),BC
	LD	(IX+%FFFFFFE5),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFE5)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_904
; 3733				csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
.LINE 3733

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	DEC	HL
	LD	BC,HL
	CALL	__itol
	LD	(IX+%FFFFFFDB),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFE2)
	LD	A,(IX+%FFFFFFE5)
	LD	L,%9
	CALL	__lshru
	LD	HL,(IX+%FFFFFFDB)
	CALL	__land
	LD	(IX+%FFFFFFED),HL
; 3734				if (csect == 0) {					/* On the cluster boundary? */
.LINE 3734

	LD	BC,0
	LD	HL,(IX+%FFFFFFED)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_891
; 3735					if (fp->fptr == 0) {			/* On the top of the file? */
.LINE 3735

	LD	HL,(IX+%FFFFFFE2)
	LD	E,(IX+%FFFFFFE5)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_884
; 3736						clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
.LINE 3736

	LD	IY,(IX+%6)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFE6),BC
	LD	(IX+%FFFFFFE9),A
; 3737					} else {						/* Middle or end of the file */
.LINE 3737

	JR	L_886
L_884:
; 3738	#if FF_USE_FASTSEEK
; 3739						if (fp->cltbl) {
; 3740							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
; 3741						} else
; 3742	#endif
; 3743						{
; 3744							clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
.LINE 3744

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE6),HL
	LD	(IX+%FFFFFFE9),E
; 3745						}
; 3746					}
L_886:
.LINE 3746

; 3747					if (clst < 2) ABORT(fs, FR_INT_ERR);
.LINE 3747

	LD	HL,(IX+%FFFFFFE6)
	LD	E,(IX+%FFFFFFE9)
	LD	BC,2
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_887
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_914
L_887:
; 3748					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
.LINE 3748

	LD	HL,(IX+%FFFFFFE6)
	LD	E,(IX+%FFFFFFE9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_889
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_914
L_889:
; 3749					fp->clust = clst;				/* Update current cluster */
.LINE 3749

	LD	BC,(IX+%FFFFFFE6)
	LD	A,(IX+%FFFFFFE9)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 3750				}
L_891:
.LINE 3750

; 3751				sect = clst2sect(fs, fp->clust);	/* Get current sector */
.LINE 3751

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 3752				if (sect == 0) ABORT(fs, FR_INT_ERR);
.LINE 3752

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_893
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_914
L_893:
; 3753				sect += csect;
.LINE 3753

	LD	BC,(IX+%FFFFFFED)
	XOR	A,A
	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	CALL	__ladd
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 3754				cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
.LINE 3754

	LD	HL,(IX+%C)
	LD	A,%9
	CALL	__ishru_b
	LD	(IX+%FFFFFFF3),HL
; 3755				if (cc > 0) {						/* Read maximum contiguous sectors directly */
.LINE 3755

	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_902
; 3756					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
.LINE 3756

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	DE,(IX+%FFFFFFF3)
	LD	HL,(IX+%FFFFFFED)
	ADD	HL,DE
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NC,L_896
; 3757						cc = fs->csize - csect;
.LINE 3757

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFED)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFF3),HL
; 3758					}
L_896:
.LINE 3758

; 3759					if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
.LINE 3759

	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	C,(IX+%FFFFFFF9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_897
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_914
L_897:
; 3760	#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
; 3761	#if FF_FS_TINY
; 3762					if (fs->wflag && fs->winsect - sect < cc) {
.LINE 3762

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%3)
	OR	A,A
	JR	Z,L_900
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	CALL	__lsub
	LD	BC,(IX+%FFFFFFF3)
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_900
; 3763						mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
.LINE 3763

	LD	BC,512
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%36
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	CALL	__lsub
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFF0)
	ADD	HL,BC
	PUSH	HL
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 3764					}
L_900:
.LINE 3764

; 3765	#else
; 3766					if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
; 3767						mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
; 3768					}
; 3769	#endif
; 3770	#endif
; 3771					rcnt = SS(fs) * cc;				/* Number of bytes transferred */
.LINE 3771

	LD	HL,(IX+%FFFFFFF3)
	LD	A,%9
	CALL	__ishl_b
	LD	(IX+%FFFFFFFA),HL
; 3772					continue;
.LINE 3772

	JR	L_910
; 3773				}
L_902:
.LINE 3773

; 3774	#if !FF_FS_TINY
; 3775				if (fp->sect != sect) {			/* Load data sector if not in cache */
; 3776	#if !FF_FS_READONLY
; 3777					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
; 3778						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 3779						fp->flag &= (BYTE)~FA_DIRTY;
; 3780					}
; 3781	#endif
; 3782					if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
; 3783				}
; 3784	#endif
; 3785				fp->sect = sect;
.LINE 3785

	LD	BC,(IX+%FFFFFFF6)
	LD	D,(IX+%FFFFFFF9)
	LD	IY,(IX+%6)
	LD	(IY+%19),BC
	LD	(IY+%1C),D
; 3786			}
L_904:
.LINE 3786

; 3787			rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
.LINE 3787

	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	BC,511
	CALL	__iand
	LD	BC,HL
	LD	HL,512
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 3788			if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
.LINE 3788

	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_907
	LD	BC,(IX+%C)
	LD	(IX+%FFFFFFFA),BC
L_907:
; 3789	#if FF_FS_TINY
; 3790			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
.LINE 3790

	LD	IY,(IX+%6)
	LD	BC,(IY+%19)
	LD	A,(IY+%1C)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_908
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_914
L_908:
; 3791			mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
.LINE 3791

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	(IX+%FFFFFFDA),A
	CALL	_mem_cpy
	LD	A,(IX+%FFFFFFDA)
	POP	BC
	POP	BC
	POP	BC
; 3792	#else
; 3793			mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
; 3794	#endif
; 3795		}
L_910:
.LINE 3795

	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%C),HL
	LD	HL,(IX+%F)
	LD	IY,(IX+%F)
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(HL)
	ADD	HL,BC
	LD	(IY),HL
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(IX+%FFFFFFF0),HL
	LD	BC,(IX+%FFFFFFFA)
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__ladd
	LD	(IY+%11),HL
	LD	(IY+%14),E
L_911:
	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_909
; 3796	
; 3797		LEAVE_FF(fs, FR_OK);
.LINE 3797

	OR	A,A
	SBC	HL,HL
; 3798	}
L_914:
.LINE 3798

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_read ***************************
;Name                         Addr/Register   Size   Type
;_disk_read                          IMPORT  -----   function
;remain                               IX-34      4   variable
;G_59                                 IX-30      4   variable
;clst                                 IX-26      4   variable
;res                                  IX-22      3   variable
;csect                                IX-19      3   variable
;rbuff                                IX-16      3   variable
;cc                                   IX-13      3   variable
;sect                                 IX-10      4   variable
;rcnt                                  IX-6      3   variable
;fs                                    IX-3      3   variable
;br                                   IX+15      3   parameter
;btr                                  IX+12      3   parameter
;buff                                  IX+9      3   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 56 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_read",3798,"_f_read"
; 3799	
; 3800	
; 3801	
; 3802	
; 3803	#if !FF_FS_READONLY
; 3804	/*-----------------------------------------------------------------------*/
; 3805	/* Write File                                                            */
; 3806	/*-----------------------------------------------------------------------*/
; 3807	
; 3808	FRESULT f_write (
; 3809		FIL* fp,			/* Pointer to the file object */
; 3810		const void* buff,	/* Pointer to the data to be written */
; 3811		UINT btw,			/* Number of bytes to write */
; 3812		UINT* bw			/* Pointer to number of bytes written */
; 3813	)
; 3814	{
_f_write:
.DEFINE "_f_write"

.VALUE _f_write

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_write",3814,"_f_write"

.LINE 3814

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "btw"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "bw"

.CLASS 65

.VALUE 15

.TYPE 46

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "wcnt"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE -14

.TYPE 15

.ENDEF

.DEFINE "cc"

.CLASS 65

.VALUE -17

.TYPE 14

.ENDEF

.DEFINE "wbuff"

.CLASS 65

.VALUE -20

.TYPE 204

.ENDEF

.DEFINE "csect"

.CLASS 65

.VALUE -23

.TYPE 14

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -26

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFC9
	LD	SP,HL
; 3815		FRESULT res;
; 3816		FATFS *fs;
; 3817		DWORD clst, sect;
; 3818		UINT wcnt, cc, csect;
; 3819		const BYTE *wbuff = (const BYTE*)buff;
.LINE 3819

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFEC),BC
; 3820	
; 3821	
; 3822		*bw = 0;	/* Clear write byte counter */
.LINE 3822

	LD	HL,(IX+%F)
	LD	BC,0
	LD	(HL),BC
; 3823		res = validate(&fp->obj, &fs);			/* Check validity of the file object */
.LINE 3823

	PEA	IX+%FFFFFFFD
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE6),HL
; 3824		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
.LINE 3824

	LD	BC,0
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_916
	LD	IY,(IX+%6)
	LD	A,(IY+%10)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFE6),HL
	LD	HL,(IX+%FFFFFFE6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_918
L_916:
	LD	HL,(IX+%FFFFFFE6)
	JR	L_966
L_918:
; 3825		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
.LINE 3825

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%2
	JR	NZ,L_920
	LD	HL,7
	JR	L_966
L_920:
; 3826	
; 3827		/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
; 3828		if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
.LINE 3828

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFDB),BC
	LD	(IX+%FFFFFFDE),A
	XOR	A,A
	LD	E,A
	LD	HL,(IX+%C)
	LD	A,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	BC,(IX+%FFFFFFDB)
	LD	A,(IX+%FFFFFFDE)
	CALL	__lcmpu
	JR	NC,L_963
; 3829			btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
.LINE 3829

	LD	BC,(IX+%FFFFFFDB)
	LD	HL,16777215
	OR	A,A
	SBC	HL,BC
	LD	(IX+%C),HL
; 3830		}
.LINE 3830

; 3831	
; 3832		for ( ;  btw;							/* Repeat until all data written */
.LINE 3832

	JR	L_963
; 3833			btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
L_961:
.LINE 3833

; 3834			if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
.LINE 3834

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFDF),BC
	LD	(IX+%FFFFFFE2),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFE2)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_956
; 3835				csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
.LINE 3835

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFDF)
	LD	A,(IX+%FFFFFFE2)
	LD	L,%9
	CALL	__lshru
	LD	HL,DE
	CALL	__iand
	LD	(IX+%FFFFFFE9),HL
; 3836				if (csect == 0) {				/* On the cluster boundary? */
.LINE 3836

	LD	BC,0
	LD	HL,(IX+%FFFFFFE9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_939
; 3837					if (fp->fptr == 0) {		/* On the top of the file? */
.LINE 3837

	LD	HL,(IX+%FFFFFFDF)
	LD	E,(IX+%FFFFFFE2)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_927
; 3838						clst = fp->obj.sclust;	/* Follow from the origin */
.LINE 3838

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFD8),BC
	LD	IY,(IX+%FFFFFFD8)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 3839						if (clst == 0) {		/* If no cluster is allocated, */
.LINE 3839

	LD	HL,BC
	LD	E,(IX+%FFFFFFF9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_929
; 3840							clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
.LINE 3840

	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%FFFFFFD8)
	PUSH	BC
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 3841						}
; 3842					} else {					/* On the middle or end of the file */
.LINE 3842

	JR	L_929
L_927:
; 3843	#if FF_USE_FASTSEEK
; 3844						if (fp->cltbl) {
; 3845							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
; 3846						} else
; 3847	#endif
; 3848						{
; 3849							clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
.LINE 3849

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%0
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 3850						}
; 3851					}
L_929:
.LINE 3851

; 3852					if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
.LINE 3852

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_965
; 3853					if (clst == 1) ABORT(fs, FR_INT_ERR);
.LINE 3853

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_932
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_966
L_932:
; 3854					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
.LINE 3854

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_934
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_966
L_934:
; 3855					fp->clust = clst;			/* Update current cluster */
.LINE 3855

	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 3856					if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
.LINE 3856

	LEA	BC,IY+%0
	LD	(IX+%FFFFFFD5),BC
	LD	IY,(IX+%FFFFFFD5)
	LD	HL,(IY+%7)
	LD	E,(IY+%A)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_939
	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	IY,(IX+%FFFFFFD5)
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 3857				}
L_939:
.LINE 3857

; 3858	#if FF_FS_TINY
; 3859				if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
.LINE 3859

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	IY,(IX+%6)
	LD	BC,(IY+%19)
	LD	A,(IY+%1C)
	CALL	__lcmpu
	JR	NZ,L_940
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_sync_window
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_940
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_966
L_940:
; 3860	#else
; 3861				if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
; 3862					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 3863					fp->flag &= (BYTE)~FA_DIRTY;
; 3864				}
; 3865	#endif
; 3866				sect = clst2sect(fs, fp->clust);	/* Get current sector */
.LINE 3866

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF2),HL
	LD	(IX+%FFFFFFF5),E
; 3867				if (sect == 0) ABORT(fs, FR_INT_ERR);
.LINE 3867

	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_942
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_966
L_942:
; 3868				sect += csect;
.LINE 3868

	LD	BC,(IX+%FFFFFFE9)
	XOR	A,A
	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	CALL	__ladd
	LD	(IX+%FFFFFFF2),HL
	LD	(IX+%FFFFFFF5),E
; 3869				cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
.LINE 3869

	LD	HL,(IX+%C)
	LD	A,%9
	CALL	__ishru_b
	LD	(IX+%FFFFFFEF),HL
; 3870				if (cc > 0) {					/* Write maximum contiguous sectors directly */
.LINE 3870

	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_953
; 3871					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
.LINE 3871

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	DE,(IX+%FFFFFFEF)
	LD	HL,(IX+%FFFFFFE9)
	ADD	HL,DE
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	NC,L_945
; 3872						cc = fs->csize - csect;
.LINE 3872

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFE9)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFEF),HL
; 3873					}
L_945:
.LINE 3873

; 3874					if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
.LINE 3874

	LD	BC,(IX+%FFFFFFEF)
	PUSH	BC
	LD	C,(IX+%FFFFFFF5)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	C,(IY+%1)
	LD	B,%0
	PUSH	BC
	CALL	_disk_write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_946
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_966
L_946:
; 3875	#if FF_FS_MINIMIZE <= 2
; 3876	#if FF_FS_TINY
; 3877					if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
.LINE 3877

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	BC,(IX+%FFFFFFF2)
	LD	A,(IX+%FFFFFFF5)
	CALL	__lsub
	LD	BC,(IX+%FFFFFFEF)
	XOR	A,A
	CALL	__lcmpu
	JR	NC,L_948
; 3878						mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
.LINE 3878

	LD	BC,512
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%32)
	LD	E,(IY+%35)
	LD	BC,(IX+%FFFFFFF2)
	LD	A,(IX+%FFFFFFF5)
	CALL	__lsub
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFEC)
	ADD	HL,BC
	PUSH	HL
	PEA	IY+%36
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 3879						fs->wflag = 0;
.LINE 3879

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),%0
; 3880					}
L_948:
.LINE 3880

; 3881	#else
; 3882					if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
; 3883						mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
; 3884						fp->flag &= (BYTE)~FA_DIRTY;
; 3885					}
; 3886	#endif
; 3887	#endif
; 3888					wcnt = SS(fs) * cc;		/* Number of bytes transferred */
.LINE 3888

	LD	HL,(IX+%FFFFFFEF)
	LD	A,%9
	CALL	__ishl_b
	LD	(IX+%FFFFFFFA),HL
; 3889					continue;
.LINE 3889

	JR	L_962
; 3890				}
L_953:
.LINE 3890

; 3891	#if FF_FS_TINY
; 3892				if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
.LINE 3892

	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	CALL	__lcmpu
	JR	C,L_954
; 3893					if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
.LINE 3893

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	(IX+%FFFFFFC9),A
	CALL	_sync_window
	LD	A,(IX+%FFFFFFC9)
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_951
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_966
L_951:
; 3894					fs->winsect = sect;
.LINE 3894

	LD	BC,(IX+%FFFFFFF2)
	LD	D,(IX+%FFFFFFF5)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%32),BC
	LD	(IY+%35),D
; 3895				}
L_954:
.LINE 3895

; 3896	#else
; 3897				if (fp->sect != sect && 		/* Fill sector cache with file data */
; 3898					fp->fptr < fp->obj.objsize &&
; 3899					disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
; 3900						ABORT(fs, FR_DISK_ERR);
; 3901				}
; 3902	#endif
; 3903				fp->sect = sect;
.LINE 3903

	LD	BC,(IX+%FFFFFFF2)
	LD	D,(IX+%FFFFFFF5)
	LD	IY,(IX+%6)
	LD	(IY+%19),BC
	LD	(IY+%1C),D
; 3904			}
L_956:
.LINE 3904

; 3905			wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
.LINE 3905

	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	BC,511
	CALL	__iand
	LD	BC,HL
	LD	HL,512
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 3906			if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
.LINE 3906

	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_959
	LD	BC,(IX+%C)
	LD	(IX+%FFFFFFFA),BC
L_959:
; 3907	#if FF_FS_TINY
; 3908			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
.LINE 3908

	LD	IY,(IX+%6)
	LD	BC,(IY+%19)
	LD	A,(IY+%1C)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_960
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_966
L_960:
; 3909			mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
.LINE 3909

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	LD	(IX+%FFFFFFC9),A
	CALL	_mem_cpy
	LD	A,(IX+%FFFFFFC9)
	POP	BC
	POP	BC
	POP	BC
; 3910			fs->wflag = 1;
.LINE 3910

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),%1
; 3911	#else
; 3912			mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
; 3913			fp->flag |= FA_DIRTY;
; 3914	#endif
; 3915		}
L_962:
.LINE 3915

	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%C),HL
	LD	HL,(IX+%F)
	LD	IY,(IX+%F)
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(HL)
	ADD	HL,BC
	LD	(IY),HL
	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%FFFFFFEC)
	ADD	HL,BC
	LD	(IX+%FFFFFFEC),HL
	LD	BC,(IX+%FFFFFFFA)
	XOR	A,A
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__ladd
	LD	(IY+%11),HL
	LD	(IY+%14),E
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFCA),BC
	LD	(IX+%FFFFFFCD),A
	LEA	DE,IY+%0
	LD	(IX+%FFFFFFE3),DE
	LD	(IX+%FFFFFFD2),DE
	LD	IY,(IX+%FFFFFFE3)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	A,(IX+%FFFFFFCD)
	CALL	__lcmpu
	JR	NC,L_923
	LD	BC,(IX+%FFFFFFCA)
	LD	A,(IX+%FFFFFFCD)
	LD	(IX+%FFFFFFCE),BC
	LD	(IX+%FFFFFFD1),A
	JR	L_924
L_923:
	LD	BC,(IX+%FFFFFFE3)
	LD	(IX+%FFFFFFD2),BC
	LD	IY,(IX+%FFFFFFE3)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	(IX+%FFFFFFCE),BC
	LD	(IX+%FFFFFFD1),A
L_924:
	LD	BC,(IX+%FFFFFFCE)
	LD	A,(IX+%FFFFFFD1)
	LD	IY,(IX+%FFFFFFD2)
	LD	(IY+%B),BC
	LD	(IY+%E),A
L_963:
	LD	BC,0
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_961
L_965:
; 3916	
; 3917		fp->flag |= FA_MODIFIED;				/* Set file change flag */
.LINE 3917

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	SET	%6,A
	LD	(IY+%F),A
; 3918	
; 3919		LEAVE_FF(fs, FR_OK);
.LINE 3919

	OR	A,A
	SBC	HL,HL
; 3920	}
L_966:
.LINE 3920

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_write ***************************
;Name                         Addr/Register   Size   Type
;_disk_write                         IMPORT  -----   function
;G_66                                 IX-54      4   variable
;temp921                              IX-50      4   variable
;G_68                                 IX-46      3   variable
;G_65                                 IX-43      3   variable
;G_64                                 IX-40      3   variable
;G_61                                 IX-37      4   variable
;G_62                                 IX-33      4   variable
;G_67                                 IX-29      3   variable
;res                                  IX-26      3   variable
;csect                                IX-23      3   variable
;wbuff                                IX-20      3   variable
;cc                                   IX-17      3   variable
;sect                                 IX-14      4   variable
;clst                                 IX-10      4   variable
;wcnt                                  IX-6      3   variable
;fs                                    IX-3      3   variable
;bw                                   IX+15      3   parameter
;btw                                  IX+12      3   parameter
;buff                                  IX+9      3   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 73 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_write",3920,"_f_write"
; 3921	
; 3922	
; 3923	
; 3924	
; 3925	/*-----------------------------------------------------------------------*/
; 3926	/* Synchronize the File                                                  */
; 3927	/*-----------------------------------------------------------------------*/
; 3928	
; 3929	FRESULT f_sync (
; 3930		FIL* fp		/* Pointer to the file object */
; 3931	)
; 3932	{
_f_sync:
.DEFINE "_f_sync"

.VALUE _f_sync

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_sync",3932,"_f_sync"

.LINE 3932

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE -3

.TYPE 44

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -9

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "tm"

.CLASS 65

.VALUE -13

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 3933		FRESULT res;
; 3934		FATFS *fs;
; 3935		DWORD tm;
; 3936		BYTE *dir;
; 3937	
; 3938	
; 3939		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
.LINE 3939

	PEA	IX+%FFFFFFF7
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3940		if (res == FR_OK) {
.LINE 3940

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_970
; 3941			if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
.LINE 3941

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%40
	JR	Z,L_970
; 3942	#if !FF_FS_TINY
; 3943				if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
; 3944					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
; 3945					fp->flag &= (BYTE)~FA_DIRTY;
; 3946				}
; 3947	#endif
; 3948				/* Update the directory entry */
; 3949				tm = GET_FATTIME();				/* Modified time */
.LINE 3949

	CALL	_get_fattime
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
; 3950	#if FF_FS_EXFAT
; 3951				if (fs->fs_type == FS_EXFAT) {
; 3952					res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
; 3953					if (res == FR_OK) {
; 3954						res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
; 3955					}
; 3956					if (res == FR_OK) {
; 3957						DIR dj;
; 3958						DEF_NAMBUF
; 3959	
; 3960						INIT_NAMBUF(fs);
; 3961						res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
; 3962						if (res == FR_OK) {
; 3963							fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
; 3964							fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
; 3965							st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
; 3966							st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
; 3967							st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
; 3968							st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
; 3969							fs->dirbuf[XDIR_ModTime10] = 0;
; 3970							st_dword(fs->dirbuf + XDIR_AccTime, 0);
; 3971							res = store_xdir(&dj);	/* Restore it to the directory */
; 3972							if (res == FR_OK) {
; 3973								res = sync_fs(fs);
; 3974								fp->flag &= (BYTE)~FA_MODIFIED;
; 3975							}
; 3976						}
; 3977						FREE_NAMBUF();
; 3978					}
; 3979				} else
; 3980	#endif
; 3981				{
; 3982					res = move_window(fs, fp->dir_sect);
.LINE 3982

	LD	IY,(IX+%6)
	LD	BC,(IY+%1D)
	LD	A,(IY+%20)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3983					if (res == FR_OK) {
.LINE 3983

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_970
; 3984						dir = fp->dir_ptr;
.LINE 3984

	LD	IY,(IX+%6)
	LD	BC,(IY+%21)
	LD	(IX+%FFFFFFFD),BC
; 3985						dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
.LINE 3985

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%B
	LD	A,(HL)
	SET	%5,A
	LEA	HL,IY+%B
	LD	(HL),A
; 3986						st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
.LINE 3986

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFF0),BC
	LD	IY,(IX+%FFFFFFF0)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	BC,(IY+%0)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 3987						st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
.LINE 3987

	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%1C
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 3988						st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
.LINE 3988

	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 3989						st_word(dir + DIR_LstAccDate, 0);
.LINE 3989

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%12
	PUSH	BC
	CALL	_st_word
	POP	BC
	POP	BC
; 3990						fs->wflag = 1;
.LINE 3990

	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),%1
; 3991						res = sync_fs(fs);					/* Restore it to the directory */
.LINE 3991

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_sync_fs
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 3992						fp->flag &= (BYTE)~FA_MODIFIED;
.LINE 3992

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	RES	%6,A
	LD	(IY+%F),A
; 3993					}
; 3994				}
; 3995			}
; 3996		}
L_970:
.LINE 3996

; 3997	
; 3998		LEAVE_FF(fs, res);
.LINE 3998

	LD	HL,(IX+%FFFFFFFA)
; 3999	}
.LINE 3999

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_sync ***************************
;Name                         Addr/Register   Size   Type
;_get_fattime                        IMPORT  -----   function
;tm                                   IX-13      4   variable
;fs                                    IX-9      3   variable
;res                                   IX-6      3   variable
;dir                                   IX-3      3   variable
;fp                                    IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_sync",3999,"_f_sync"
; 4000	
; 4001	#endif /* !FF_FS_READONLY */
; 4002	
; 4003	
; 4004	
; 4005	
; 4006	/*-----------------------------------------------------------------------*/
; 4007	/* Close File                                                            */
; 4008	/*-----------------------------------------------------------------------*/
; 4009	
; 4010	FRESULT f_close (
; 4011		FIL* fp		/* Pointer to the file object to be closed */
; 4012	)
; 4013	{
_f_close:
.DEFINE "_f_close"

.VALUE _f_close

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_close",4013,"_f_close"

.LINE 4013

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 4014		FRESULT res;
; 4015		FATFS *fs;
; 4016	
; 4017	#if !FF_FS_READONLY
; 4018		res = f_sync(fp);					/* Flush cached data */
.LINE 4018

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_f_sync
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4019		if (res == FR_OK)
.LINE 4019

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_974
; 4020	#endif
; 4021		{
; 4022			res = validate(&fp->obj, &fs);	/* Lock volume */
.LINE 4022

	PEA	IX+%FFFFFFFA
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4023			if (res == FR_OK) {
.LINE 4023

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_974
; 4024	#if FF_FS_LOCK != 0
; 4025				res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
; 4026				if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
; 4027	#else
; 4028				fp->obj.fs = 0;	/* Invalidate file object */
.LINE 4028

	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 4029	#endif
; 4030	#if FF_FS_REENTRANT
; 4031				unlock_fs(fs, FR_OK);		/* Unlock volume */
; 4032	#endif
; 4033			}
; 4034		}
L_974:
.LINE 4034

; 4035		return res;
.LINE 4035

	LD	HL,(IX+%FFFFFFFD)
; 4036	}
.LINE 4036

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_close ***************************
;Name                         Addr/Register   Size   Type
;_f_sync                             IMPORT  -----   function
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;fp                                    IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_close",4036,"_f_close"
; 4037	
; 4038	
; 4039	
; 4040	
; 4041	#if FF_FS_RPATH >= 1
; 4042	/*-----------------------------------------------------------------------*/
; 4043	/* Change Current Directory or Current Drive, Get Current Directory      */
; 4044	/*-----------------------------------------------------------------------*/
; 4045	
; 4046	FRESULT f_chdrive (
; 4047		const TCHAR* path		/* Drive number to set */
; 4048	)
; 4049	{
_f_chdrive:
.DEFINE "_f_chdrive"

.VALUE _f_chdrive

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_chdrive",4049,"_f_chdrive"

.LINE 4049

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "vol"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 4050		int vol;
; 4051	
; 4052	
; 4053		/* Get logical drive number */
; 4054		vol = get_ldnumber(&path);
.LINE 4054

	PEA	IX+%6
	CALL	_get_ldnumber
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4055		if (vol < 0) return FR_INVALID_DRIVE;
.LINE 4055

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	P,L_977
	LD	HL,11
	JR	L_978
L_977:
; 4056		CurrVol = (BYTE)vol;	/* Set it as current volume */
.LINE 4056

	LD	A,(IX+%FFFFFFFD)
	LD	(_CurrVol),A
; 4057	
; 4058		return FR_OK;
.LINE 4058

	OR	A,A
	SBC	HL,HL
; 4059	}
L_978:
.LINE 4059

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_chdrive ***************************
;Name                         Addr/Register   Size   Type
;_CurrVol                            STATIC      1   variable
;vol                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_chdrive",4059,"_f_chdrive"
; 4060	
; 4061	
; 4062	
; 4063	FRESULT f_chdir (
; 4064		const TCHAR* path	/* Pointer to the directory path */
; 4065	)
; 4066	{
_f_chdir:
.DEFINE "_f_chdir"

.VALUE _f_chdir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_chdir",4066,"_f_chdir"

.LINE 4066

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -52

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFCC
	LD	SP,HL
; 4067	#if FF_STR_VOLUME_ID == 2
; 4068		UINT i;
; 4069	#endif
; 4070		FRESULT res;
; 4071		DIR dj;
; 4072		FATFS *fs;
; 4073		DEF_NAMBUF
; 4074	
; 4075	
; 4076		/* Get logical drive */
; 4077		res = find_volume(&path, &fs, 0);
.LINE 4077

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4078		if (res == FR_OK) {
.LINE 4078

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_987
; 4079			dj.obj.fs = fs;
.LINE 4079

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFCC),BC
; 4080			INIT_NAMBUF(fs);
; 4081			res = follow_path(&dj, path);		/* Follow the path */
.LINE 4081

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFFCC
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4082			if (res == FR_OK) {					/* Follow completed */
.LINE 4082

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_984
; 4083				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
.LINE 4083

	LEA	IY,IX+%FFFFFFEA
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_982
; 4084					fs->cdir = dj.obj.sclust;
.LINE 4084

	LD	BC,(IX+%FFFFFFD3)
	LD	A,(IX+%FFFFFFD6)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%16),BC
	LD	(IY+%19),A
; 4085	#if FF_FS_EXFAT
; 4086					if (fs->fs_type == FS_EXFAT) {
; 4087						fs->cdc_scl = dj.obj.c_scl;
; 4088						fs->cdc_size = dj.obj.c_size;
; 4089						fs->cdc_ofs = dj.obj.c_ofs;
; 4090					}
; 4091	#endif
; 4092				} else {
.LINE 4092

	JR	L_984
L_982:
; 4093					if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
.LINE 4093

	LD	A,(IX+%FFFFFFD1)
	AND	A,%10
	JR	Z,L_980
; 4094	#if FF_FS_EXFAT
; 4095						if (fs->fs_type == FS_EXFAT) {
; 4096							fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
; 4097							fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
; 4098							fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
; 4099							fs->cdc_ofs = dj.blk_ofs;
; 4100						} else
; 4101	#endif
; 4102						{
; 4103							fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
.LINE 4103

	LD	BC,(IX+%FFFFFFE7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%16),HL
	LD	(IY+%19),E
; 4104						}
; 4105					} else {
.LINE 4105

	JR	L_984
L_980:
; 4106						res = FR_NO_PATH;		/* Reached but a file */
.LINE 4106

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4107					}
; 4108				}
; 4109			}
L_984:
.LINE 4109

; 4110			FREE_NAMBUF();
; 4111			if (res == FR_NO_FILE) res = FR_NO_PATH;
.LINE 4111

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_987
	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4112	#if FF_STR_VOLUME_ID == 2	/* Also current drive is changed at Unix style volume ID */
; 4113			if (res == FR_OK) {
; 4114				for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;	/* Set current drive */
; 4115				CurrVol = (BYTE)i;
; 4116			}
; 4117	#endif
; 4118		}
L_987:
.LINE 4118

; 4119	
; 4120		LEAVE_FF(fs, res);
.LINE 4120

	LD	HL,(IX+%FFFFFFFD)
; 4121	}
.LINE 4121

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_chdir ***************************
;Name                         Addr/Register   Size   Type
;dj                                   IX-52     46   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 61 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_chdir",4121,"_f_chdir"
; 4122	
; 4123	
; 4124	#if FF_FS_RPATH >= 2
; 4125	FRESULT f_getcwd (
; 4126		TCHAR* buff,	/* Pointer to the directory path */
; 4127		UINT len		/* Size of buff in unit of TCHAR */
; 4128	)
; 4129	{
; 4130		FRESULT res;
; 4131		DIR dj;
; 4132		FATFS *fs;
; 4133		UINT i, n;
; 4134		DWORD ccl;
; 4135		TCHAR *tp = buff;
; 4136	#if FF_VOLUMES >= 2
; 4137		UINT vl;
; 4138	#endif
; 4139	#if FF_STR_VOLUME_ID
; 4140		const char *vp;
; 4141	#endif
; 4142		FILINFO fno;
; 4143		DEF_NAMBUF
; 4144	
; 4145	
; 4146		/* Get logical drive */
; 4147		res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
; 4148		if (res == FR_OK) {
; 4149			dj.obj.fs = fs;
; 4150			INIT_NAMBUF(fs);
; 4151	
; 4152			/* Follow parent directories and create the path */
; 4153			i = len;			/* Bottom of buffer (directory stack base) */
; 4154			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
; 4155				dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
; 4156				while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
; 4157					res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
; 4158					if (res != FR_OK) break;
; 4159					res = move_window(fs, dj.sect);
; 4160					if (res != FR_OK) break;
; 4161					dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
; 4162					res = dir_sdi(&dj, 0);
; 4163					if (res != FR_OK) break;
; 4164					do {							/* Find the entry links to the child directory */
; 4165						res = dir_read_file(&dj);
; 4166						if (res != FR_OK) break;
; 4167						if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
; 4168						res = dir_next(&dj, 0);
; 4169					} while (res == FR_OK);
; 4170					if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
; 4171					if (res != FR_OK) break;
; 4172					get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
; 4173					for (n = 0; fno.fname[n]; n++) ;	/* Name length */
; 4174					if (i < n + 1) {	/* Insufficient space to store the path name? */
; 4175						res = FR_NOT_ENOUGH_CORE; break;
; 4176					}
; 4177					while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
; 4178					buff[--i] = '/';
; 4179				}
; 4180			}
; 4181			if (res == FR_OK) {
; 4182				if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
; 4183	#if FF_VOLUMES >= 2			/* Put drive prefix */
; 4184				vl = 0;
; 4185	#if FF_STR_VOLUME_ID >= 1	/* String volume ID */
; 4186				for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;
; 4187				if (i >= n + 2) {
; 4188					if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';
; 4189					for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;
; 4190					if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';
; 4191					vl++;
; 4192				}
; 4193	#else						/* Numeric volume ID */
; 4194				if (i >= 3) {
; 4195					*tp++ = (TCHAR)'0' + CurrVol;
; 4196					*tp++ = (TCHAR)':';
; 4197					vl = 2;
; 4198				}
; 4199	#endif
; 4200				if (vl == 0) res = FR_NOT_ENOUGH_CORE;
; 4201	#endif
; 4202				/* Add current directory path */
; 4203				if (res == FR_OK) {
; 4204					do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
; 4205				}
; 4206			}
; 4207			FREE_NAMBUF();
; 4208		}
; 4209	
; 4210		*tp = 0;
; 4211		LEAVE_FF(fs, res);
; 4212	}
; 4213	
; 4214	#endif /* FF_FS_RPATH >= 2 */
; 4215	#endif /* FF_FS_RPATH >= 1 */
; 4216	
; 4217	
; 4218	
; 4219	#if FF_FS_MINIMIZE <= 2
; 4220	/*-----------------------------------------------------------------------*/
; 4221	/* Seek File Read/Write Pointer                                          */
; 4222	/*-----------------------------------------------------------------------*/
; 4223	
; 4224	FRESULT f_lseek (
; 4225		FIL* fp,		/* Pointer to the file object */
; 4226		FSIZE_t ofs		/* File pointer from top of file */
; 4227	)
; 4228	{
_f_lseek:
.DEFINE "_f_lseek"

.VALUE _f_lseek

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_lseek",4228,"_f_lseek"

.LINE 4228

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "ofs"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -7

.TYPE 4

.ENDEF

.DEFINE "bcs"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

.DEFINE "nsect"

.CLASS 65

.VALUE -15

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -18

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "ifptr"

.CLASS 65

.VALUE -28

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD8
	LD	SP,HL
; 4229		FRESULT res;
; 4230		FATFS *fs;
; 4231		DWORD clst, bcs, nsect;
; 4232		FSIZE_t ifptr;
; 4233	#if FF_USE_FASTSEEK
; 4234		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
; 4235	#endif
; 4236	
; 4237		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
.LINE 4237

	PEA	IX+%FFFFFFEE
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF9),HL
; 4238		if (res == FR_OK) res = (FRESULT)fp->err;
.LINE 4238

	LD	BC,0
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_991
	LD	IY,(IX+%6)
	LD	A,(IY+%10)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF9),HL
L_991:
; 4239	#if FF_FS_EXFAT && !FF_FS_READONLY
; 4240		if (res == FR_OK && fs->fs_type == FS_EXFAT) {
; 4241			res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
; 4242		}
; 4243	#endif
; 4244		if (res != FR_OK) LEAVE_FF(fs, res);
.LINE 4244

	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_1029
	LD	HL,(IX+%FFFFFFF9)
	JR	L_1031
L_1029:
; 4245	
; 4246	#if FF_USE_FASTSEEK
; 4247		if (fp->cltbl) {	/* Fast seek */
; 4248			if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
; 4249				tbl = fp->cltbl;
; 4250				tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
; 4251				cl = fp->obj.sclust;		/* Origin of the chain */
; 4252				if (cl != 0) {
; 4253					do {
; 4254						/* Get a fragment */
; 4255						tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
; 4256						do {
; 4257							pcl = cl; ncl++;
; 4258							cl = get_fat(&fp->obj, cl);
; 4259							if (cl <= 1) ABORT(fs, FR_INT_ERR);
; 4260							if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
; 4261						} while (cl == pcl + 1);
; 4262						if (ulen <= tlen) {		/* Store the length and top of the fragment */
; 4263							*tbl++ = ncl; *tbl++ = tcl;
; 4264						}
; 4265					} while (cl < fs->n_fatent);	/* Repeat until end of chain */
; 4266				}
; 4267				*fp->cltbl = ulen;	/* Number of items used */
; 4268				if (ulen <= tlen) {
; 4269					*tbl = 0;		/* Terminate table */
; 4270				} else {
; 4271					res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
; 4272				}
; 4273			} else {						/* Fast seek */
; 4274				if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
; 4275				fp->fptr = ofs;				/* Set file pointer */
; 4276				if (ofs > 0) {
; 4277					fp->clust = clmt_clust(fp, ofs - 1);
; 4278					dsc = clst2sect(fs, fp->clust);
; 4279					if (dsc == 0) ABORT(fs, FR_INT_ERR);
; 4280					dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
; 4281					if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
; 4282	#if !FF_FS_TINY
; 4283	#if !FF_FS_READONLY
; 4284						if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
; 4285							if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4286							fp->flag &= (BYTE)~FA_DIRTY;
; 4287						}
; 4288	#endif
; 4289						if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
; 4290	#endif
; 4291						fp->sect = dsc;
; 4292					}
; 4293				}
; 4294			}
; 4295		} else
; 4296	#endif
; 4297	
; 4298		/* Normal Seek */
; 4299		{
; 4300	#if FF_FS_EXFAT
; 4301			if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at FATxx */
; 4302	#endif
; 4303			if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
.LINE 4303

	LD	IY,(IX+%6)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	NC,L_994
	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%2
	JR	NZ,L_994
; 4304				ofs = fp->obj.objsize;
.LINE 4304

	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	(IX+%9),BC
	LD	(IX+%C),A
; 4305			}
L_994:
.LINE 4305

; 4306			ifptr = fp->fptr;
.LINE 4306

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFE4),BC
	LD	(IX+%FFFFFFE7),A
; 4307			fp->fptr = nsect = 0;
.LINE 4307

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF1),BC
	LD	(IX+%FFFFFFF4),A
	LD	(IY+%11),BC
	LD	(IY+%14),%0
; 4308			if (ofs > 0) {
.LINE 4308

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	NC,L_1025
; 4309				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
.LINE 4309

	LD	IY,(IX+%FFFFFFEE)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 4310				if (ifptr > 0 &&
.LINE 4310

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFE4)
	LD	A,(IX+%FFFFFFE7)
	CALL	__lcmpu
	JR	NC,L_1003
; 4311					(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
.LINE 4311

	LD	HL,(IX+%FFFFFFE4)
	LD	E,(IX+%FFFFFFE7)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFDC),HL
	LD	(IX+%FFFFFFDF),E
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__ldivu
	LD	(IX+%FFFFFFDB),E
	LD	(IX+%FFFFFFD8),HL
	LD	HL,(IX+%FFFFFFDC)
	LD	E,(IX+%FFFFFFDF)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__ldivu
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFDB)
	LD	HL,(IX+%FFFFFFD8)
	CALL	__lcmpu
	JR	C,L_1003
; 4312					fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
.LINE 4312

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	CALL	__lnot
	LD	BC,(IX+%FFFFFFDC)
	LD	A,(IX+%FFFFFFDF)
	CALL	__land
	LD	IY,(IX+%6)
	LD	(IY+%11),HL
	LD	(IY+%14),E
; 4313					ofs -= fp->fptr;
.LINE 4313

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
; 4314					clst = fp->clust;
.LINE 4314

	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 4315				} else {									/* When seek to back cluster, */
.LINE 4315

	JR	L_1022
L_1003:
; 4316					clst = fp->obj.sclust;					/* start from the first cluster */
.LINE 4316

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFEB),BC
	LD	IY,(IX+%FFFFFFEB)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 4317	#if !FF_FS_READONLY
; 4318					if (clst == 0) {						/* If no cluster chain, create a new chain */
.LINE 4318

	LD	HL,BC
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1001
; 4319						clst = create_chain(&fp->obj, 0);
.LINE 4319

	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%FFFFFFEB)
	PUSH	BC
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 4320						if (clst == 1) ABORT(fs, FR_INT_ERR);
.LINE 4320

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_997
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_1031
L_997:
; 4321						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
.LINE 4321

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_999
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_1031
L_999:
; 4322						fp->obj.sclust = clst;
.LINE 4322

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 4323					}
L_1001:
.LINE 4323

; 4324	#endif
; 4325					fp->clust = clst;
.LINE 4325

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 4326				}
L_1022:
.LINE 4326

; 4327				if (clst != 0) {
.LINE 4327

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1015
	JR	L_1025
; 4328					while (ofs > bcs) {						/* Cluster following loop */
L_1016:
.LINE 4328

; 4329						ofs -= bcs; fp->fptr += bcs;
.LINE 4329

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lsub
	LD	(IX+%9),HL
	LD	(IX+%C),E
	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__ladd
	LD	(IY+%11),HL
	LD	(IY+%14),E
; 4330	#if !FF_FS_READONLY
; 4331						if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
.LINE 4331

	LD	A,(IY+%F)
	AND	A,%2
	JR	Z,L_1008
; 4332							if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
; 4333								fp->obj.objsize = fp->fptr;
; 4334								fp->flag |= FA_MODIFIED;
; 4335							}
; 4336							clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
.LINE 4336

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 4337							if (clst == 0) {				/* Clip file size in case of disk full */
.LINE 4337

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1010
; 4338								ofs = 0; break;
.LINE 4338

	XOR	A,A
	LD	(IX+%9),BC
	LD	(IX+%C),A
	JR	L_1017
; 4339							}
; 4340						} else
L_1008:
.LINE 4340

; 4341	#endif
; 4342						{
; 4343							clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
.LINE 4343

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 4344						}
L_1010:
.LINE 4344

; 4345						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
.LINE 4345

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_1011
	LD	IY,(IX+%6)
	LD	(IY+%10),%1
	LD	HL,1
	JR	L_1031
L_1011:
; 4346						if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
.LINE 4346

	LD	HL,1
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	NC,L_1013
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	IY,(IX+%FFFFFFEE)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_1014
L_1013:
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_1031
L_1014:
; 4347						fp->clust = clst;
.LINE 4347

	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	IY,(IX+%6)
	LD	(IY+%15),BC
	LD	(IY+%18),A
; 4348					}
L_1015:
.LINE 4348

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__lcmpu
	JR	C,L_1016
L_1017:
; 4349					fp->fptr += ofs;
.LINE 4349

	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__ladd
	LD	(IY+%11),HL
	LD	(IY+%14),E
; 4350					if (ofs % SS(fs)) {
.LINE 4350

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_1025
; 4351						nsect = clst2sect(fs, clst);	/* Current sector */
.LINE 4351

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF1),HL
	LD	(IX+%FFFFFFF4),E
; 4352						if (nsect == 0) ABORT(fs, FR_INT_ERR);
.LINE 4352

	LD	HL,(IX+%FFFFFFF1)
	LD	E,(IX+%FFFFFFF4)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1019
	LD	IY,(IX+%6)
	LD	(IY+%10),%2
	LD	HL,2
	JR	L_1031
L_1019:
; 4353						nsect += (DWORD)(ofs / SS(fs));
.LINE 4353

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	L,%9
	CALL	__lshru
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	CALL	__ladd
	LD	(IX+%FFFFFFF1),HL
	LD	(IX+%FFFFFFF4),E
; 4354					}
; 4355				}
; 4356			}
L_1025:
.LINE 4356

; 4357			if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
.LINE 4357

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFE8),BC
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFE0),BC
	LD	(IX+%FFFFFFE3),A
	LD	IY,(IX+%FFFFFFE8)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	A,(IX+%FFFFFFE3)
	CALL	__lcmpu
	JR	NC,L_1028
; 4358				fp->obj.objsize = fp->fptr;
.LINE 4358

	LD	BC,(IX+%FFFFFFE0)
	LD	A,(IX+%FFFFFFE3)
	LD	IY,(IX+%FFFFFFE8)
	LD	(IY+%B),BC
	LD	(IY+%E),A
; 4359				fp->flag |= FA_MODIFIED;
.LINE 4359

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	SET	%6,A
	LD	(IY+%F),A
; 4360			}
L_1028:
.LINE 4360

; 4361			if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
.LINE 4361

	LD	IY,(IX+%6)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	LD	BC,511
	XOR	A,A
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_1030
	LD	IY,(IX+%6)
	LD	HL,(IY+%19)
	LD	E,(IY+%1C)
	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	CALL	__lcmpu
	JR	Z,L_1030
; 4362	#if !FF_FS_TINY
; 4363	#if !FF_FS_READONLY
; 4364				if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
; 4365					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
; 4366					fp->flag &= (BYTE)~FA_DIRTY;
; 4367				}
; 4368	#endif
; 4369				if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
; 4370	#endif
; 4371				fp->sect = nsect;
.LINE 4371

	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	LD	IY,(IX+%6)
	LD	(IY+%19),BC
	LD	(IY+%1C),A
; 4372			}
; 4373		}
L_1030:
.LINE 4373

; 4374	
; 4375		LEAVE_FF(fs, res);
.LINE 4375

	LD	HL,(IX+%FFFFFFF9)
; 4376	}
L_1031:
.LINE 4376

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_lseek ***************************
;Name                         Addr/Register   Size   Type
;G_71                                 IX-36      4   variable
;G_74                                 IX-32      4   variable
;ifptr                                IX-28      4   variable
;G_73                                 IX-24      3   variable
;G_72                                 IX-21      3   variable
;fs                                   IX-18      3   variable
;nsect                                IX-15      4   variable
;bcs                                  IX-11      4   variable
;res                                   IX-7      3   variable
;clst                                  IX-4      4   variable
;ofs                                   IX+9      4   parameter
;fp                                    IX+6      3   parameter


; Stack Frame Size: 55 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_lseek",4376,"_f_lseek"
; 4377	
; 4378	
; 4379	
; 4380	#if FF_FS_MINIMIZE <= 1
; 4381	/*-----------------------------------------------------------------------*/
; 4382	/* Create a Directory Object                                             */
; 4383	/*-----------------------------------------------------------------------*/
; 4384	
; 4385	FRESULT f_opendir (
; 4386		DIR* dp,			/* Pointer to directory object to create */
; 4387		const TCHAR* path	/* Pointer to the directory path */
; 4388	)
; 4389	{
_f_opendir:
.DEFINE "_f_opendir"

.VALUE _f_opendir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_opendir",4389,"_f_opendir"

.LINE 4389

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "path"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 4390		FRESULT res;
; 4391		FATFS *fs;
; 4392		DEF_NAMBUF
; 4393	
; 4394	
; 4395		if (!dp) return FR_INVALID_OBJECT;
.LINE 4395

	LD	BC,0
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1033
	LD	HL,9
	JR	L_1046
L_1033:
; 4396	
; 4397		/* Get logical drive */
; 4398		res = find_volume(&path, &fs, 0);
.LINE 4398

	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%9
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4399		if (res == FR_OK) {
.LINE 4399

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1044
; 4400			dp->obj.fs = fs;
.LINE 4400

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 4401			INIT_NAMBUF(fs);
; 4402			res = follow_path(dp, path);			/* Follow the path to the directory */
.LINE 4402

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4403			if (res == FR_OK) {						/* Follow completed */
.LINE 4403

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1040
; 4404				if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
.LINE 4404

	LD	IY,(IX+%6)
	LD	A,(IY+%29)
	AND	A,%80
	JR	NZ,L_1038
; 4405					if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
.LINE 4405

	LD	IY,(IX+%6)
	LD	A,(IY+%5)
	AND	A,%10
	JR	Z,L_1035
; 4406	#if FF_FS_EXFAT
; 4407						if (fs->fs_type == FS_EXFAT) {
; 4408							dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
; 4409							dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
; 4410							dp->obj.c_ofs = dp->blk_ofs;
; 4411							init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
; 4412						} else
; 4413	#endif
; 4414						{
; 4415							dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
.LINE 4415

	LD	IY,(IX+%6)
	LD	BC,(IY+%1B)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	IY,(IX+%6)
	LD	(IY+%7),HL
	LD	(IY+%A),E
; 4416						}
; 4417					} else {						/* This object is a file */
.LINE 4417

	JR	L_1038
L_1035:
; 4418						res = FR_NO_PATH;
.LINE 4418

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4419					}
; 4420				}
L_1038:
.LINE 4420

; 4421				if (res == FR_OK) {
.LINE 4421

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1040
; 4422					dp->obj.id = fs->id;
.LINE 4422

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%5)
	LD	IY,(IX+%6)
	LD	(IY+%3),C
	LD	(IY+%4),B
; 4423					res = dir_sdi(dp, 0);			/* Rewind directory */
.LINE 4423

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4424	#if FF_FS_LOCK != 0
; 4425					if (res == FR_OK) {
; 4426						if (dp->obj.sclust != 0) {
; 4427							dp->obj.lockid = inc_lock(dp, 0);	/* Lock the sub directory */
; 4428							if (!dp->obj.lockid) res = FR_TOO_MANY_OPEN_FILES;
; 4429						} else {
; 4430							dp->obj.lockid = 0;	/* Root directory need not to be locked */
; 4431						}
; 4432					}
; 4433	#endif
; 4434				}
; 4435			}
L_1040:
.LINE 4435

; 4436			FREE_NAMBUF();
; 4437			if (res == FR_NO_FILE) res = FR_NO_PATH;
.LINE 4437

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1044
	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
; 4438		}
L_1044:
.LINE 4438

; 4439		if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
.LINE 4439

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_1045
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
L_1045:
; 4440	
; 4441		LEAVE_FF(fs, res);
.LINE 4441

	LD	HL,(IX+%FFFFFFFD)
; 4442	}
L_1046:
.LINE 4442

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_opendir ***************************
;Name                         Addr/Register   Size   Type
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path                                  IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_opendir",4442,"_f_opendir"
; 4443	
; 4444	
; 4445	
; 4446	
; 4447	/*-----------------------------------------------------------------------*/
; 4448	/* Close Directory                                                       */
; 4449	/*-----------------------------------------------------------------------*/
; 4450	
; 4451	FRESULT f_closedir (
; 4452		DIR *dp		/* Pointer to the directory object to be closed */
; 4453	)
; 4454	{
_f_closedir:
.DEFINE "_f_closedir"

.VALUE _f_closedir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_closedir",4454,"_f_closedir"

.LINE 4454

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 4455		FRESULT res;
; 4456		FATFS *fs;
; 4457	
; 4458	
; 4459		res = validate(&dp->obj, &fs);	/* Check validity of the file object */
.LINE 4459

	PEA	IX+%FFFFFFFA
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4460		if (res == FR_OK) {
.LINE 4460

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1048
; 4461	#if FF_FS_LOCK != 0
; 4462			if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
; 4463			if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
; 4464	#else
; 4465			dp->obj.fs = 0;	/* Invalidate directory object */
.LINE 4465

	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 4466	#endif
; 4467	#if FF_FS_REENTRANT
; 4468			unlock_fs(fs, FR_OK);		/* Unlock volume */
; 4469	#endif
; 4470		}
L_1048:
.LINE 4470

; 4471		return res;
.LINE 4471

	LD	HL,(IX+%FFFFFFFD)
; 4472	}
.LINE 4472

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_closedir ***************************
;Name                         Addr/Register   Size   Type
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;dp                                    IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_closedir",4472,"_f_closedir"
; 4473	
; 4474	
; 4475	
; 4476	
; 4477	/*-----------------------------------------------------------------------*/
; 4478	/* Read Directory Entries in Sequence                                    */
; 4479	/*-----------------------------------------------------------------------*/
; 4480	
; 4481	FRESULT f_readdir (
; 4482		DIR* dp,			/* Pointer to the open directory object */
; 4483		FILINFO* fno		/* Pointer to file information to return */
; 4484	)
; 4485	{
_f_readdir:
.DEFINE "_f_readdir"

.VALUE _f_readdir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_readdir",4485,"_f_readdir"

.LINE 4485

.DEFINE "dp"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "fno"

.CLASS 65

.VALUE 9

.TAG "NONAME4"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 4486		FRESULT res;
; 4487		FATFS *fs;
; 4488		DEF_NAMBUF
; 4489	
; 4490	
; 4491		res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
.LINE 4491

	PEA	IX+%FFFFFFFA
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4492		if (res == FR_OK) {
.LINE 4492

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1058
; 4493			if (!fno) {
.LINE 4493

	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1056
; 4494				res = dir_sdi(dp, 0);			/* Rewind the directory object */
.LINE 4494

	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4495			} else {
.LINE 4495

	JR	L_1058
L_1056:
; 4496				INIT_NAMBUF(fs);
; 4497				res = dir_read_file(dp);		/* Read an item */
.LINE 4497

	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_read
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4498				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
.LINE 4498

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1053
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
L_1053:
; 4499				if (res == FR_OK) {				/* A valid entry is found */
.LINE 4499

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1054
; 4500					get_fileinfo(dp, fno);		/* Get the object information */
.LINE 4500

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_fileinfo
	POP	BC
	POP	BC
; 4501					res = dir_next(dp, 0);		/* Increment index for next */
.LINE 4501

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_dir_next
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4502					if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
.LINE 4502

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1054
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4503				}
L_1054:
.LINE 4503

; 4504				FREE_NAMBUF();
; 4505			}
; 4506		}
L_1058:
.LINE 4506

; 4507		LEAVE_FF(fs, res);
.LINE 4507

	LD	HL,(IX+%FFFFFFFD)
; 4508	}
.LINE 4508

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_readdir ***************************
;Name                         Addr/Register   Size   Type
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;fno                                   IX+9      3   parameter
;dp                                    IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_readdir",4508,"_f_readdir"
; 4509	
; 4510	
; 4511	
; 4512	#if FF_USE_FIND
; 4513	/*-----------------------------------------------------------------------*/
; 4514	/* Find Next File                                                        */
; 4515	/*-----------------------------------------------------------------------*/
; 4516	
; 4517	FRESULT f_findnext (
; 4518		DIR* dp,		/* Pointer to the open directory object */
; 4519		FILINFO* fno	/* Pointer to the file information structure */
; 4520	)
; 4521	{
; 4522		FRESULT res;
; 4523	
; 4524	
; 4525		while (1) {
; 4526			res = f_readdir(dp, fno);		/* Get a directory item */
; 4527			if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
; 4528			if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
; 4529	#if FF_USE_LFN && FF_USE_FIND == 2
; 4530			if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
; 4531	#endif
; 4532		}
; 4533		return res;
; 4534	}
; 4535	
; 4536	
; 4537	
; 4538	/*-----------------------------------------------------------------------*/
; 4539	/* Find First File                                                       */
; 4540	/*-----------------------------------------------------------------------*/
; 4541	
; 4542	FRESULT f_findfirst (
; 4543		DIR* dp,				/* Pointer to the blank directory object */
; 4544		FILINFO* fno,			/* Pointer to the file information structure */
; 4545		const TCHAR* path,		/* Pointer to the directory to open */
; 4546		const TCHAR* pattern	/* Pointer to the matching pattern */
; 4547	)
; 4548	{
; 4549		FRESULT res;
; 4550	
; 4551	
; 4552		dp->pat = pattern;		/* Save pointer to pattern string */
; 4553		res = f_opendir(dp, path);		/* Open the target directory */
; 4554		if (res == FR_OK) {
; 4555			res = f_findnext(dp, fno);	/* Find the first item */
; 4556		}
; 4557		return res;
; 4558	}
; 4559	
; 4560	#endif	/* FF_USE_FIND */
; 4561	
; 4562	
; 4563	
; 4564	#if FF_FS_MINIMIZE == 0
; 4565	/*-----------------------------------------------------------------------*/
; 4566	/* Get File Status                                                       */
; 4567	/*-----------------------------------------------------------------------*/
; 4568	
; 4569	FRESULT f_stat (
; 4570		const TCHAR* path,	/* Pointer to the file path */
; 4571		FILINFO* fno		/* Pointer to file information to return */
; 4572	)
; 4573	{
_f_stat:
.DEFINE "_f_stat"

.VALUE _f_stat

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_stat",4573,"_f_stat"

.LINE 4573

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "fno"

.CLASS 65

.VALUE 9

.TAG "NONAME4"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -49

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFCF
	LD	SP,HL
; 4574		FRESULT res;
; 4575		DIR dj;
; 4576		DEF_NAMBUF
; 4577	
; 4578	
; 4579		/* Get logical drive */
; 4580		res = find_volume(&path, &dj.obj.fs, 0);
.LINE 4580

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFCF
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4581		if (res == FR_OK) {
.LINE 4581

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1066
; 4582			INIT_NAMBUF(dj.obj.fs);
; 4583			res = follow_path(&dj, path);	/* Follow the file path */
.LINE 4583

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFFCF
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4584			if (res == FR_OK) {				/* Follow completed */
.LINE 4584

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1064
; 4585				if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
.LINE 4585

	LEA	IY,IX+%FFFFFFED
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_1062
; 4586					res = FR_INVALID_NAME;
.LINE 4586

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 4587				} else {							/* Found an object */
.LINE 4587

	JR	L_1064
L_1062:
; 4588					if (fno) get_fileinfo(&dj, fno);
.LINE 4588

	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_1064
	LD	BC,(IX+%9)
	PUSH	BC
	PEA	IX+%FFFFFFCF
	CALL	_get_fileinfo
	POP	BC
	POP	BC
; 4589				}
; 4590			}
L_1064:
.LINE 4590

; 4591			FREE_NAMBUF();
; 4592		}
L_1066:
.LINE 4592

; 4593	
; 4594		LEAVE_FF(dj.obj.fs, res);
.LINE 4594

	LD	HL,(IX+%FFFFFFFD)
; 4595	}
.LINE 4595

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_stat ***************************
;Name                         Addr/Register   Size   Type
;dj                                   IX-49     46   variable
;res                                   IX-3      3   variable
;fno                                   IX+9      3   parameter
;path                                  IX+6      3   parameter


; Stack Frame Size: 61 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_stat",4595,"_f_stat"
; 4596	
; 4597	
; 4598	
; 4599	#if !FF_FS_READONLY
; 4600	/*-----------------------------------------------------------------------*/
; 4601	/* Get Number of Free Clusters                                           */
; 4602	/*-----------------------------------------------------------------------*/
; 4603	
; 4604	FRESULT f_getfree (
; 4605		const TCHAR* path,	/* Logical drive number */
; 4606		DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
; 4607		FATFS** fatfs		/* Pointer to return pointer to corresponding filesystem object */
; 4608	)
; 4609	{
_f_getfree:
.DEFINE "_f_getfree"

.VALUE _f_getfree

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_getfree",4609,"_f_getfree"

.LINE 4609

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "nclst"

.CLASS 65

.VALUE 9

.TYPE 47

.ENDEF

.DEFINE "fatfs"

.CLASS 65

.VALUE 12

.TAG "NONAME0"

.TYPE 296

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -3

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "nfree"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -10

.TYPE 14

.ENDEF

.DEFINE "clst"

.CLASS 65

.VALUE -14

.TYPE 15

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -17

.TYPE 4

.ENDEF

.DEFINE "stat"

.CLASS 65

.VALUE -21

.TYPE 15

.ENDEF

.DEFINE "sect"

.CLASS 65

.VALUE -25

.TYPE 15

.ENDEF

.DEFINE "obj"

.CLASS 65

.VALUE -40

.TAG "NONAME1"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD2
	LD	SP,HL
; 4610		FRESULT res;
; 4611		FATFS *fs;
; 4612		DWORD nfree, clst, sect, stat;
; 4613		UINT i;
; 4614		FFOBJID obj;
; 4615	
; 4616	
; 4617		/* Get logical drive */
; 4618		res = find_volume(&path, &fs, 0);
.LINE 4618

	LD	BC,0
	PUSH	BC
	PEA	IX+%FFFFFFFD
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEF),HL
; 4619		if (res == FR_OK) {
.LINE 4619

	LD	BC,0
	LD	HL,(IX+%FFFFFFEF)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1097
; 4620			*fatfs = fs;				/* Return ptr to the fs object */
.LINE 4620

	LD	HL,(IX+%C)
	LD	BC,(IX+%FFFFFFFD)
	LD	(HL),BC
; 4621			/* If free_clst is valid, return it without full FAT scan */
; 4622			if (fs->free_clst <= fs->n_fatent - 2) {
.LINE 4622

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1A)
	LD	E,(IY+%1D)
	LD	BC,2
	XOR	A,A
	CALL	__lsub
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	CALL	__lcmpu
	JR	C,L_1095
; 4623				*nclst = fs->free_clst;
.LINE 4623

	LD	HL,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%12)
	LD	A,(IY+%15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 4624			} else {
.LINE 4624

	JR	L_1097
L_1095:
; 4625				/* Scan FAT to obtain number of free clusters */
; 4626				nfree = 0;
.LINE 4626

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF9),BC
	LD	(IX+%FFFFFFFC),A
; 4627				if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
.LINE 4627

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	CP	A,%1
	JR	NZ,L_1092
; 4628					clst = 2; obj.fs = fs;
.LINE 4628

	LD	BC,2
	XOR	A,A
	LD	(IX+%FFFFFFF2),BC
	LD	(IX+%FFFFFFF5),A
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFD8),BC
; 4629					do {
L_1074:
.LINE 4629

; 4630						stat = get_fat(&obj, clst);
.LINE 4630

	LD	C,(IX+%FFFFFFF5)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	PEA	IX+%FFFFFFD8
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEB),HL
	LD	(IX+%FFFFFFEE),E
; 4631						if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
.LINE 4631

	LD	HL,(IX+%FFFFFFEB)
	LD	E,(IX+%FFFFFFEE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_1070
	LD	BC,1
	LD	(IX+%FFFFFFEF),BC
	JR	L_1093
L_1070:
; 4632						if (stat == 1) { res = FR_INT_ERR; break; }
.LINE 4632

	LD	HL,(IX+%FFFFFFEB)
	LD	E,(IX+%FFFFFFEE)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1073
	LD	BC,2
	LD	(IX+%FFFFFFEF),BC
	JR	L_1093
L_1073:
; 4633						if (stat == 0) nfree++;
.LINE 4633

	LD	HL,(IX+%FFFFFFEB)
	LD	E,(IX+%FFFFFFEE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1075
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
; 4634					} while (++clst < fs->n_fatent);
L_1075:
.LINE 4634

	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF2),HL
	LD	(IX+%FFFFFFF5),E
	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	C,L_1074
	JR	L_1093
; 4635				} else {
L_1092:
.LINE 4635

; 4636	#if FF_FS_EXFAT
; 4637					if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan allocation bitmap */
; 4638						BYTE bm;
; 4639						UINT b;
; 4640	
; 4641						clst = fs->n_fatent - 2;	/* Number of clusters */
; 4642						sect = fs->database;		/* Assuming bitmap starts at cluster 2 */
; 4643						i = 0;						/* Offset in the sector */
; 4644						do {	/* Counts numbuer of bits with zero in the bitmap */
; 4645							if (i == 0) {
; 4646								res = move_window(fs, sect++);
; 4647								if (res != FR_OK) break;
; 4648							}
; 4649							for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
; 4650								if (!(bm & 1)) nfree++;
; 4651								bm >>= 1;
; 4652							}
; 4653							i = (i + 1) % SS(fs);
; 4654						} while (clst);
; 4655					} else
; 4656	#endif
; 4657					{	/* FAT16/32: Scan WORD/DWORD FAT entries */
; 4658						clst = fs->n_fatent;	/* Number of entries */
.LINE 4658

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	LD	(IX+%FFFFFFF2),BC
	LD	(IX+%FFFFFFF5),A
; 4659						sect = fs->fatbase;		/* Top of the FAT */
.LINE 4659

	LD	BC,(IY+%26)
	LD	A,(IY+%29)
	LD	(IX+%FFFFFFE7),BC
	LD	(IX+%FFFFFFEA),A
; 4660						i = 0;					/* Offset in the sector */
.LINE 4660

	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
; 4661						do {	/* Counts numbuer of entries with zero in the FAT */
L_1089:
.LINE 4661

; 4662							if (i == 0) {
.LINE 4662

	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1087
; 4663								res = move_window(fs, sect++);
.LINE 4663

	LD	HL,(IX+%FFFFFFE7)
	LD	(IX+%FFFFFFD2),HL	; spill
	LD	C,(IX+%FFFFFFEA)
	LD	HL,(IX+%FFFFFFE7)
	LD	E,(IX+%FFFFFFEA)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFE7),HL
	LD	(IX+%FFFFFFEA),E
	LD	B,%0
	PUSH	BC
	LD	HL,(IX+%FFFFFFD2)	; unspill
	PUSH	HL
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEF),HL
; 4664								if (res != FR_OK) break;
.LINE 4664

	LD	BC,0
	LD	HL,(IX+%FFFFFFEF)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1093
; 4665							}
L_1087:
.LINE 4665

; 4666							if (fs->fs_type == FS_FAT16) {
.LINE 4666

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%0)
	CP	A,%2
	JR	NZ,L_1086
; 4667								if (ld_word(fs->win + i) == 0) nfree++;
.LINE 4667

	LD	BC,(IX+%FFFFFFF6)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_word
	POP	BC
	LD.LIS	BC,0
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_1081
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
L_1081:
; 4668								i += 2;
.LINE 4668

	LD	IY,(IX+%FFFFFFF6)
	LEA	IY,IY+%2
	LD	(IX+%FFFFFFF6),IY
; 4669							} else {
.LINE 4669

	JR	L_1088
L_1086:
; 4670								if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
.LINE 4670

	LD	BC,(IX+%FFFFFFF6)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%36
	ADD	HL,BC
	PUSH	HL
	CALL	_ld_dword
	POP	BC
	LD	BC,16777215
	LD	A,%F
	CALL	__land
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1084
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
L_1084:
; 4671								i += 4;
.LINE 4671

	LD	IY,(IX+%FFFFFFF6)
	LEA	IY,IY+%4
	LD	(IX+%FFFFFFF6),IY
; 4672							}
L_1088:
.LINE 4672

; 4673							i %= SS(fs);
.LINE 4673

	LD	BC,511
	LD	HL,(IX+%FFFFFFF6)
	CALL	__iand
	LD	(IX+%FFFFFFF6),HL
; 4674						} while (--clst);
.LINE 4674

	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF2),HL
	LD	(IX+%FFFFFFF5),E
	LD	HL,(IX+%FFFFFFF2)
	LD	E,(IX+%FFFFFFF5)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1089
; 4675					}
; 4676				}
L_1093:
.LINE 4676

; 4677				*nclst = nfree;			/* Return the free clusters */
.LINE 4677

	LD	HL,(IX+%9)
	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 4678				fs->free_clst = nfree;	/* Now free_clst is valid */
.LINE 4678

	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%12),BC
	LD	(IY+%15),A
; 4679				fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
.LINE 4679

	LD	A,(IY+%4)
	SET	%0,A
	LD	(IY+%4),A
; 4680			}
; 4681		}
L_1097:
.LINE 4681

; 4682	
; 4683		LEAVE_FF(fs, res);
.LINE 4683

	LD	HL,(IX+%FFFFFFEF)
; 4684	}
.LINE 4684

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_getfree ***************************
;Name                         Addr/Register   Size   Type
;obj                                  IX-40     15   variable
;sect                                 IX-25      4   variable
;stat                                 IX-21      4   variable
;res                                  IX-17      3   variable
;clst                                 IX-14      4   variable
;i                                    IX-10      3   variable
;nfree                                 IX-7      4   variable
;fs                                    IX-3      3   variable
;fatfs                                IX+12      3   parameter
;nclst                                 IX+9      3   parameter
;path                                  IX+6      3   parameter


; Stack Frame Size: 61 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_getfree",4684,"_f_getfree"
; 4685	
; 4686	
; 4687	
; 4688	
; 4689	/*-----------------------------------------------------------------------*/
; 4690	/* Truncate File                                                         */
; 4691	/*-----------------------------------------------------------------------*/
; 4692	
; 4693	FRESULT f_truncate (
; 4694		FIL* fp		/* Pointer to the file object */
; 4695	)
; 4696	{
_f_truncate:
.DEFINE "_f_truncate"

.VALUE _f_truncate

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_truncate",4696,"_f_truncate"

.LINE 4696

.DEFINE "fp"

.CLASS 65

.VALUE 6

.TAG "NONAME2"

.TYPE 40

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "ncl"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -14

.TAG "NONAME0"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEF
	LD	SP,HL
; 4697		FRESULT res;
; 4698		FATFS *fs;
; 4699		DWORD ncl;
; 4700	
; 4701	
; 4702		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
.LINE 4702

	PEA	IX+%FFFFFFF2
	LD	IY,(IX+%6)
	PEA	IY+%0
	CALL	_validate
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4703		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
.LINE 4703

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1100
	LD	IY,(IX+%6)
	LD	A,(IY+%10)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFFD),HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_1102
L_1100:
	LD	HL,(IX+%FFFFFFFD)
	JR	L_1117
L_1102:
; 4704		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
.LINE 4704

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	AND	A,%2
	JR	NZ,L_1115
	LD	HL,7
	JR	L_1117
L_1115:
; 4705	
; 4706		if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
.LINE 4706

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IX+%FFFFFFF5),BC
	LD	(IX+%FFFFFFF8),A
	LD	HL,BC
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	CALL	__lcmpu
	JR	NC,L_1116
; 4707			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
.LINE 4707

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1110
; 4708				res = remove_chain(&fp->obj, fp->obj.sclust, 0);
.LINE 4708

	LD	IY,(IX+%6)
	LEA	BC,IY+%0
	LD	(IX+%FFFFFFEF),BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	IY,(IX+%FFFFFFEF)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	BC,(IX+%FFFFFFEF)
	PUSH	BC
	CALL	_remove_chain
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4709				fp->obj.sclust = 0;
.LINE 4709

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	(IY+%A),%0
; 4710			} else {				/* When truncate a part of the file, remove remaining clusters */
.LINE 4710

	JR	L_1111
L_1110:
; 4711				ncl = get_fat(&fp->obj, fp->clust);
.LINE 4711

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	PEA	IY+%0
	CALL	_get_fat
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
; 4712				res = FR_OK;
.LINE 4712

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4713				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
.LINE 4713

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_1105
	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
L_1105:
; 4714				if (ncl == 1) res = FR_INT_ERR;
.LINE 4714

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1108
	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
L_1108:
; 4715				if (res == FR_OK && ncl < fs->n_fatent) {
.LINE 4715

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1111
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	IY,(IX+%FFFFFFF2)
	LD	BC,(IY+%1A)
	LD	A,(IY+%1D)
	CALL	__lcmpu
	JR	NC,L_1111
; 4716					res = remove_chain(&fp->obj, ncl, fp->clust);
.LINE 4716

	LD	IY,(IX+%6)
	LD	BC,(IY+%15)
	LD	A,(IY+%18)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	PEA	IY+%0
	CALL	_remove_chain
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4717				}
; 4718			}
L_1111:
.LINE 4718

; 4719			fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
.LINE 4719

	LD	IY,(IX+%6)
	LD	BC,(IY+%11)
	LD	A,(IY+%14)
	LD	(IY+%B),BC
	LD	(IY+%E),A
; 4720			fp->flag |= FA_MODIFIED;
.LINE 4720

	LD	A,(IY+%F)
	SET	%6,A
	LD	(IY+%F),A
; 4721	#if !FF_FS_TINY
; 4722			if (res == FR_OK && (fp->flag & FA_DIRTY)) {
; 4723				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
; 4724					res = FR_DISK_ERR;
; 4725				} else {
; 4726					fp->flag &= (BYTE)~FA_DIRTY;
; 4727				}
; 4728			}
; 4729	#endif
; 4730			if (res != FR_OK) ABORT(fs, res);
.LINE 4730

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_1116
	LD	A,(IX+%FFFFFFFD)
	LD	IY,(IX+%6)
	LD	(IY+%10),A
	LD	HL,(IX+%FFFFFFFD)
	JR	L_1117
; 4731		}
L_1116:
.LINE 4731

; 4732	
; 4733		LEAVE_FF(fs, res);
.LINE 4733

	LD	HL,(IX+%FFFFFFFD)
; 4734	}
L_1117:
.LINE 4734

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_truncate ***************************
;Name                         Addr/Register   Size   Type
;fs                                   IX-14      3   variable
;G_76                                 IX-11      4   variable
;ncl                                   IX-7      4   variable
;res                                   IX-3      3   variable
;fp                                    IX+6      3   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_truncate",4734,"_f_truncate"
; 4735	
; 4736	
; 4737	
; 4738	
; 4739	/*-----------------------------------------------------------------------*/
; 4740	/* Delete a File/Directory                                               */
; 4741	/*-----------------------------------------------------------------------*/
; 4742	
; 4743	FRESULT f_unlink (
; 4744		const TCHAR* path		/* Pointer to the file or directory path */
; 4745	)
; 4746	{
_f_unlink:
.DEFINE "_f_unlink"

.VALUE _f_unlink

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_unlink",4746,"_f_unlink"

.LINE 4746

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dclst"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -56

.TAG "NONAME3"

.TYPE 8

.ENDEF

.DEFINE "sdj"

.CLASS 65

.VALUE -102

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFF97
	LD	SP,HL
; 4747		FRESULT res;
; 4748		DIR dj, sdj;
; 4749		DWORD dclst = 0;
.LINE 4749

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 4750		FATFS *fs;
; 4751	#if FF_FS_EXFAT
; 4752		FFOBJID obj;
; 4753	#endif
; 4754		DEF_NAMBUF
; 4755	
; 4756	
; 4757		/* Get logical drive */
; 4758		res = find_volume(&path, &fs, FA_WRITE);
.LINE 4758

	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4759		if (res == FR_OK) {
.LINE 4759

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1142
; 4760			dj.obj.fs = fs;
.LINE 4760

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFC8),BC
; 4761			INIT_NAMBUF(fs);
; 4762			res = follow_path(&dj, path);		/* Follow the file path */
.LINE 4762

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFFC8
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4763			if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
.LINE 4763

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1139
	LEA	IY,IX+%FFFFFFE6
	LD	A,(IY+%B)
	AND	A,%20
	JR	Z,L_1139
; 4764				res = FR_INVALID_NAME;			/* Cannot remove dot entry */
.LINE 4764

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 4765			}
L_1139:
.LINE 4765

; 4766	#if FF_FS_LOCK != 0
; 4767			if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
; 4768	#endif
; 4769			if (res == FR_OK) {					/* The object is accessible */
.LINE 4769

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1140
; 4770				if (dj.fn[NSFLAG] & NS_NONAME) {
.LINE 4770

	LEA	IY,IX+%FFFFFFE6
	LD	A,(IY+%B)
	AND	A,%80
	JR	Z,L_1122
; 4771					res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
.LINE 4771

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 4772				} else {
.LINE 4772

	JR	L_1131
L_1122:
; 4773					if (dj.obj.attr & AM_RDO) {
.LINE 4773

	LD	A,(IX+%FFFFFFCD)
	AND	A,%1
	JR	Z,L_1131
; 4774						res = FR_DENIED;		/* Cannot remove R/O object */
.LINE 4774

	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
; 4775					}
; 4776				}
L_1131:
.LINE 4776

; 4777				if (res == FR_OK) {
.LINE 4777

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1137
; 4778	#if FF_FS_EXFAT
; 4779					obj.fs = fs;
; 4780					if (fs->fs_type == FS_EXFAT) {
; 4781						init_alloc_info(fs, &obj);
; 4782						dclst = obj.sclust;
; 4783					} else
; 4784	#endif
; 4785					{
; 4786						dclst = ld_clust(fs, dj.dir);
.LINE 4786

	LD	BC,(IX+%FFFFFFE3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
; 4787					}
; 4788					if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
.LINE 4788

	LD	A,(IX+%FFFFFFCD)
	AND	A,%10
	JR	Z,L_1137
; 4789	#if FF_FS_RPATH != 0
; 4790						if (dclst == fs->cdir) {		 	/* Is it the current directory? */
.LINE 4790

	LD	IY,(IX+%FFFFFFFA)
	LD	HL,(IY+%16)
	LD	E,(IY+%19)
	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	CALL	__lcmpu
	JR	NZ,L_1128
; 4791							res = FR_DENIED;
.LINE 4791

	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
; 4792						} else
.LINE 4792

	JR	L_1137
L_1128:
; 4793	#endif
; 4794						{
; 4795							sdj.obj.fs = fs;				/* Open the sub-directory */
.LINE 4795

	LEA	BC,IX+%FFFFFF9A
	LD	(IX+%FFFFFF97),BC
	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFF9A),BC
; 4796							sdj.obj.sclust = dclst;
.LINE 4796

	LD	BC,(IX+%FFFFFFF6)
	LD	A,(IX+%FFFFFFF9)
	LD	IY,(IX+%FFFFFF97)
	LD	(IY+%7),BC
	LD	(IY+%A),A
; 4797	#if FF_FS_EXFAT
; 4798							if (fs->fs_type == FS_EXFAT) {
; 4799								sdj.obj.objsize = obj.objsize;
; 4800								sdj.obj.stat = obj.stat;
; 4801							}
; 4802	#endif
; 4803							res = dir_sdi(&sdj, 0);
.LINE 4803

	LD	BC,0
	PUSH	BC
	PUSH	BC
	PEA	IX+%FFFFFF9A
	CALL	_dir_sdi
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4804							if (res == FR_OK) {
.LINE 4804

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1137
; 4805								res = dir_read_file(&sdj);			/* Test if the directory is empty */
.LINE 4805

	PUSH	BC
	PEA	IX+%FFFFFF9A
	CALL	_dir_read
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4806								if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
.LINE 4806

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1125
	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
L_1125:
; 4807								if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
.LINE 4807

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1137
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4808							}
; 4809						}
; 4810					}
; 4811				}
L_1137:
.LINE 4811

; 4812				if (res == FR_OK) {
.LINE 4812

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1140
; 4813					res = dir_remove(&dj);			/* Remove the directory entry */
.LINE 4813

	PEA	IX+%FFFFFFC8
	CALL	_dir_remove
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4814					if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
.LINE 4814

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1135
	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_1135
; 4815	#if FF_FS_EXFAT
; 4816						res = remove_chain(&obj, dclst, 0);
; 4817	#else
; 4818						res = remove_chain(&dj.obj, dclst, 0);
.LINE 4818

	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFF9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	PEA	IX+%FFFFFFC8
	CALL	_remove_chain
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4819	#endif
; 4820					}
L_1135:
.LINE 4820

; 4821					if (res == FR_OK) res = sync_fs(fs);
.LINE 4821

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1140
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_sync_fs
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4822				}
; 4823			}
L_1140:
.LINE 4823

; 4824			FREE_NAMBUF();
; 4825		}
L_1142:
.LINE 4825

; 4826	
; 4827		LEAVE_FF(fs, res);
.LINE 4827

	LD	HL,(IX+%FFFFFFFD)
; 4828	}
.LINE 4828

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_unlink ***************************
;Name                         Addr/Register   Size   Type
;sdj                                 IX-102     46   variable
;dj                                   IX-56     46   variable
;dclst                                IX-10      4   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 114 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_unlink",4828,"_f_unlink"
; 4829	
; 4830	
; 4831	
; 4832	
; 4833	/*-----------------------------------------------------------------------*/
; 4834	/* Create a Directory                                                    */
; 4835	/*-----------------------------------------------------------------------*/
; 4836	
; 4837	FRESULT f_mkdir (
; 4838		const TCHAR* path		/* Pointer to the directory path */
; 4839	)
; 4840	{
_f_mkdir:
.DEFINE "_f_mkdir"

.VALUE _f_mkdir

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_mkdir",4840,"_f_mkdir"

.LINE 4840

.DEFINE "path"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE -9

.TYPE 44

.ENDEF

.DEFINE "dcl"

.CLASS 65

.VALUE -13

.TYPE 15

.ENDEF

.DEFINE "tm"

.CLASS 65

.VALUE -20

.TYPE 15

.ENDEF

.DEFINE "pcl"

.CLASS 65

.VALUE -24

.TYPE 15

.ENDEF

.DEFINE "dj"

.CLASS 65

.VALUE -70

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFBA
	LD	SP,HL
; 4841		FRESULT res;
; 4842		DIR dj;
; 4843		FATFS *fs;
; 4844		BYTE *dir;
; 4845		DWORD dcl, pcl, tm;
; 4846		DEF_NAMBUF
; 4847	
; 4848	
; 4849		/* Get logical drive */
; 4850		res = find_volume(&path, &fs, FA_WRITE);
.LINE 4850

	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4851		if (res == FR_OK) {
.LINE 4851

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1169
; 4852			dj.obj.fs = fs;
.LINE 4852

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFBA),BC
; 4853			INIT_NAMBUF(fs);
; 4854			res = follow_path(&dj, path);			/* Follow the file path */
.LINE 4854

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFFBA
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4855			if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
.LINE 4855

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1147
	LD	BC,8
	LD	(IX+%FFFFFFFD),BC
L_1147:
; 4856			if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
.LINE 4856

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1166
	LEA	IY,IX+%FFFFFFD8
	LD	A,(IY+%B)
	AND	A,%20
	JR	Z,L_1166
; 4857				res = FR_INVALID_NAME;
.LINE 4857

	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
; 4858			}
L_1166:
.LINE 4858

; 4859			if (res == FR_NO_FILE) {				/* Can create a new directory */
.LINE 4859

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1167
; 4860				dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
.LINE 4860

	LEA	BC,IX+%FFFFFFBA
	LD	(IX+%FFFFFFF0),BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_create_chain
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
; 4861				dj.obj.objsize = (DWORD)fs->csize * SS(fs);
.LINE 4861

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%9)
	CALL	__stoiu
	LD	E,%0
	LD	BC,512
	XOR	A,A
	CALL	__lmulu
	LD	IY,(IX+%FFFFFFF0)
	LD	(IY+%B),HL
	LD	(IY+%E),E
; 4862				res = FR_OK;
.LINE 4862

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4863				if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
.LINE 4863

	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1150
	LD	BC,7
	LD	(IX+%FFFFFFFD),BC
L_1150:
; 4864				if (dcl == 1) res = FR_INT_ERR;
.LINE 4864

	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	LD	BC,1
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1152
	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
L_1152:
; 4865				if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
.LINE 4865

	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_1154
	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
L_1154:
; 4866				if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
.LINE 4866

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1155
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_sync_window
	POP	BC
	LD	(IX+%FFFFFFFD),HL
L_1155:
; 4867				tm = GET_FATTIME();
.LINE 4867

	CALL	_get_fattime
	LD	(IX+%FFFFFFEC),HL
	LD	(IX+%FFFFFFEF),E
; 4868				if (res == FR_OK) {					/* Initialize the new directory table */
.LINE 4868

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1160
; 4869					res = dir_clear(fs, dcl);		/* Clean up the new table */
.LINE 4869

	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_dir_clear
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4870					if (res == FR_OK && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)) {	/* Create dot entries (FAT only) */
.LINE 4870

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1160
; 4871						dir = fs->win;
.LINE 4871

	LD	IY,(IX+%FFFFFFFA)
	LEA	BC,IY+%36
	LD	(IX+%FFFFFFF7),BC
; 4872						mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
.LINE 4872

	LD	BC,11
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PEA	IY+%36
	CALL	_mem_set
	POP	BC
	POP	BC
	POP	BC
; 4873						dir[DIR_Name] = '.';
.LINE 4873

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%36),%2E
; 4874						dir[DIR_Attr] = AM_DIR;
.LINE 4874

	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%B
	LD	(HL),%10
; 4875						st_dword(dir + DIR_ModTime, tm);
.LINE 4875

	LD	C,(IX+%FFFFFFEF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 4876						st_clust(fs, dir, dcl);
.LINE 4876

	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 4877						mem_cpy(dir + SZDIRE, dir, SZDIRE); /* Create ".." entry */
.LINE 4877

	LD	BC,32
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%20
	PUSH	BC
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 4878						dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
.LINE 4878

	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%21
	LD	(HL),%2E
	LD	IY,(IX+%FFFFFFF0)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	(IX+%FFFFFFE8),BC
	LD	(IX+%FFFFFFEB),A
; 4879						st_clust(fs, dir + SZDIRE, pcl);
.LINE 4879

	LD	C,(IX+%FFFFFFEB)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%20
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 4880						fs->wflag = 1;
.LINE 4880

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 4881					}
; 4882				}
L_1160:
.LINE 4882

; 4883				if (res == FR_OK) {
.LINE 4883

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1164
; 4884					res = dir_register(&dj);	/* Register the object to the directoy */
.LINE 4884

	PEA	IX+%FFFFFFBA
	CALL	_dir_register
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4885				}
L_1164:
.LINE 4885

; 4886				if (res == FR_OK) {
.LINE 4886

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1163
; 4887	#if FF_FS_EXFAT
; 4888					if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
; 4889						st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
; 4890						st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
; 4891						st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
; 4892						st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
; 4893						fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
; 4894						fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
; 4895						res = store_xdir(&dj);
; 4896					} else
; 4897	#endif
; 4898					{
; 4899						dir = dj.dir;
.LINE 4899

	LD	BC,(IX+%FFFFFFD5)
	LD	(IX+%FFFFFFF7),BC
; 4900						st_dword(dir + DIR_ModTime, tm);	/* Created time */
.LINE 4900

	LD	C,(IX+%FFFFFFEF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%16
	PUSH	BC
	CALL	_st_dword
	POP	BC
	POP	BC
	POP	BC
; 4901						st_clust(fs, dir, dcl);				/* Table start cluster */
.LINE 4901

	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 4902						dir[DIR_Attr] = AM_DIR;				/* Attribute */
.LINE 4902

	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%B
	LD	(HL),%10
; 4903						fs->wflag = 1;
.LINE 4903

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 4904					}
; 4905					if (res == FR_OK) {
.LINE 4905

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1167
; 4906						res = sync_fs(fs);
.LINE 4906

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_sync_fs
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4907					}
; 4908				} else {
.LINE 4908

	JR	L_1167
L_1163:
; 4909					remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
.LINE 4909

	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFF6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	PEA	IX+%FFFFFFBA
	CALL	_remove_chain
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 4910				}
; 4911			}
L_1167:
.LINE 4911

; 4912			FREE_NAMBUF();
; 4913		}
L_1169:
.LINE 4913

; 4914	
; 4915		LEAVE_FF(fs, res);
.LINE 4915

	LD	HL,(IX+%FFFFFFFD)
; 4916	}
.LINE 4916

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_mkdir ***************************
;Name                         Addr/Register   Size   Type
;_get_fattime                        IMPORT  -----   function
;dj                                   IX-70     46   variable
;pcl                                  IX-24      4   variable
;tm                                   IX-20      4   variable
;G_80                                 IX-16      3   variable
;dcl                                  IX-13      4   variable
;dir                                   IX-9      3   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path                                  IX+6      3   parameter


; Stack Frame Size: 79 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_mkdir",4916,"_f_mkdir"
; 4917	
; 4918	
; 4919	
; 4920	
; 4921	/*-----------------------------------------------------------------------*/
; 4922	/* Rename a File/Directory                                               */
; 4923	/*-----------------------------------------------------------------------*/
; 4924	
; 4925	FRESULT f_rename (
; 4926		const TCHAR* path_old,	/* Pointer to the object name to be renamed */
; 4927		const TCHAR* path_new	/* Pointer to the new name */
; 4928	)
; 4929	{
_f_rename:
.DEFINE "_f_rename"

.VALUE _f_rename

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "f_rename",4929,"_f_rename"

.LINE 4929

.DEFINE "path_old"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "path_new"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "res"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "fs"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "dir"

.CLASS 65

.VALUE -9

.TYPE 44

.ENDEF

.DEFINE "dw"

.CLASS 65

.VALUE -19

.TYPE 15

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE -51

.DIM 32

.TYPE 108

.ENDEF

.DEFINE "djo"

.CLASS 65

.VALUE -97

.TAG "NONAME3"

.TYPE 8

.ENDEF

.DEFINE "djn"

.CLASS 65

.VALUE -143

.TAG "NONAME3"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-146
	ADD	HL,SP
	LD	SP,HL
; 4930		FRESULT res;
; 4931		DIR djo, djn;
; 4932		FATFS *fs;
; 4933		BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
; 4934		DWORD dw;
; 4935		DEF_NAMBUF
; 4936	
; 4937	
; 4938		get_ldnumber(&path_new);						/* Snip the drive number of new name off */
.LINE 4938

	PEA	IX+%9
	CALL	_get_ldnumber
	POP	BC
; 4939		res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
.LINE 4939

	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFA
	PEA	IX+%6
	CALL	_find_volume
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4940		if (res == FR_OK) {
.LINE 4940

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1197
; 4941			djo.obj.fs = fs;
.LINE 4941

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFF9F),BC
; 4942			INIT_NAMBUF(fs);
; 4943			res = follow_path(&djo, path_old);		/* Check old object */
.LINE 4943

	LD	BC,(IX+%6)
	PUSH	BC
	PEA	IX+%FFFFFF9F
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4944			if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
.LINE 4944

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1194
	LEA	IY,IX+%FFFFFFBD
	LD	A,(IY+%B)
	AND	A,%A0
	JR	Z,L_1194
	LD	BC,6
	LD	(IX+%FFFFFFFD),BC
L_1194:
; 4945	#if FF_FS_LOCK != 0
; 4946			if (res == FR_OK) {
; 4947				res = chk_lock(&djo, 2);
; 4948			}
; 4949	#endif
; 4950			if (res == FR_OK) {						/* Object to be renamed is found */
.LINE 4950

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1195
; 4951	#if FF_FS_EXFAT
; 4952				if (fs->fs_type == FS_EXFAT) {	/* At exFAT volume */
; 4953					BYTE nf, nn;
; 4954					WORD nh;
; 4955	
; 4956					mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
; 4957					mem_cpy(&djn, &djo, sizeof djo);
; 4958					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
; 4959					if (res == FR_OK) {						/* Is new name already in use by any other object? */
; 4960						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
; 4961					}
; 4962					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
; 4963						res = dir_register(&djn);			/* Register the new entry */
; 4964						if (res == FR_OK) {
; 4965							nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
; 4966							nh = ld_word(fs->dirbuf + XDIR_NameHash);
; 4967							mem_cpy(fs->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry */
; 4968							fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
; 4969							st_word(fs->dirbuf + XDIR_NameHash, nh);
; 4970							if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
; 4971	/* Start of critical section where an interruption can cause a cross-link */
; 4972							res = store_xdir(&djn);
; 4973						}
; 4974					}
; 4975				} else
; 4976	#endif
; 4977				{	/* At FAT/FAT32 volume */
; 4978					mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
.LINE 4978

	LD	BC,32
	PUSH	BC
	LD	BC,(IX+%FFFFFFBA)
	PUSH	BC
	PEA	IX+%FFFFFFCD
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 4979					mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
.LINE 4979

	LD	BC,46
	PUSH	BC
	PEA	IX+%FFFFFF9F
	LD	HL,IX
	LD	BC,-143
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 4980					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
.LINE 4980

	LD	BC,(IX+%9)
	PUSH	BC
	LD	HL,IX
	LD	BC,-143
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_follow_path
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4981					if (res == FR_OK) {						/* Is new name already in use by any other object? */
.LINE 4981

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1189
; 4982						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
.LINE 4982

	LD	IY,-136
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,(IX+%FFFFFFA6)
	LD	A,(IX+%FFFFFFA9)
	CALL	__lcmpu
	JR	NZ,L_1176
	LD	HL,(IX+%FFFFFF80)
	LD	E,(IX+%FFFFFF83)
	LD	BC,(IX+%FFFFFFAE)
	LD	A,(IX+%FFFFFFB1)
	CALL	__lcmpu
	JR	NZ,L_1176
	LD	BC,4
	LD	(IX+%FFFFFFF4),BC
	JR	L_1177
L_1176:
	LD	BC,8
	LD	(IX+%FFFFFFF4),BC
L_1177:
	LD	BC,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFFD),BC
; 4983					}
L_1189:
.LINE 4983

; 4984					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
.LINE 4984

	LD	BC,4
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1192
; 4985						res = dir_register(&djn);			/* Register the new entry */
.LINE 4985

	LD	HL,IX
	LD	BC,-143
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_dir_register
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4986						if (res == FR_OK) {
.LINE 4986

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1192
; 4987							dir = djn.dir;					/* Copy directory entry of the object except name */
.LINE 4987

	LD	BC,(IX+%FFFFFF8C)
	LD	(IX+%FFFFFFF7),BC
; 4988							mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
.LINE 4988

	LD	BC,19
	PUSH	BC
	LEA	BC,IX+%FFFFFFDA
	PUSH	BC
	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%D
	PUSH	BC
	CALL	_mem_cpy
	POP	BC
	POP	BC
	POP	BC
; 4989							dir[DIR_Attr] = buf[DIR_Attr];
.LINE 4989

	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%B
	LD	HL,-146
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),BC
	LEA	IY,IX+%FFFFFFCD
	LD	HL,-146
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(IY+%B)
	LD	(HL),A
; 4990							if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
.LINE 4990

	LD	HL,-146
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(HL)
	AND	A,%10
	JR	NZ,L_1180
	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%B
	LD	A,(HL)
	SET	%5,A
	LEA	HL,IY+%B
	LD	(HL),A
L_1180:
; 4991							fs->wflag = 1;
.LINE 4991

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 4992							if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
.LINE 4992

	LD	IY,(IX+%FFFFFFF7)
	LD	A,(IY+%B)
	AND	A,%10
	JR	Z,L_1192
	LD	HL,IX
	LD	BC,-143
	ADD	HL,BC
	LD	(IX+%FFFFFFF1),HL
	LD	HL,(IX+%FFFFFFA6)
	LD	E,(IX+%FFFFFFA9)
	LD	IY,(IX+%FFFFFFF1)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	CALL	__lcmpu
	JR	Z,L_1192
; 4993								dw = clst2sect(fs, ld_clust(fs, dir));
.LINE 4993

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_ld_clust
	POP	BC
	POP	BC
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_clst2sect
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFED),HL
	LD	(IX+%FFFFFFF0),E
; 4994								if (dw == 0) {
.LINE 4994

	LD	HL,(IX+%FFFFFFED)
	LD	E,(IX+%FFFFFFF0)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_1185
; 4995									res = FR_INT_ERR;
.LINE 4995

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 4996								} else {
.LINE 4996

	JR	L_1192
L_1185:
; 4997	/* Start of critical section where an interruption can cause a cross-link */
; 4998									res = move_window(fs, dw);
.LINE 4998

	LD	C,(IX+%FFFFFFF0)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_move_window
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 4999									dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
.LINE 4999

	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%56
	LD	(IX+%FFFFFFF7),IY
; 5000									if (res == FR_OK && dir[1] == '.') {
.LINE 5000

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1192
	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%57
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1192
; 5001										st_clust(fs, dir, djn.obj.sclust);
.LINE 5001

	LD	IY,(IX+%FFFFFFF1)
	LD	BC,(IY+%7)
	LD	A,(IY+%A)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	LD	IY,(IX+%FFFFFFFA)
	LEA	BC,IY+%56
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_st_clust
	POP	BC
	POP	BC
	POP	BC
	POP	BC
; 5002										fs->wflag = 1;
.LINE 5002

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),%1
; 5003									}
; 5004								}
; 5005							}
; 5006						}
; 5007					}
; 5008				}
L_1192:
.LINE 5008

; 5009				if (res == FR_OK) {
.LINE 5009

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1195
; 5010					res = dir_remove(&djo);		/* Remove old entry */
.LINE 5010

	PEA	IX+%FFFFFF9F
	CALL	_dir_remove
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 5011					if (res == FR_OK) {
.LINE 5011

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_1195
; 5012						res = sync_fs(fs);
.LINE 5012

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_sync_fs
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 5013					}
; 5014				}
; 5015	/* End of the critical section */
; 5016			}
L_1195:
.LINE 5016

; 5017			FREE_NAMBUF();
; 5018		}
L_1197:
.LINE 5018

; 5019	
; 5020		LEAVE_FF(fs, res);
.LINE 5020

	LD	HL,(IX+%FFFFFFFD)
; 5021	}
.LINE 5021

	LD	SP,IX
	POP	IX
	RET	


;**************************** _f_rename ***************************
;Name                         Addr/Register   Size   Type
;djn                                 IX-143     46   variable
;djo                                  IX-97     46   variable
;buf                                  IX-51     32   variable
;dw                                   IX-19      4   variable
;G_81                                 IX-15      3   variable
;temp1174                             IX-12      3   variable
;dir                                   IX-9      3   variable
;fs                                    IX-6      3   variable
;res                                   IX-3      3   variable
;path_new                              IX+9      3   parameter
;path_old                              IX+6      3   parameter


; Stack Frame Size: 158 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "f_rename",5021,"_f_rename"
	XREF _disk_ioctl:ROM
	XREF _disk_write:ROM
	XREF _disk_read:ROM
	XREF _disk_status:ROM
	XREF _disk_initialize:ROM
	XREF _ff_wtoupper:ROM
	XREF _ff_uni2oem:ROM
	XREF _ff_oem2uni:ROM
	XREF _get_fattime:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __idivu:ROM
	XREF __ldivu:ROM
	XREF __lmulu:ROM
	XREF __lnot:ROM
	XREF __sor:ROM
	XREF __ior:ROM
	XREF __lor:ROM
	XREF __sand:ROM
	XREF __iand:ROM
	XREF __land:ROM
	XREF __bshl:ROM
	XREF __lshl:ROM
	XREF __lxor:ROM
	XREF __lshru:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XREF __ishl_b:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _f_rename
	XDEF _f_mkdir
	XDEF _f_unlink
	XDEF _f_truncate
	XDEF _f_getfree
	XDEF _f_stat
	XDEF _f_readdir
	XDEF _f_closedir
	XDEF _f_opendir
	XDEF _f_lseek
	XDEF _f_chdir
	XDEF _f_chdrive
	XDEF _f_close
	XDEF _f_sync
	XDEF _f_write
	XDEF _f_read
	XDEF _f_open
	XDEF _f_mount
	END
