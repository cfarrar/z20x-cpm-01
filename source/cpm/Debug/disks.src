; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\disks.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
	SEGMENT BSS
_disk_:
	DS	1
.DEFINE "disk_"
.ALIAS "_disk_"
.CLASS 83
.VALUE _disk_
.TYPE 12
.ENDEF
_track_:
	DS	2*1
.DEFINE "track_"
.ALIAS "_track_"
.CLASS 83
.VALUE _track_
.TYPE 13
.ENDEF
_sector_:
	DS	2*1
.DEFINE "sector_"
.ALIAS "_sector_"
.CLASS 83
.VALUE _sector_
.TYPE 13
.ENDEF
_dma_:
	DS	3
.DEFINE "dma_"
.ALIAS "_dma_"
.CLASS 83
.VALUE _dma_
.TYPE 44
.ENDEF
	SEGMENT DATA
_sectorMask_:
	DB	0
.DEFINE "sectorMask_"
.ALIAS "_sectorMask_"
.CLASS 69
.VALUE _sectorMask_
.TYPE 12
.ENDEF
_currentLba_:
	DL	-1
.DEFINE "currentLba_"
.ALIAS "_currentLba_"
.CLASS 69
.VALUE _currentLba_
.TYPE 15
.ENDEF
	SEGMENT BSS
_sectorBuffer_:
	DS	512
.DEFINE "sectorBuffer_"
.ALIAS "_sectorBuffer_"
.CLASS 83
.VALUE _sectorBuffer_
.DIM 512
.TYPE 108
.ENDEF
;    1	//----------------------------------------------------------------------------
;    2	// Copyright (c) 2019, by Christopher D. Farrar
;    3	//----------------------------------------------------------------------------
;    4	// I here grant permission to any and all to copy and use this software for
;    5	// any purpose as long as my copyright message is retained.
;    6	//----------------------------------------------------------------------------
;    7	#include <ctype.h>
;    8	#include <defines.h>
;    9	#include <string.h>
;   10	//----------------------------------------------------------------------------
;   11	#include "diskio.h"
;   12	//----------------------------------------------------------------------------
;   13	#include "cpmdiskio.h"
;   14	#include "cpmtable.h"
;   15	#include "disks.h"
;   16	#include "sdparams.h"
;   17	#include "sdcard.h"
;   18	//----------------------------------------------------------------------------
;   19	#include <stdio.h>
;   20	//----------------------------------------------------------------------------
;   21	static UINT8          disk_;
;   22	static UINT16         track_;
;   23	static UINT16         sector_;
;   24	static unsigned char *dma_;
;   25	//------------------------------------------------------------------------
;   26	static UINT8 sectorMask_ = 0;
;   27	static UINT32 currentLba_ = 0xFFFFFFFF;
;   28	static BYTE sectorBuffer_[SD_PHYSICAL_SECTOR_SIZE];
	SEGMENT CODE
;   29	//----------------------------------------------------------------------------
;   30	#define WRITE_TYPE_CAN_DEFER_WRITE ( 0 )
;   31	#define WRITE_TYPE_IMMEDIATE_WRITE ( 1 )
;   32	#define WRITE_TYPE_NO_PREREAD      ( 2 )
;   33	//----------------------------------------------------------------------------
;   34	#define READ_RESULT_SUCCESS        ( 0 )
;   35	#define READ_RESULT_FAILURE        ( 1 )
;   36	#define READ_RESULT_MEDIA_CHANGE   ( 0xFF )
;   37	//----------------------------------------------------------------------------
;   38	#define WRITE_RESULT_SUCCESS       ( 0 )
;   39	#define WRITE_RESULT_FAILURE       ( 1 )
;   40	#define WRITE_RESULT_READ_ONLY     ( 2 )
;   41	#define WRITE_RESULT_MEDIA_CHANGE  ( 0xFF )
;   42	//----------------------------------------------------------------------------
;   43	#if ( SD_TRACKS_PER_DISK != 65 )
;   44	#error update the code for tracks per disk
;   45	#endif
;   46	#if ( SD_SECTORS_PER_TRACK != 1024 )
;   47	#error update the code for sectors per track
;   48	#endif
;   49	#if ( SD_LOGICAL_PER_PHYSICAL != 4 )
;   50	#error update the code for logical sectors per physical
;   51	#endif
;   52	//----------------------------------------------------------------------------
;   53	UINT16 selectDisk( UINT8 newLog, UINT8 disk )
;   54	{
_selectDisk:
.DEFINE "_selectDisk"

.VALUE _selectDisk

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "selectDisk",54,"_selectDisk"

.LINE 54

.DEFINE "newLog"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "disk"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   55	    UINT16 r;
;   56	
;   57	    r = getDphP( disk );
.LINE 57

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	CALL	_getDphP
	POP	BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   58	
;   59	    if ( !r ) {
.LINE 59

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_1
;   60	        return 0;
.LINE 60

	OR	A,A
	SBC	HL,HL
	JR	L_2
;   61	    }
L_1:
.LINE 61

;   62	
;   63	    disk_ = disk;
.LINE 63

	LD	A,(IX+%9)
	LD	(_disk_),A
;   64	    return r;
.LINE 64

	LD	HL,(IX+%FFFFFFFE)
;   65	}
L_2:
.LINE 65

	LD	SP,IX
	POP	IX
	RET	


;**************************** _selectDisk ***************************
;Name                         Addr/Register   Size   Type
;_disk_                              STATIC      1   variable
;_getDphP                            IMPORT  -----   function
;r                                     IX-2      2   variable
;disk                                  IX+9      1   parameter
;newLog                                IX+6      1   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "selectDisk",65,"_selectDisk"
;   66	//----------------------------------------------------------------------------
;   67	void homeHead( void )
;   68	{
_homeHead:
.DEFINE "_homeHead"

.VALUE _homeHead

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "homeHead",68,"_homeHead"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   69	    track_ = 0;
.LINE 69

	XOR	A,A
	LD	(_track_),A
	XOR	A,A
	LD	(_track_+1),A
;   70	}
.LINE 70

	LD	SP,IX
	POP	IX
	RET	


;**************************** _homeHead ***************************
;Name                         Addr/Register   Size   Type
;_track_                             STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "homeHead",70,"_homeHead"
;   71	//----------------------------------------------------------------------------
;   72	void setTrack( UINT16 track )
;   73	{
_setTrack:
.DEFINE "_setTrack"

.VALUE _setTrack

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setTrack",73,"_setTrack"

.LINE 73

.DEFINE "track"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   74	    track_ = track;
.LINE 74

	LD	BC,(IX+%6)
	LD	HL,_track_
	LD	(HL),C
	INC	HL
	LD	(HL),B
;   75	}
.LINE 75

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setTrack ***************************
;Name                         Addr/Register   Size   Type
;_track_                             STATIC      2   variable
;track                                 IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setTrack",75,"_setTrack"
;   76	//----------------------------------------------------------------------------
;   77	void setSector( UINT16 sector )
;   78	{
_setSector:
.DEFINE "_setSector"

.VALUE _setSector

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setSector",78,"_setSector"

.LINE 78

.DEFINE "sector"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   79	    sector_ = sector;
.LINE 79

	LD	BC,(IX+%6)
	LD	HL,_sector_
	LD	(HL),C
	INC	HL
	LD	(HL),B
;   80	}
.LINE 80

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setSector ***************************
;Name                         Addr/Register   Size   Type
;_sector_                            STATIC      2   variable
;sector                                IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setSector",80,"_setSector"
;   81	//----------------------------------------------------------------------------
;   82	void setDma( unsigned char *dma )
;   83	{
_setDma:
.DEFINE "_setDma"

.VALUE _setDma

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setDma",83,"_setDma"

.LINE 83

.DEFINE "dma"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   84	    dma_ = dma;
.LINE 84

	LD	BC,(IX+%6)
	LD	(_dma_),BC
;   85	}
.LINE 85

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setDma ***************************
;Name                         Addr/Register   Size   Type
;_dma_                               STATIC      3   variable
;dma                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setDma",85,"_setDma"
;   86	//----------------------------------------------------------------------------
;   87	static UINT32 calculateLba(
;   88	    unsigned disk
;   89	  , unsigned track
;   90	  , unsigned sector )
;   91	{
_calculateLba:
.DEFINE "_calculateLba"

.VALUE _calculateLba

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "calculateLba",91,"_calculateLba"

.LINE 91

.DEFINE "disk"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "track"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "lba"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   92	    UINT32 lba;
;   93	    lba  = ( disk << 6 ) + disk; // * 65
.LINE 93

	LD	BC,(IX+%6)
	XOR	A,A
	LD	L,%6
	CALL	__lshl
	LD	HL,BC
	LD	E,A
	LD	BC,(IX+%6)
	XOR	A,A
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   94	    lba += track;
.LINE 94

	LD	BC,(IX+%9)
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   95	    lba <<= 10;  // * 1024
.LINE 95

	LD	BC,HL
	LD	A,(IX+%FFFFFFFF)
	LD	L,%A
	CALL	__lshl
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   96	    lba += sector;
.LINE 96

	LD	BC,(IX+%C)
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   97	    lba >>= SD_SECTOR_SHIFT;
.LINE 97

	LD	BC,HL
	LD	A,(IX+%FFFFFFFF)
	LD	L,%2
	CALL	__lshru
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   98	    return lba;
.LINE 98

	LD	HL,BC
	LD	E,(IX+%FFFFFFFF)
;   99	}
.LINE 99

	LD	SP,IX
	POP	IX
	RET	


;**************************** _calculateLba ***************************
;Name                         Addr/Register   Size   Type
;lba                                   IX-4      4   variable
;sector                               IX+12      3   parameter
;track                                 IX+9      3   parameter
;disk                                  IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "calculateLba",99,"_calculateLba"
;  100	//----------------------------------------------------------------------------
;  101	UINT8 readSector( void )
;  102	{
_readSector:
.DEFINE "_readSector"

.VALUE _readSector

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "readSector",102,"_readSector"

.LINE 102

.DEFINE "lba"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "offset"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
;  103	    unsigned offset;
;  104	    UINT32 lba = calculateLba( disk_, track_, sector_ );
.LINE 104

	LD	BC,(_sector_)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(_track_)
	CALL	__stoiu
	PUSH	HL
	LD	A,(_disk_)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_calculateLba
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),E
;  105	    if ( currentLba_ != lba )
.LINE 105

	LD	HL,(_currentLba_)
	LD	A,(_currentLba_+3)
	LD	E,A
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	Z,L_11
;  106	    {
;  107	        if ( sectorMask_ != 0 )
.LINE 107

	LD	A,(_sectorMask_)
	OR	A,A
	JR	Z,L_9
;  108	        {
;  109	            write_sdcard( sectorBuffer_, currentLba_ );
.LINE 109

	LD	A,(_currentLba_+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_currentLba_)
	PUSH	BC
	LD	BC,_sectorBuffer_
	PUSH	BC
	CALL	_write_sdcard
	POP	BC
	POP	BC
	POP	BC
;  110	            sectorMask_ = 0;
.LINE 110

	XOR	A,A
	LD	(_sectorMask_),A
;  111	        }
L_9:
.LINE 111

;  112	        read_sdcard( sectorBuffer_, lba, 1U );
.LINE 112

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,_sectorBuffer_
	PUSH	BC
	CALL	_read_sdcard
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  113	        currentLba_ = lba;
.LINE 113

	LD	BC,(IX+%FFFFFFFC)
	LD	(_currentLba_),BC
	LD	A,(IX+%FFFFFFFF)
	LD	(_currentLba_+3),A
;  114	    }
L_11:
.LINE 114

;  115	    offset = ( sector_ & SD_SECTOR_MASK ) << 7;
.LINE 115

	LD	A,(_sector_)
	AND	A,%3
	LD	C,A
	LD	B,%0
	CALL	__stoiu
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF9),HL
;  116	    memcpy( dma_, &sectorBuffer_[offset], 128 );
.LINE 116

	LD	BC,128
	PUSH	BC
	LD	BC,_sectorBuffer_
	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(_dma_)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  117	    return READ_RESULT_SUCCESS;
.LINE 117

	XOR	A,A
;  118	}
.LINE 118

	LD	SP,IX
	POP	IX
	RET	


;**************************** _readSector ***************************
;Name                         Addr/Register   Size   Type
;_dma_                               STATIC      3   variable
;_memcpy                             IMPORT  -----   function
;_read_sdcard                        IMPORT  -----   function
;_sectorBuffer_                      STATIC    512   variable
;_write_sdcard                       IMPORT  -----   function
;_sectorMask_                        STATIC      1   variable
;_currentLba_                        STATIC      4   variable
;_disk_                              STATIC      1   variable
;_track_                             STATIC      2   variable
;_sector_                            STATIC      2   variable
;offset                                IX-7      3   variable
;lba                                   IX-4      4   variable


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "readSector",118,"_readSector"
	SEGMENT TEXT
_indexToBit:
	DB	1
	DB	2
	DB	4
	DB	8
.DEFINE "indexToBit"
.ALIAS "_indexToBit"
.CLASS 84
.VALUE _indexToBit
.DIM 4
.TYPE 108
.ENDEF
;  119	//----------------------------------------------------------------------------
;  120	UINT8 const indexToBit[SD_LOGICAL_PER_PHYSICAL] = { 1, 2, 4, 8 };
	SEGMENT CODE
;  121	//----------------------------------------------------------------------------
;  122	UINT8 writeSector( UINT8 writeType )
;  123	{
_writeSector:
.DEFINE "_writeSector"

.VALUE _writeSector

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "writeSector",123,"_writeSector"

.LINE 123

.DEFINE "writeType"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "lba"

.CLASS 65

.VALUE -5

.TYPE 15

.ENDEF

.DEFINE "offset"

.CLASS 65

.VALUE -8

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  124	    UINT8 index;
;  125	    unsigned offset;
;  126	    UINT32 lba = calculateLba( disk_, track_, sector_ );
.LINE 126

	LD	BC,(_sector_)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(_track_)
	CALL	__stoiu
	PUSH	HL
	LD	A,(_disk_)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_calculateLba
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	(IX+%FFFFFFFB),BC
	LD	(IX+%FFFFFFFE),E
;  127	    if ( currentLba_ != lba )
.LINE 127

	LD	HL,(_currentLba_)
	LD	A,(_currentLba_+3)
	LD	E,A
	LD	A,(IX+%FFFFFFFE)
	CALL	__lcmpu
	JR	Z,L_16
;  128	    {
;  129	        if ( sectorMask_ != 0 )
.LINE 129

	LD	A,(_sectorMask_)
	OR	A,A
	JR	Z,L_14
;  130	        {
;  131	            write_sdcard( sectorBuffer_, currentLba_ );
.LINE 131

	LD	A,(_currentLba_+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_currentLba_)
	PUSH	BC
	LD	BC,_sectorBuffer_
	PUSH	BC
	CALL	_write_sdcard
	POP	BC
	POP	BC
	POP	BC
;  132	            sectorMask_ = 0;
.LINE 132

	XOR	A,A
	LD	(_sectorMask_),A
;  133	        }
L_14:
.LINE 133

;  134	        read_sdcard( sectorBuffer_, lba, 1U );
.LINE 134

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%FFFFFFFE)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,_sectorBuffer_
	PUSH	BC
	CALL	_read_sdcard
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  135	        currentLba_ = lba;
.LINE 135

	LD	BC,(IX+%FFFFFFFB)
	LD	(_currentLba_),BC
	LD	A,(IX+%FFFFFFFE)
	LD	(_currentLba_+3),A
;  136	    }
L_16:
.LINE 136

;  137	    index = ( sector_ & SD_SECTOR_MASK );
.LINE 137

	LD	A,(_sector_)
	AND	A,%3
	LD	(IX+%FFFFFFFF),A
;  138	    offset = ( (unsigned) index ) << 7;
.LINE 138

	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF8),HL
;  139	    memcpy( &sectorBuffer_[offset], dma_, 128 );
.LINE 139

	LD	BC,128
	PUSH	BC
	LD	BC,(_dma_)
	PUSH	BC
	LD	BC,_sectorBuffer_
	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,BC
	PUSH	HL
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  140	    sectorMask_ |= indexToBit[index];
.LINE 140

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_indexToBit
	ADD	HL,BC
	LD	BC,(_sectorMask_)
	LD	A,(HL)
	OR	A,C
	LD	(_sectorMask_),A
;  141	    if ( sectorMask_ == 15 ) // all logical sectors written
.LINE 141

	CP	A,%F
	JR	NZ,L_18
;  142	    {
;  143	        write_sdcard( sectorBuffer_, lba );
.LINE 143

	LD	C,(IX+%FFFFFFFE)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,_sectorBuffer_
	PUSH	BC
	CALL	_write_sdcard
	POP	BC
	POP	BC
	POP	BC
;  144	        sectorMask_ = 0;
.LINE 144

	XOR	A,A
	LD	(_sectorMask_),A
;  145	    }
L_18:
.LINE 145

;  146	    return WRITE_RESULT_SUCCESS;
.LINE 146

	XOR	A,A
;  147	}
.LINE 147

	LD	SP,IX
	POP	IX
	RET	


;**************************** _writeSector ***************************
;Name                         Addr/Register   Size   Type
;_indexToBit                         STATIC      4   variable
;_dma_                               STATIC      3   variable
;_memcpy                             IMPORT  -----   function
;_read_sdcard                        IMPORT  -----   function
;_sectorBuffer_                      STATIC    512   variable
;_write_sdcard                       IMPORT  -----   function
;_sectorMask_                        STATIC      1   variable
;_currentLba_                        STATIC      4   variable
;_disk_                              STATIC      1   variable
;_track_                             STATIC      2   variable
;_sector_                            STATIC      2   variable
;offset                                IX-8      3   variable
;lba                                   IX-5      4   variable
;index                                 IX-1      1   variable
;writeType                             IX+6      1   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "writeSector",147,"_writeSector"
;  148	//----------------------------------------------------------------------------
;  149	UINT16 translateSector( UINT16 logical )
;  150	{
_translateSector:
.DEFINE "_translateSector"

.VALUE _translateSector

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "translateSector",150,"_translateSector"

.LINE 150

.DEFINE "logical"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  151	    return logical;
.LINE 151

	LD	HL,(IX+%6)
;  152	}
.LINE 152

	LD	SP,IX
	POP	IX
	RET	


;**************************** _translateSector ***************************
;Name                         Addr/Register   Size   Type
;logical                               IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "translateSector",152,"_translateSector"
;  153	//----------------------------------------------------------------------------
;  154	void initCpmDiskio( void )
;  155	{
_initCpmDiskio:
.DEFINE "_initCpmDiskio"

.VALUE _initCpmDiskio

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initCpmDiskio",155,"_initCpmDiskio"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  156	    init_sdcard();
.LINE 156

	CALL	_init_sdcard
;  157	}
.LINE 157

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initCpmDiskio ***************************
;Name                         Addr/Register   Size   Type
;_init_sdcard                        IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initCpmDiskio",157,"_initCpmDiskio"
	XREF _write_sdcard:ROM
	XREF _read_sdcard:ROM
	XREF _init_sdcard:ROM
	XREF _getDphP:ROM
	XREF _memcpy:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lshl:ROM
	XREF __lshru:ROM
	XREF __stoiu:ROM
	XDEF _initCpmDiskio
	XDEF _translateSector
	XDEF _writeSector
	XDEF _indexToBit
	XDEF _readSector
	XDEF _setDma
	XDEF _setSector
	XDEF _setTrack
	XDEF _homeHead
	XDEF _selectDisk
	END
