; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\..\fatfs\source\diskio.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",4
.DEFINE "dr"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "ddr"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "alt1"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "alt2"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",10
.DEFINE "uartMode"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "baudRate"
.VALUE 1
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fifoTriggerLevel"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "hwFlowControl"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "swFlowControl"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",9
.DEFINE "pBuffer"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "next_in"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "next_out"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "size"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME2"
	SEGMENT DATA
_dstat:
	DB	1
.DEFINE "dstat"
.ALIAS "_dstat"
.CLASS 69
.VALUE _dstat
.TYPE 12
.ENDEF
;    1	/*-----------------------------------------------------------------------*/
;    2	/* Low level disk I/O module for MakerLisp Machine port of FatFs         */
;    3	/*-----------------------------------------------------------------------*/
;    4	
;    5	#include <ez80.h>
;    6	#include <string.h>
;    7	
;    8	//#include "time.h"
;    9	#include "sdcard.h"
;   10	#include "diskio.h"   /* FatFs lower layer API */
;   11	
;   12	/* Sector size */
;   13	#define SECTSIZ 512
;   14	
;   15	/* Drive status */
;   16	static DSTATUS dstat = STA_NOINIT;
	SEGMENT CODE
;   17	
;   18	/*-----------------------------------------------------------------------*/
;   19	/* Get Drive Status                                                      */
;   20	/*-----------------------------------------------------------------------*/
;   21	
;   22	DSTATUS disk_status (
;   23	    BYTE pdrv         /* Physical drive number to identify the drive */
;   24	)
;   25	{
_disk_status:
.DEFINE "_disk_status"

.VALUE _disk_status

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "disk_status",25,"_disk_status"

.LINE 25

.DEFINE "pdrv"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "buf"

.CLASS 65

.VALUE -512

.DIM 512

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-512
	ADD	HL,SP
	LD	SP,HL
;   26	    BYTE buf[SECTSIZ];
;   27	
;   28	    if (pdrv) {
.LINE 28

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_5
;   29	        return RES_PARERR;
.LINE 29

	LD	A,%4
	JR	L_7
;   30	    }
L_5:
.LINE 30

;   31	
;   32	    /* If two seconds elapsed since last access, maybe card has changed */
;   33	    if (!dstat) {
.LINE 33

	LD	A,(_dstat)
	OR	A,A
	JR	NZ,L_6
;   34	        if (!(TMR0_CTL & 0x01)) {
.LINE 34

	IN0	A,(128)
	AND	A,%1
	JR	NZ,L_6
;   35	
;   36	            /* Card is out or just inserted and isn't initialized yet */
;   37	            if (read_sdcard(buf, 0, 1)) {
.LINE 37

	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	HL,IX
	LD	BC,-512
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_read_sdcard
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_2
;   38	                dstat = STA_NOINIT;
.LINE 38

	LD	A,%1
	LD	(_dstat),A
;   39	            } else {
.LINE 39

	JR	L_6
L_2:
;   40	                /* Still in - restart two second countdown timer */
;   41	                TMR0_CTL = 0x23;
.LINE 41

	LD	A,%23
	OUT0	(128),A
;   42	            }
;   43	        }
;   44	    }
L_6:
.LINE 44

;   45	
;   46	    return dstat;
.LINE 46

	LD	A,(_dstat)
;   47	}
L_7:
.LINE 47

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_status ***************************
;Name                         Addr/Register   Size   Type
;_read_sdcard                        IMPORT  -----   function
;_dstat                              STATIC      1   variable
;buf                                 IX-512    512   variable
;pdrv                                  IX+6      1   parameter


; Stack Frame Size: 521 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_status",47,"_disk_status"
;   48	
;   49	/*-----------------------------------------------------------------------*/
;   50	/* Initialize a Drive                                                    */
;   51	/*-----------------------------------------------------------------------*/
;   52	
;   53	DSTATUS disk_initialize (
;   54	    BYTE pdrv         /* Physical drive number to identify the drive */
;   55	)
;   56	{
_disk_initialize:
.DEFINE "_disk_initialize"

.VALUE _disk_initialize

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "disk_initialize",56,"_disk_initialize"

.LINE 56

.DEFINE "pdrv"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   57	    if (pdrv) {
.LINE 57

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_11
;   58	        return RES_PARERR;
.LINE 58

	LD	A,%4
	JR	L_13
;   59	    }
L_11:
.LINE 59

;   60	
;   61	    /* Initialize SD card */
;   62	    if (init_sdcard()) {
.LINE 62

	CALL	_init_sdcard
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_10
;   63	        dstat = STA_NOINIT;
.LINE 63

	LD	A,%1
	LD	(_dstat),A
;   64	    } else {
.LINE 64

	JR	L_12
L_10:
;   65	        /* Start two second count down timer */
;   66	        dstat = 0;
.LINE 66

	XOR	A,A
	LD	(_dstat),A
;   67	        TMR0_CTL = 0x23;
.LINE 67

	LD	A,%23
	OUT0	(128),A
;   68	    }
L_12:
.LINE 68

;   69	
;   70	    return dstat;
.LINE 70

	LD	A,(_dstat)
;   71	}
L_13:
.LINE 71

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_initialize ***************************
;Name                         Addr/Register   Size   Type
;_dstat                              STATIC      1   variable
;_init_sdcard                        IMPORT  -----   function
;pdrv                                  IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_initialize",71,"_disk_initialize"
;   72	
;   73	/*-----------------------------------------------------------------------*/
;   74	/* Read Sector(s)                                                        */
;   75	/*-----------------------------------------------------------------------*/
;   76	
;   77	DRESULT disk_read (
;   78	    BYTE pdrv,        /* Physical drive number to identify the drive */
;   79	    BYTE *buff,       /* Data buffer to store read data */
;   80	    DWORD sector,     /* Start sector in LBA */
;   81	    UINT count        /* Number of sectors to read */
;   82	)
;   83	{
_disk_read:
.DEFINE "_disk_read"

.VALUE _disk_read

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "disk_read",83,"_disk_read"

.LINE 83

.DEFINE "pdrv"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "count"

.CLASS 65

.VALUE 18

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   84	    if (pdrv) {
.LINE 84

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_16
;   85	        return RES_PARERR;
.LINE 85

	LD	HL,4
	JR	L_20
;   86	    }
L_16:
.LINE 86

;   87	
;   88	    if (dstat == STA_NOINIT) {
.LINE 88

	LD	A,(_dstat)
	CP	A,%1
	JR	NZ,L_18
;   89	        return RES_NOTRDY;
.LINE 89

	LD	HL,3
	JR	L_20
;   90	    }
L_18:
.LINE 90

;   91	
;   92	    if (read_sdcard(buff, sector, count)) {
.LINE 92

	LD	BC,(IX+%12)
	PUSH	BC
	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_read_sdcard
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_19
;   93	        return RES_ERROR;
.LINE 93

	LD	HL,1
	JR	L_20
;   94	    }
L_19:
.LINE 94

;   95	
;   96	    /* Restart two second countdown timer */
;   97	    TMR0_CTL = 0x23;
.LINE 97

	LD	A,%23
	OUT0	(128),A
;   98	
;   99	    return RES_OK;
.LINE 99

	OR	A,A
	SBC	HL,HL
;  100	}
L_20:
.LINE 100

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_read ***************************
;Name                         Addr/Register   Size   Type
;_read_sdcard                        IMPORT  -----   function
;_dstat                              STATIC      1   variable
;count                                IX+18      3   parameter
;sector                               IX+12      4   parameter
;buff                                  IX+9      3   parameter
;pdrv                                  IX+6      1   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_read",100,"_disk_read"
;  101	
;  102	/*-----------------------------------------------------------------------*/
;  103	/* Write Sector(s)                                                       */
;  104	/*-----------------------------------------------------------------------*/
;  105	
;  106	DRESULT disk_write (
;  107	    BYTE pdrv,        /* Physical drive number to identify the drive */
;  108	    const BYTE *buff, /* Data to be written */
;  109	    DWORD sector,     /* Start sector in LBA */
;  110	    UINT count        /* Number of sectors to write */
;  111	)
;  112	{
_disk_write:
.DEFINE "_disk_write"

.VALUE _disk_write

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "disk_write",112,"_disk_write"

.LINE 112

.DEFINE "pdrv"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 9

.TYPE 204

.ENDEF

.DEFINE "sector"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "count"

.CLASS 65

.VALUE 18

.TYPE 14

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -3

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "s"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;  113	    BYTE *b;
;  114	    UINT i;
;  115	    DWORD s;
;  116	
;  117	    if (pdrv) {
.LINE 117

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_23
;  118	        return RES_PARERR;
.LINE 118

	LD	HL,4
	JR	L_30
;  119	    }
L_23:
.LINE 119

;  120	
;  121	    if (dstat == STA_NOINIT) {
.LINE 121

	LD	A,(_dstat)
	CP	A,%1
	JR	NZ,L_24
;  122	        return RES_NOTRDY;
.LINE 122

	LD	HL,3
	JR	L_30
;  123	    }
L_24:
.LINE 123

;  124	
;  125	    b = buff;
.LINE 125

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFD),BC
;  126	    s = sector;
.LINE 126

	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
;  127	    i = 0;
.LINE 127

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
;  128	    while (i < count) {
.LINE 128

	JR	L_27
L_28:
;  129	        if (write_sdcard(b, s)) {
.LINE 129

	LD	C,(IX+%FFFFFFF9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_write_sdcard
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_26
;  130	            return RES_ERROR;
.LINE 130

	LD	HL,1
	JR	L_30
;  131	        }
L_26:
.LINE 131

;  132	        b += SECTSIZ;
.LINE 132

	LD	BC,512
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
;  133	        ++s;
.LINE 133

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFF6),HL
	LD	(IX+%FFFFFFF9),E
;  134	        ++i;
.LINE 134

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  135	    }
L_27:
.LINE 135

	LD	BC,(IX+%12)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	C,L_28
;  136	
;  137	    /* Restart two second countdown timer */
;  138	    TMR0_CTL = 0x23;
.LINE 138

	LD	A,%23
	OUT0	(128),A
;  139	
;  140	    return RES_OK;
.LINE 140

	OR	A,A
	SBC	HL,HL
;  141	}
L_30:
.LINE 141

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_write ***************************
;Name                         Addr/Register   Size   Type
;_write_sdcard                       IMPORT  -----   function
;_dstat                              STATIC      1   variable
;s                                    IX-10      4   variable
;i                                     IX-6      3   variable
;b                                     IX-3      3   variable
;count                                IX+18      3   parameter
;sector                               IX+12      4   parameter
;buff                                  IX+9      3   parameter
;pdrv                                  IX+6      1   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_write",141,"_disk_write"
;  142	
;  143	/*-----------------------------------------------------------------------*/
;  144	/* Miscellaneous Functions                                               */
;  145	/*-----------------------------------------------------------------------*/
;  146	
;  147	DRESULT disk_ioctl (
;  148	    BYTE pdrv,        /* Physical drive number (0..) */
;  149	    BYTE cmd,         /* Control code */
;  150	    void *buff        /* Buffer to send/receive control data */
;  151	)
;  152	{
_disk_ioctl:
.DEFINE "_disk_ioctl"

.VALUE _disk_ioctl

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "disk_ioctl",152,"_disk_ioctl"

.LINE 152

.DEFINE "pdrv"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "cmd"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "buff"

.CLASS 65

.VALUE 12

.TYPE 33

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  153	    switch (cmd) {
.LINE 153

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
L__17:
	LD	DE,0
	OR	A,A
	SBC	HL,DE
	JR	NZ,L_32
;  154	        case CTRL_SYNC :
.LINE 154

;  155	            return RES_OK;
.LINE 155

	OR	A,A
	SBC	HL,HL
	JR	L_33
;  156	        default :
L_32:
.LINE 156

;  157	            return RES_PARERR;
.LINE 157

	LD	HL,4
;  158	    }
;  159	}
L_33:
.LINE 159

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_ioctl ***************************
;Name                         Addr/Register   Size   Type
;buff                                 IX+12      3   parameter
;cmd                                   IX+9      1   parameter
;pdrv                                  IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_ioctl",159,"_disk_ioctl"
;  160	
;  161	/* FAT filesystem time */
;  162	static DWORD bcd2bin(UINT8 bcdn)
;  163	{
_bcd2bin:
.DEFINE "_bcd2bin"

.VALUE _bcd2bin

.CLASS 3

.TYPE 79

.ENDEF

.BEGFUNC "bcd2bin",163,"_bcd2bin"

.LINE 163

.DEFINE "bcdn"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;  164	    return (((DWORD)bcdn & 0xF0) >> 4)*10 + ((DWORD)bcdn & 0x0F);
.LINE 164

	UEXT	HL
	LD	L,(IX+%6)
	LD	A,H
	LD	BC,HL
	LD	L,%4
	CALL	__lshru
	LD	A,C
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	E,H
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFFD),HL
	UEXT	HL
	LD	L,(IX+%6)
	LD	BC,HL
	LD	A,C
	AND	A,%F
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,H
	LD	HL,(IX+%FFFFFFFD)
	CALL	__ladd
;  165	}
.LINE 165

	LD	SP,IX
	POP	IX
	RET	


;**************************** _bcd2bin ***************************
;Name                         Addr/Register   Size   Type
;bcdn                                  IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "bcd2bin",165,"_bcd2bin"
;  166	DWORD get_fattime()
;  167	{
_get_fattime:
.DEFINE "_get_fattime"

.VALUE _get_fattime

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "get_fattime",167,"_get_fattime"

.LINE 167

.DEFINE "t"

.CLASS 65

.VALUE -3

.TYPE 44

.ENDEF

.DEFINE "fattime"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "year"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

.DEFINE "month"

.CLASS 65

.VALUE -15

.TYPE 15

.ENDEF

.DEFINE "dom"

.CLASS 65

.VALUE -19

.TYPE 15

.ENDEF

.DEFINE "hour"

.CLASS 65

.VALUE -23

.TYPE 15

.ENDEF

.DEFINE "minute"

.CLASS 65

.VALUE -27

.TYPE 15

.ENDEF

.DEFINE "second2"

.CLASS 65

.VALUE -31

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFCF
	LD	SP,HL
;  168	    UINT8 *t;
;  169	    DWORD fattime, year, month, dom, hour, minute, second2;
;  170	
;  171	    /* Grab the time */
;  172	    t = get_time();
.LINE 172

	CALL	_get_time
	LD	(IX+%FFFFFFFD),HL
;  173	
;  174	    /* Put in FAT fs format */
;  175	    year = bcd2bin(t[6])*100 + bcd2bin(t[5]) - 1980;
.LINE 175

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%6
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	BC,100
	XOR	A,A
	CALL	__lmulu
	LD	(IX+%FFFFFFD2),E
	LD	(IX+%FFFFFFCF),HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%5
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	E,(IX+%FFFFFFD2)
	LD	HL,(IX+%FFFFFFCF)
	CALL	__ladd
	LD	BC,1980
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
;  176	    month = bcd2bin(t[4]);
.LINE 176

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%4
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	(IX+%FFFFFFF1),HL
	LD	(IX+%FFFFFFF4),E
;  177	    dom = bcd2bin(t[3]);
.LINE 177

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	(IX+%FFFFFFED),HL
	LD	(IX+%FFFFFFF0),E
;  178	    hour = bcd2bin(t[2]);
.LINE 178

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	(IX+%FFFFFFE9),HL
	LD	(IX+%FFFFFFEC),E
;  179	    minute = bcd2bin(t[1]);
.LINE 179

	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	(IX+%FFFFFFE5),HL
	LD	(IX+%FFFFFFE8),E
;  180	    second2 = bcd2bin(t[0]) / 2;
.LINE 180

	LD	HL,(IX+%FFFFFFFD)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_bcd2bin
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	L,%1
	CALL	__lshru
	LD	(IX+%FFFFFFE1),BC
	LD	(IX+%FFFFFFE4),A
;  181	
;  182	    fattime = (year << 25) | (month << 21) | (dom << 16) | \
;  183	        (hour << 11) | (minute << 5) | second2;
.LINE 183

	LD	BC,(IX+%FFFFFFF1)
	LD	A,(IX+%FFFFFFF4)
	LD	L,%15
	CALL	__lshl
	LD	(IX+%FFFFFFDB),BC
	LD	E,A
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	LD	L,%19
	CALL	__lshl
	LD	HL,(IX+%FFFFFFDB)
	CALL	__lor
	LD	(IX+%FFFFFFDE),HL
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	PUSH	BC
	UEXT	HL
	PUSH	HL
	INC	SP
	POP	BC
	POP	HL
	LD	(IX+%FFFFFFD9),L	; spill
	INC	SP
	INC	SP
	LD	HL,(IX+%FFFFFFDE)
	LD	(IX+%FFFFFFDA),L	; spill
	LD	L,(IX+%FFFFFFD9)	; unspill
	LD	A,L
	LD	L,(IX+%FFFFFFDA)	; unspill
	CALL	__lor
	LD	(IX+%FFFFFFD6),HL
	LD	BC,(IX+%FFFFFFE9)
	LD	A,(IX+%FFFFFFEC)
	LD	L,%B
	CALL	__lshl
	LD	HL,(IX+%FFFFFFD6)
	CALL	__lor
	LD	(IX+%FFFFFFD3),HL
	LD	BC,(IX+%FFFFFFE5)
	LD	A,(IX+%FFFFFFE8)
	LD	L,%5
	CALL	__lshl
	LD	HL,(IX+%FFFFFFD3)
	CALL	__lor
	LD	BC,(IX+%FFFFFFE1)
	LD	A,(IX+%FFFFFFE4)
	CALL	__lor
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
;  184	
;  185	    return fattime;
.LINE 185

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
;  186	}
.LINE 186

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_fattime ***************************
;Name                         Addr/Register   Size   Type
;_get_time                           IMPORT  -----   function
;second2                              IX-31      4   variable
;minute                               IX-27      4   variable
;hour                                 IX-23      4   variable
;dom                                  IX-19      4   variable
;month                                IX-15      4   variable
;year                                 IX-11      4   variable
;fattime                               IX-7      4   variable
;t                                     IX-3      3   variable


; Stack Frame Size: 55 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_fattime",186,"_get_fattime"
;  187	
;  188	/* Force recognition of medium change */
;  189	void disk_change()
;  190	{
_disk_change:
.DEFINE "_disk_change"

.VALUE _disk_change

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "disk_change",190,"_disk_change"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  191	    dstat = STA_NOINIT;
.LINE 191

	LD	A,%1
	LD	(_dstat),A
;  192	}
.LINE 192

	LD	SP,IX
	POP	IX
	RET	


;**************************** _disk_change ***************************
;Name                         Addr/Register   Size   Type
;_dstat                              STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "disk_change",192,"_disk_change"
	XREF _get_time:ROM
	XREF _write_sdcard:ROM
	XREF _read_sdcard:ROM
	XREF _init_sdcard:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __lmulu:ROM
	XREF __lor:ROM
	XREF __lshl:ROM
	XREF __lshru:ROM
	XREF __ladd_b:ROM
	XDEF _disk_change
	XDEF _get_fattime
	XDEF _disk_ioctl
	XDEF _disk_write
	XDEF _disk_read
	XDEF _disk_initialize
	XDEF _disk_status
	END
