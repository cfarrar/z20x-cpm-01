; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\cpmtable.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
;    1	//----------------------------------------------------------------------------
;    2	// Copyright (c) 2019, Christopher D. Farrar
;    3	//----------------------------------------------------------------------------
;    4	// I here grant permission to any and all to copy and use this software for
;    5	// any purpose as long as my copyright message is retained.
;    6	//----------------------------------------------------------------------------
;    7	#include <defines.h>
;    8	//----------------------------------------------------------------------------
;    9	#include "cpmtable.h"
;   10	#include "cpmregisters.h"
;   11	#include "sdparams.h"
;   12	//----------------------------------------------------------------------------
;   13	typedef struct DiskParameterHeaderStruct
;   14	{
;   15	    UINT16  xlt;
;   16	    UINT16  w1;
;   17	    UINT16  w2;
;   18	    UINT16  w3;
;   19	    UINT16  dirbuf;
;   20	    UINT16  dpb;
;   21	    UINT16  csv;
;   22	    UINT16  alv;
;   23	} DiskParameterHeader;
.BEGREC "DiskParameterHeaderStruct",16
.DEFINE "xlt"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "w1"
.VALUE 2
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "w2"
.VALUE 4
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "w3"
.VALUE 6
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "dirbuf"
.VALUE 8
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "dpb"
.VALUE 10
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "csv"
.VALUE 12
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "alv"
.VALUE 14
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "DiskParameterHeaderStruct"
;   24	//----------------------------------------------------------------------------
;   25	typedef struct DiskParameterBlockStruct
;   26	{
;   27	    UINT16  spt;
;   28	    UINT8   bsh;
;   29	    UINT8   blm;
;   30	    UINT8   exm;
;   31	    UINT16  dsm;
;   32	    UINT16  drm;
;   33	    UINT8   al0;
;   34	    UINT8   al1;
;   35	    UINT16  cks;
;   36	    UINT16  off;
;   37	} DiskParameterBlock;
.BEGREC "DiskParameterBlockStruct",15
.DEFINE "spt"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bsh"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "blm"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exm"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "dsm"
.VALUE 5
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "drm"
.VALUE 7
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "al0"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "al1"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cks"
.VALUE 11
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "off"
.VALUE 13
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "DiskParameterBlockStruct"
	SEGMENT BSS
_nextByte_:
	DS	3
.DEFINE "nextByte_"
.ALIAS "_nextByte_"
.CLASS 83
.VALUE _nextByte_
.TYPE 44
.ENDEF
_dphP:
	DS	24
.DEFINE "dphP"
.ALIAS "_dphP"
.CLASS 83
.VALUE _dphP
.DIM 8
.TAG "DiskParameterHeaderStruct"
.TYPE 360
.ENDEF
_dpbsdP:
	DS	3
.DEFINE "dpbsdP"
.ALIAS "_dpbsdP"
.CLASS 83
.VALUE _dpbsdP
.TAG "DiskParameterBlockStruct"
.TYPE 40
.ENDEF
_dirbufP:
	DS	3
.DEFINE "dirbufP"
.ALIAS "_dirbufP"
.CLASS 83
.VALUE _dirbufP
.TYPE 44
.ENDEF
_allP:
	DS	24
.DEFINE "allP"
.ALIAS "_allP"
.CLASS 83
.VALUE _allP
.DIM 8
.TYPE 364
.ENDEF
;   38	//----------------------------------------------------------------------------
;   39	static unsigned char *nextByte_;
;   40	static DiskParameterHeader *dphP[SD_CARD_DISKS];
;   41	static DiskParameterBlock  *dpbsdP;
;   42	static unsigned char *dirbufP;
;   43	static unsigned char *allP[SD_CARD_DISKS];
	SEGMENT CODE
;   44	//----------------------------------------------------------------------------
;   45	UINT16 getDphP( UINT8 disk )
;   46	{
_getDphP:
.DEFINE "_getDphP"

.VALUE _getDphP

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "getDphP",46,"_getDphP"

.LINE 46

.DEFINE "disk"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   47	    if ( disk < SD_CARD_DISKS )
.LINE 47

	LD	A,(IX+%6)
	CP	A,%8
	JR	NC,L_1
;   48	    {
;   49	        return (UINT16) dphP[disk];
.LINE 49

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	HL,(HL)
	JR	L_2
;   50	    }
L_1:
.LINE 50

;   51	    return 0x0000;
.LINE 51

	OR	A,A
	SBC	HL,HL
;   52	}
L_2:
.LINE 52

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getDphP ***************************
;Name                         Addr/Register   Size   Type
;_dphP                               STATIC     24   variable
;disk                                  IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getDphP",52,"_getDphP"
;   53	//----------------------------------------------------------------------------
;   54	void cpmSetRamBase( void )
;   55	{
_cpmSetRamBase:
.DEFINE "_cpmSetRamBase"

.VALUE _cpmSetRamBase

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "cpmSetRamBase",55,"_cpmSetRamBase"

.LINE 55

.DEFINE "disk"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "addr"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   56	    UINT8 disk;
;   57	    UINT24 addr = (UINT24) ( mbregister & 0xFF );
.LINE 57

	LD	A,(_mbregister)
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFFC),HL
;   58	    addr <<= 16;
.LINE 58

	PUSH	HL
	UEXT	HL
	PUSH	HL
	INC	SP
	POP	HL
	INC	SP
	INC	SP
	LD	(IX+%FFFFFFFC),HL
;   59	    addr += (UINT24) ( bcregister & 0xFFFF );
.LINE 59

	LD	BC,(_bcregister)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFFC)
	ADD	HL,BC
	LD	(IX+%FFFFFFFC),HL
;   60	
;   61	    // beginning of allocatable ram space above bios
;   62	    nextByte_ = (unsigned char *) addr;
.LINE 62

	LD	BC,HL
	LD	(_nextByte_),BC
;   63	
;   64	    // disk parameter blocks
;   65	    for ( disk = 0; disk < SD_CARD_DISKS; ++disk )
.LINE 65

	LD	(IX+%FFFFFFFF),%0
	JR	L_5
L_3:
;   66	    {
;   67	        dphP[disk] = (DiskParameterHeader *) nextByte_;
.LINE 67

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	BC,(_nextByte_)
	LD	(HL),BC
;   68	        nextByte_ += sizeof (DiskParameterHeader);
.LINE 68

	LD	IY,(_nextByte_)
	LEA	BC,IY+%10
	LD	(_nextByte_),BC
	INC	(IX+%FFFFFFFF)
;   69	    }
L_5:
.LINE 69

	LD	A,(IX+%FFFFFFFF)
	CP	A,%8
	JR	C,L_3
;   70	
;   71	    // allocation vector tables
;   72	    for ( disk = 0; disk < SD_CARD_DISKS; ++disk )
.LINE 72

	LD	(IX+%FFFFFFFF),%0
	JR	L_8
L_6:
;   73	    {
;   74	        allP[disk] = nextByte_;
.LINE 74

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_allP
	ADD	HL,BC
	LD	BC,(_nextByte_)
	LD	(HL),BC
;   75	        nextByte_ += SD_ALLCATION_VECTOR_SIZE;
.LINE 75

	LD	BC,256
	LD	HL,(_nextByte_)
	ADD	HL,BC
	LD	(_nextByte_),HL
	INC	(IX+%FFFFFFFF)
;   76	    }
L_8:
.LINE 76

	LD	A,(IX+%FFFFFFFF)
	CP	A,%8
	JR	C,L_6
;   77	
;   78	    // allocate space for and build disk
;   79	    // disk parameter block for sd card hard drive images
;   80	    dpbsdP = (DiskParameterBlock *) nextByte_;
.LINE 80

	LD	BC,(_nextByte_)
	LD	(_dpbsdP),BC
;   81	    nextByte_ += sizeof (DiskParameterBlock);
.LINE 81

	LD	IY,(_nextByte_)
	LEA	BC,IY+%F
	LD	(_nextByte_),BC
;   82	    dirbufP = nextByte_;
.LINE 82

	LD	(_dirbufP),BC
;   83	    nextByte_ += LOGICAL_SECTOR_SIZE;
.LINE 83

	LD	BC,128
	LD	HL,(_nextByte_)
	ADD	HL,BC
	LD	(_nextByte_),HL
;   84	
;   85	    // initiate the sd card disk parameter block
;   86	    dpbsdP->spt = SD_SECTORS_PER_TRACK;     // 1024
.LINE 86

	LD	IY,(_dpbsdP)
	LD	(IY+%0),%0
	LD	(IY+%1),%4
;   87	    dpbsdP->bsh = SD_BLOCK_SHIFT_FACTOR;    // 5;
.LINE 87

	LD	IY,(_dpbsdP)
	LD	(IY+%2),%5
;   88	    dpbsdP->blm = SD_BLOCK_MASK;            // 31;
.LINE 88

	LD	IY,(_dpbsdP)
	LD	(IY+%3),%1F
;   89	    dpbsdP->exm = SD_EXTENT_MASK;           // 1;
.LINE 89

	LD	IY,(_dpbsdP)
	LD	A,%1
	LD	(IY+%4),A
;   90	    dpbsdP->dsm = SD_DISK_BLOCKS - 1;       // 2047;
.LINE 90

	LD	IY,(_dpbsdP)
	LD	(IY+%5),%FF
	LD	(IY+%6),%7
;   91	    dpbsdP->drm = SD_DIRECTORY_ENTRIES - 1; // 511;
.LINE 91

	LD	IY,(_dpbsdP)
	LD	(IY+%7),%FF
	LD	(IY+%8),A
;   92	    dpbsdP->al0 = SD_ALLOCATION_BITMAP_0;   // 0xf0;
.LINE 92

	LD	IY,(_dpbsdP)
	LD	(IY+%9),%F0
;   93	    dpbsdP->al1 = SD_ALLOCATION_BITMAP_1;   // 0x00;
.LINE 93

	LD	IY,(_dpbsdP)
	LD	(IY+%A),%0
;   94	    dpbsdP->cks = SD_CHECKSUM_VECTOR_SIZE;  // 0;
.LINE 94

	LD	IY,(_dpbsdP)
	LD	(IY+%B),%0
	LD	(IY+%C),%0
;   95	    dpbsdP->off = SD_TRACK_OFFSET;          // 1;
.LINE 95

	LD	IY,(_dpbsdP)
	LD	(IY+%D),%1
	LD	(IY+%E),%0
;   96	
;   97	    // initiate the disk parameter headers
;   98	    for ( disk = 0; disk < SD_CARD_DISKS; ++disk )
.LINE 98

	LD	(IX+%FFFFFFFF),%0
	JR	L_13
L_11:
;   99	    {
;  100	        dphP[disk]->xlt = 0;
.LINE 100

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	IY,(HL)
	LD	(IY+%0),%0
	LD	(IY+%1),%0
;  101	        dphP[disk]->w1 = 0;
.LINE 101

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	IY,(HL)
	LD	(IY+%2),%0
	LD	(IY+%3),%0
;  102	        dphP[disk]->w2 = 0;
.LINE 102

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	IY,(HL)
	LD	(IY+%4),%0
	LD	(IY+%5),%0
;  103	        dphP[disk]->w3 = 0;
.LINE 103

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_dphP
	ADD	HL,BC
	LD	IY,(HL)
	LD	(IY+%6),%0
	LD	(IY+%7),%0
;  104	        dphP[disk]->dirbuf = (UINT16) ( dirbufP );
.LINE 104

	LD	BC,(_dirbufP)
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_dphP
	ADD	HL,DE
	LD	IY,(HL)
	LD	(IY+%8),C
	LD	(IY+%9),B
;  105	        dphP[disk]->dpb = (UINT16) ( dpbsdP );
.LINE 105

	LD	BC,(_dpbsdP)
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_dphP
	ADD	HL,DE
	LD	IY,(HL)
	LD	(IY+%A),C
	LD	(IY+%B),B
;  106	        dphP[disk]->csv = 0;
.LINE 106

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	IY,(HL)
	LD	(IY+%C),%0
	LD	(IY+%D),%0
;  107	        dphP[disk]->alv = (UINT16) ( allP[disk] );
.LINE 107

	LD	DE,_allP
	LD	HL,BC
	ADD	HL,DE
	LD	BC,(HL)
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_dphP
	ADD	HL,DE
	LD	IY,(HL)
	LD	(IY+%E),C
	LD	(IY+%F),B
	INC	(IX+%FFFFFFFF)
;  108	    }
L_13:
.LINE 108

	LD	A,(IX+%FFFFFFFF)
	CP	A,%8
	JR	C,L_11
;  109	}
.LINE 109

	LD	SP,IX
	POP	IX
	RET	


;**************************** _cpmSetRamBase ***************************
;Name                         Addr/Register   Size   Type
;_dirbufP                            STATIC      3   variable
;_dpbsdP                             STATIC      3   variable
;_allP                               STATIC     24   variable
;_dphP                               STATIC     24   variable
;_nextByte_                          STATIC      3   variable
;_bcregister                         IMPORT      3   variable
;_mbregister                         IMPORT      1   variable
;addr                                  IX-4      3   variable
;disk                                  IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "cpmSetRamBase",109,"_cpmSetRamBase"
	XREF _bcregister:ROM
	XREF _mbregister:ROM
	XREF __stoiu:ROM
	XDEF _cpmSetRamBase
	XDEF _getDphP
	END
