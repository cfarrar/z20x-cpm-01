    1 C	/*----------------------------------------------------------------------------/
    2 C	/  FatFs - Generic FAT Filesystem Module  R0.13b                              /
    3 C	/-----------------------------------------------------------------------------/
    4 C	/
    5 C	/ Copyright (C) 2018, ChaN, all right reserved.
    6 C	/
    7 C	/ FatFs module is an open source software. Redistribution and use of FatFs in
    8 C	/ source and binary forms, with or without modification, are permitted provided
    9 C	/ that the following condition is met:
   10 C	/
   11 C	/ 1. Redistributions of source code must retain the above copyright notice,
   12 C	/    this condition and the following disclaimer.
   13 C	/
   14 C	/ This software is provided by the copyright holder and contributors "AS IS"
   15 C	/ and any warranties related to this software are DISCLAIMED.
   16 C	/ The copyright owner or contributors be NOT LIABLE for any damages caused
   17 C	/ by use of this software.
   18 C	/
   19 C	/----------------------------------------------------------------------------*/
   20 C	
   21 C	
   22  	#include "ff.h"			/* Declarations of FatFs API */
   23  	#include "diskio.h"		/* Declarations of device I/O functions */
   24  	
   25  	
   26 C	/*--------------------------------------------------------------------------
   27 C	
   28 C	   Module Private Definitions
   29 C	
   30 C	---------------------------------------------------------------------------*/
   31 C	
   32  	#if FF_DEFINED != 63463	/* Revision ID */
MacExp: #if 63463 != 63463	/* Revision ID */
   33 X	#error Wrong include file (ff.h).
   34  	#endif
   35  	
   36  	
   37 C	/* Character code support macros */
   38  	#define IsUpper(c)		((c) >= 'A' && (c) <= 'Z')
   39  	#define IsLower(c)		((c) >= 'a' && (c) <= 'z')
   40  	#define IsDigit(c)		((c) >= '0' && (c) <= '9')
   41  	#define IsSurrogate(c)	((c) >= 0xD800 && (c) <= 0xDFFF)
   42  	#define IsSurrogateH(c)	((c) >= 0xD800 && (c) <= 0xDBFF)
   43  	#define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <= 0xDFFF)
   44  	
   45  	
   46 C	/* Additional file attribute bits for internal use */
   47  	#define AM_VOL		0x08	/* Volume label */
   48  	#define AM_LFN		0x0F	/* LFN entry */
   49  	#define AM_MASK		0x3F	/* Mask of defined bits */
   50  	
   51  	
   52 C	/* Additional file access control and file status flags for internal use */
   53  	#define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
   54  	#define FA_MODIFIED	0x40	/* File has been modified */
   55  	#define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
   56  	
   57  	
   58 C	/* Name status flags in fn[11] */
   59  	#define NSFLAG		11		/* Index of the name status byte */
   60  	#define NS_LOSS		0x01	/* Out of 8.3 format */
   61  	#define NS_LFN		0x02	/* Force to create LFN entry */
   62  	#define NS_LAST		0x04	/* Last segment */
   63  	#define NS_BODY		0x08	/* Lower case flag (body) */
   64  	#define NS_EXT		0x10	/* Lower case flag (ext) */
   65  	#define NS_DOT		0x20	/* Dot entry */
   66  	#define NS_NOLFN	0x40	/* Do not find LFN */
   67  	#define NS_NONAME	0x80	/* Not followed */
   68  	
   69  	
   70 C	/* Limits and boundaries */
   71  	#define MAX_DIR		0x200000		/* Max size of FAT directory */
   72  	#define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
   73  	#define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows behavior) */
   74  	#define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Windows behavior) */
   75  	#define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
   76  	#define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
   77  	
   78  	
   79 C	/* FatFs refers the FAT structure as simple byte array instead of structure member
   80 C	/ because the C structure is not binary compatible between different platforms */
   81 C	
   82  	#define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
   83  	#define BS_OEMName			3		/* OEM name (8-byte) */
   84  	#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
   85  	#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
   86  	#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
   87  	#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
   88  	#define BPB_RootEntCnt		17		/* Size of root directory area for FAT [entry] (WORD) */
   89  	#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
   90  	#define BPB_Media			21		/* Media descriptor byte (BYTE) */
   91  	#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
   92  	#define BPB_SecPerTrk		24		/* Number of sectors per track for int13h [sector] (WORD) */
   93  	#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
   94  	#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
   95  	#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
   96  	#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
   97  	#define BS_NTres			37		/* WindowsNT error flag (BYTE) */
   98  	#define BS_BootSig			38		/* Extended boot signature (BYTE) */
   99  	#define BS_VolID			39		/* Volume serial number (DWORD) */
  100  	#define BS_VolLab			43		/* Volume label string (8-byte) */
  101  	#define BS_FilSysType		54		/* Filesystem type string (8-byte) */
  102  	#define BS_BootCode			62		/* Boot code (448-byte) */
  103  	#define BS_55AA				510		/* Signature word (WORD) */
  104  	
  105  	#define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
  106  	#define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
  107  	#define BPB_FSVer32			42		/* FAT32: Filesystem version (WORD) */
  108  	#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
  109  	#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
  110  	#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
  111  	#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
  112  	#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
  113  	#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
  114  	#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
  115  	#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
  116  	#define BS_FilSysType32		82		/* FAT32: Filesystem type string (8-byte) */
  117  	#define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
  118  	
  119  	#define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
  120  	#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
  121  	#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
  122  	#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
  123  	#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
  124  	#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
  125  	#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
  126  	#define BPB_RootClusEx		96		/* exFAT: Root directory start cluster (DWORD) */
  127  	#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
  128  	#define BPB_FSVerEx			104		/* exFAT: Filesystem version (WORD) */
  129  	#define BPB_VolFlagEx		106		/* exFAT: Volume flags (WORD) */
  130  	#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in unit of byte (BYTE) */
  131  	#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in unit of sector (BYTE) */
  132  	#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
  133  	#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
  134  	#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
  135  	#define BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
  136  	#define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
  137  	
  138  	#define DIR_Name			0		/* Short file name (11-byte) */
  139  	#define DIR_Attr			11		/* Attribute (BYTE) */
  140  	#define DIR_NTres			12		/* Lower case flag (BYTE) */
  141  	#define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
  142  	#define DIR_CrtTime			14		/* Created time (DWORD) */
  143  	#define DIR_LstAccDate		18		/* Last accessed date (WORD) */
  144  	#define DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
  145  	#define DIR_ModTime			22		/* Modified time (DWORD) */
  146  	#define DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
  147  	#define DIR_FileSize		28		/* File size (DWORD) */
  148  	#define LDIR_Ord			0		/* LFN: LFN order and LLE flag (BYTE) */
  149  	#define LDIR_Attr			11		/* LFN: LFN attribute (BYTE) */
  150  	#define LDIR_Type			12		/* LFN: Entry type (BYTE) */
  151  	#define LDIR_Chksum			13		/* LFN: Checksum of the SFN (BYTE) */
  152  	#define LDIR_FstClusLO		26		/* LFN: MBZ field (WORD) */
  153  	#define XDIR_Type			0		/* exFAT: Type of exFAT directory entry (BYTE) */
  154  	#define XDIR_NumLabel		1		/* exFAT: Number of volume label characters (BYTE) */
  155  	#define XDIR_Label			2		/* exFAT: Volume label (11-WORD) */
  156  	#define XDIR_CaseSum		4		/* exFAT: Sum of case conversion table (DWORD) */
  157  	#define XDIR_NumSec			1		/* exFAT: Number of secondary entries (BYTE) */
  158  	#define XDIR_SetSum			2		/* exFAT: Sum of the set of directory entries (WORD) */
  159  	#define XDIR_Attr			4		/* exFAT: File attribute (WORD) */
  160  	#define XDIR_CrtTime		8		/* exFAT: Created time (DWORD) */
  161  	#define XDIR_ModTime		12		/* exFAT: Modified time (DWORD) */
  162  	#define XDIR_AccTime		16		/* exFAT: Last accessed time (DWORD) */
  163  	#define XDIR_CrtTime10		20		/* exFAT: Created time subsecond (BYTE) */
  164  	#define XDIR_ModTime10		21		/* exFAT: Modified time subsecond (BYTE) */
  165  	#define XDIR_CrtTZ			22		/* exFAT: Created timezone (BYTE) */
  166  	#define XDIR_ModTZ			23		/* exFAT: Modified timezone (BYTE) */
  167  	#define XDIR_AccTZ			24		/* exFAT: Last accessed timezone (BYTE) */
  168  	#define XDIR_GenFlags		33		/* exFAT: General secondary flags (BYTE) */
  169  	#define XDIR_NumName		35		/* exFAT: Number of file name characters (BYTE) */
  170  	#define XDIR_NameHash		36		/* exFAT: Hash of file name (WORD) */
  171  	#define XDIR_ValidFileSize	40		/* exFAT: Valid file size (QWORD) */
  172  	#define XDIR_FstClus		52		/* exFAT: First cluster of the file data (DWORD) */
  173  	#define XDIR_FileSize		56		/* exFAT: File/Directory size (QWORD) */
  174  	
  175  	#define SZDIRE				32		/* Size of a directory entry */
  176  	#define DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
  177  	#define RDDEM				0x05	/* Replacement of the character collides with DDEM */
  178  	#define LLEF				0x40	/* Last long entry flag in LDIR_Ord */
  179  	
  180  	#define FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
  181  	#define FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
  182  	#define FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
  183  	#define FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
  184  	
  185  	#define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
  186  	#define SZ_PTE				16		/* MBR: Size of a partition table entry */
  187  	#define PTE_Boot			0		/* MBR PTE: Boot indicator */
  188  	#define PTE_StHead			1		/* MBR PTE: Start head */
  189  	#define PTE_StSec			2		/* MBR PTE: Start sector */
  190  	#define PTE_StCyl			3		/* MBR PTE: Start cylinder */
  191  	#define PTE_System			4		/* MBR PTE: System ID */
  192  	#define PTE_EdHead			5		/* MBR PTE: End head */
  193  	#define PTE_EdSec			6		/* MBR PTE: End sector */
  194  	#define PTE_EdCyl			7		/* MBR PTE: End cylinder */
  195  	#define PTE_StLba			8		/* MBR PTE: Start in LBA */
  196  	#define PTE_SizLba			12		/* MBR PTE: Size in LBA */
  197  	
  198  	
  199 C	/* Post process on fatal error in the file operations */
  200  	#define ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
  201  	
  202  	
  203 C	/* Re-entrancy related */
  204  	#if FF_FS_REENTRANT
MacExp: #if 0
  205 X	#if FF_USE_LFN == 1
MacExp: #if 1 == 1
  206 X	#error Static LFN work area cannot be used at thread-safe configuration
  207 X	#endif
  208 X	#define LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
  209  	#else
  210  	#define LEAVE_FF(fs, res)	return res
  211  	#endif
  212  	
  213  	
  214 C	/* Definitions of volume - physical location conversion */
  215  	#if FF_MULTI_PARTITION
MacExp: #if 0
  216 X	#define LD2PD(vol) VolToPart[vol].pd	/* Get physical drive number */
  217 X	#define LD2PT(vol) VolToPart[vol].pt	/* Get partition index */
  218  	#else
  219  	#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
  220  	#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
  221  	#endif
  222  	
  223  	
  224 C	/* Definitions of sector size */
  225  	#if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MAX_SS != 4096) || (FF_MIN_SS != 512 && FF_MIN_SS != 1024 && FF_MIN_SS != 2048 && FF_MIN_SS != 4096)
MacExp: #if (512 < 512) || (512 != 512 && 512 != 1024 && 512 != 2048 && 512 != 4096) || (512 != 512 && 512 != 1024 && 512 != 2048 && 512 != 4096)
  226 X	#error Wrong sector size configuration
  227  	#endif
  228  	#if FF_MAX_SS == FF_MIN_SS
MacExp: #if 512 == 512
  229  	#define SS(fs)	((UINT)FF_MAX_SS)	/* Fixed sector size */
  230  	#else
  231 X	#define SS(fs)	((fs)->ssize)	/* Variable sector size */
  232  	#endif
  233  	
  234  	
  235 C	/* Timestamp */
  236  	#if FF_FS_NORTC == 1
MacExp: #if 0 == 1
  237 X	#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 1 || FF_NORTC_MDAY > 31
MacExp: #if 2018 < 1980 || 2018 > 2107 || 1 < 1 || 1 > 12 || 1 < 1 || 1 > 31
  238 X	#error Invalid FF_FS_NORTC settings
  239 X	#endif
  240 X	#define GET_FATTIME()	((DWORD)(FF_NORTC_YEAR - 1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_NORTC_MDAY << 16)
  241  	#else
  242  	#define GET_FATTIME()	get_fattime()
  243  	#endif
  244  	
  245  	
  246 C	/* File lock controls */
  247  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
  248 X	#if FF_FS_READONLY
MacExp: #if 0
  249 X	#error FF_FS_LOCK must be 0 at read-only configuration
  250 X	#endif
  251 X	typedef struct {
  252 X		FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
  253 X		DWORD clu;		/* Object ID 2, containing directory (0:root) */
  254 X		DWORD ofs;		/* Object ID 3, offset in the directory */
  255 X		WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
  256 X	} FILESEM;
  257  	#endif
  258  	
  259  	
  260 C	/* SBCS up-case tables (\x80-\xFF) */
  261  	#define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
  262  						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  263  						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  264  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  265  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  266  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  267  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  268  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  269  	#define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  270  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  271  						0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  272  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  273  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  274  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  275  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  276  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  277  	#define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  278  						0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
  279  						0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
  280  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  281  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  282  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  283  						0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  284  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  285  	#define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  286  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  287  						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  288  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  289  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  290  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
  291  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  292  						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
  293  	#define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
  294  						0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
  295  						0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  296  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  297  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  298  						0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  299  						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
  300  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  301  	#define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
  302  						0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
  303  						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  304  						0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  305  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  306  						0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
  307  						0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
  308  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  309  	#define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
  310  						0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
  311  						0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
  312  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
  313  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  314  						0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  315  						0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
  316  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
  317  	#define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
  318  						0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
  319  						0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
  320  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
  321  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  322  						0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
  323  						0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
  324  						0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
  325  	#define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
  326  						0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
  327  						0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  328  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  329  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  330  						0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  331  						0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
  332  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  333  	#define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
  334  						0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  335  						0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  336  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  337  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  338  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  339  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  340  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  341  	#define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
  342  						0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
  343  						0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  344  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  345  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  346  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  347  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  348  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  349  	#define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  350  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  351  						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  352  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  353  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  354  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  355  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  356  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  357  	#define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
  358  						0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
  359  						0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  360  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  361  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  362  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  363  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  364  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  365  	#define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
  366  						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  367  						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  368  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  369  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  370  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  371  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  372  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  373  	#define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
  374  						0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  375  						0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  376  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  377  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  378  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  379  						0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
  380  						0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  381  	#define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  382  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  383  						0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  384  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  385  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  386  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  387  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  388  						0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  389  	#define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
  390  						0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
  391  						0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
  392  						0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  393  						0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
  394  						0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
  395  						0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
  396  						0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
  397  	
  398  	
  399 C	/* DBCS code range |----- 1st byte -----|  |----------- 2nd byte -----------| */
  400  	#define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 0x7E, 0x80, 0xFC, 0x00, 0x00}
  401  	#define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00}
  402  	#define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 0x5A, 0x61, 0x7A, 0x81, 0xFE}
  403  	#define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0xA1, 0xFE, 0x00, 0x00}
  404  	
  405  	
  406 C	/* Macros for table definitions */
  407  	#define MERGE_2STR(a, b) a ## b
  408  	#define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)
  409  	
  410  	
  411  	
  412  	
  413 C	/*--------------------------------------------------------------------------
  414 C	
  415 C	   Module Private Work Area
  416 C	
  417 C	---------------------------------------------------------------------------*/
  418 C	/* Remark: Variables defined here without initial value shall be guaranteed
  419 C	/  zero/null at start-up. If not, the linker option or start-up routine is
  420 C	/  not compliance with C standard. */
  421 C	
  422 C	/*--------------------------------*/
  423 C	/* File/Volume controls           */
  424 C	/*--------------------------------*/
  425 C	
  426  	#if FF_VOLUMES < 1 || FF_VOLUMES > 10
MacExp: #if 1 < 1 || 1 > 10
  427 X	#error Wrong FF_VOLUMES setting
  428  	#endif
  429  	static FATFS* FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
MacExp: static FATFS* FatFs[1];	/* Pointer to the filesystem objects (logical drives) */
  430  	static WORD Fsid;					/* Filesystem mount ID */
  431  	
  432  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
  433  	static BYTE CurrVol;				/* Current drive */
  434  	#endif
  435  	
  436  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
  437 X	static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
  438  	#endif
  439  	
  440  	#if FF_STR_VOLUME_ID
MacExp: #if 0
  441 X	#ifdef FF_VOLUME_STRS
  442 X	static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};	/* Pre-defined volume ID */
  443 X	#endif
  444  	#endif
  445  	
  446  	
  447 C	/*--------------------------------*/
  448 C	/* LFN/Directory working buffer   */
  449 C	/*--------------------------------*/
  450 C	
  451  	#if FF_USE_LFN == 0		/* Non-LFN configuration */
MacExp: #if 1 == 0		/* Non-LFN configuration */
  452 X	#if FF_FS_EXFAT
MacExp: #if 0
  453 X	#error LFN must be enabled when enable exFAT
  454 X	#endif
  455 X	#define DEF_NAMBUF
  456 X	#define INIT_NAMBUF(fs)
  457 X	#define FREE_NAMBUF()
  458 X	#define LEAVE_MKFS(res)	return res
  459 X	
  460  	#else					/* LFN configurations */
  461  	#if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
MacExp: #if 255 < 12 || 255 > 255
  462 X	#error Wrong setting of FF_MAX_LFN
  463  	#endif
  464  	#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
MacExp: #if 255 < 12 || 12 < 12
  465 X	#error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
  466  	#endif
  467  	#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
MacExp: #if 0 < 0 || 0 > 3
  468 X	#error Wrong setting of FF_LFN_UNICODE
  469  	#endif
  470  	static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* FAT: Offset of LFN characters in the directory entry */
  471  	#define MAXDIRB(nc)	((nc + 44U) / 15 * SZDIRE)	/* exFAT: Size of directory entry block scratchpad buffer needed for the name length */
  472  	
  473  	#if FF_USE_LFN == 1		/* LFN enabled with static working buffer */
MacExp: #if 1 == 1		/* LFN enabled with static working buffer */
  474  	#if FF_FS_EXFAT
MacExp: #if 0
  475 X	static BYTE	DirBuf[MAXDIRB(FF_MAX_LFN)];	/* Directory entry block scratchpad buffer */
  476  	#endif
  477  	static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
MacExp: static WCHAR LfnBuf[255 + 1];		/* LFN working buffer */
  478  	#define DEF_NAMBUF
  479  	#define INIT_NAMBUF(fs)
  480  	#define FREE_NAMBUF()
  481  	#define LEAVE_MKFS(res)	return res
  482  	
  483  	#elif FF_USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
  484 X	#if FF_FS_EXFAT
MacExp: #if 0
  485 X	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];	/* LFN working buffer and directory entry block scratchpad buffer */
  486 X	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
  487 X	#define FREE_NAMBUF()
  488 X	#else
  489 X	#define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1];	/* LFN working buffer */
  490 X	#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
  491 X	#define FREE_NAMBUF()
  492 X	#endif
  493 X	#define LEAVE_MKFS(res)	return res
  494 X	
  495  	#elif FF_USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
  496 X	#if FF_FS_EXFAT
MacExp: #if 0
  497 X	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer and directory entry block scratchpad buffer */
  498 X	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+FF_MAX_LFN+1); }
  499 X	#define FREE_NAMBUF()	ff_memfree(lfn)
  500 X	#else
  501 X	#define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer */
  502 X	#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
  503 X	#define FREE_NAMBUF()	ff_memfree(lfn)
  504 X	#endif
  505 X	#define LEAVE_MKFS(res)	{ if (!work) ff_memfree(buf); return res; }
  506 X	#define MAX_MALLOC	0x8000	/* Must be >=FF_MAX_SS */
  507 X	
  508  	#else
  509 X	#error Wrong setting of FF_USE_LFN
  510 X	
  511  	#endif	/* FF_USE_LFN == 1 */
  512  	#endif	/* FF_USE_LFN == 0 */
  513  	
  514  	
  515  	
  516 C	/*--------------------------------*/
  517 C	/* Code conversion tables         */
  518 C	/*--------------------------------*/
  519 C	
  520  	#if FF_CODE_PAGE == 0		/* Run-time code page configuration */
MacExp: #if 437 == 0		/* Run-time code page configuration */
  521 X	#define CODEPAGE CodePage
  522 X	static WORD CodePage;	/* Current code page */
  523 X	static const BYTE *ExCvt, *DbcTbl;	/* Pointer to current SBCS up-case table and DBCS code range table below */
  524 X	static const BYTE Ct437[] = TBL_CT437;
  525 X	static const BYTE Ct720[] = TBL_CT720;
  526 X	static const BYTE Ct737[] = TBL_CT737;
  527 X	static const BYTE Ct771[] = TBL_CT771;
  528 X	static const BYTE Ct775[] = TBL_CT775;
  529 X	static const BYTE Ct850[] = TBL_CT850;
  530 X	static const BYTE Ct852[] = TBL_CT852;
  531 X	static const BYTE Ct855[] = TBL_CT855;
  532 X	static const BYTE Ct857[] = TBL_CT857;
  533 X	static const BYTE Ct860[] = TBL_CT860;
  534 X	static const BYTE Ct861[] = TBL_CT861;
  535 X	static const BYTE Ct862[] = TBL_CT862;
  536 X	static const BYTE Ct863[] = TBL_CT863;
  537 X	static const BYTE Ct864[] = TBL_CT864;
  538 X	static const BYTE Ct865[] = TBL_CT865;
  539 X	static const BYTE Ct866[] = TBL_CT866;
  540 X	static const BYTE Ct869[] = TBL_CT869;
  541 X	static const BYTE Dc932[] = TBL_DC932;
  542 X	static const BYTE Dc936[] = TBL_DC936;
  543 X	static const BYTE Dc949[] = TBL_DC949;
  544 X	static const BYTE Dc950[] = TBL_DC950;
  545 X	
  546  	#elif FF_CODE_PAGE < 900	/* Static code page configuration (SBCS) */
MacExp: #elif 437 < 900	/* Static code page configuration (SBCS) */
  547  	#define CODEPAGE FF_CODE_PAGE
  548  	static const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CODE_PAGE);
MacExp: static const BYTE ExCvt[] = {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, 0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF};
  549  	
  550  	#else					/* Static code page configuration (DBCS) */
  551 X	#define CODEPAGE FF_CODE_PAGE
  552 X	static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);
  553 X	
  554  	#endif
  555  	
  556  	
  557  	
  558  	
  559 C	/*--------------------------------------------------------------------------
  560 C	
  561 C	   Module Private Functions
  562 C	
  563 C	---------------------------------------------------------------------------*/
  564 C	
  565 C	
  566 C	/*-----------------------------------------------------------------------*/
  567 C	/* Load/Store multi-byte word in the FAT structure                       */
  568 C	/*-----------------------------------------------------------------------*/
  569 C	
  570  	static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
  571  	{
  572  		WORD rv;
  573  	
  574  		rv = ptr[1];
  575  		rv = rv << 8 | ptr[0];
  576  		return rv;
  577  	}
  578  	
  579  	static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
  580  	{
  581  		DWORD rv;
  582  	
  583  		rv = ptr[3];
  584  		rv = rv << 8 | ptr[2];
  585  		rv = rv << 8 | ptr[1];
  586  		rv = rv << 8 | ptr[0];
  587  		return rv;
  588  	}
  589  	
  590  	#if FF_FS_EXFAT
MacExp: #if 0
  591 X	static QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
  592 X	{
  593 X		QWORD rv;
  594 X	
  595 X		rv = ptr[7];
  596 X		rv = rv << 8 | ptr[6];
  597 X		rv = rv << 8 | ptr[5];
  598 X		rv = rv << 8 | ptr[4];
  599 X		rv = rv << 8 | ptr[3];
  600 X		rv = rv << 8 | ptr[2];
  601 X		rv = rv << 8 | ptr[1];
  602 X		rv = rv << 8 | ptr[0];
  603 X		return rv;
  604 X	}
  605  	#endif
  606  	
  607  	#if !FF_FS_READONLY
MacExp: #if !0
  608  	static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
  609  	{
  610  		*ptr++ = (BYTE)val; val >>= 8;
  611  		*ptr++ = (BYTE)val;
  612  	}
  613  	
  614  	static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
  615  	{
  616  		*ptr++ = (BYTE)val; val >>= 8;
  617  		*ptr++ = (BYTE)val; val >>= 8;
  618  		*ptr++ = (BYTE)val; val >>= 8;
  619  		*ptr++ = (BYTE)val;
  620  	}
  621  	
  622  	#if FF_FS_EXFAT
MacExp: #if 0
  623 X	static void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
  624 X	{
  625 X		*ptr++ = (BYTE)val; val >>= 8;
  626 X		*ptr++ = (BYTE)val; val >>= 8;
  627 X		*ptr++ = (BYTE)val; val >>= 8;
  628 X		*ptr++ = (BYTE)val; val >>= 8;
  629 X		*ptr++ = (BYTE)val; val >>= 8;
  630 X		*ptr++ = (BYTE)val; val >>= 8;
  631 X		*ptr++ = (BYTE)val; val >>= 8;
  632 X		*ptr++ = (BYTE)val;
  633 X	}
  634  	#endif
  635  	#endif	/* !FF_FS_READONLY */
  636  	
  637  	
  638  	
  639 C	/*-----------------------------------------------------------------------*/
  640 C	/* String functions                                                      */
  641 C	/*-----------------------------------------------------------------------*/
  642 C	
  643 C	/* Copy memory to memory */
  644  	static void mem_cpy (void* dst, const void* src, UINT cnt)
  645  	{
  646  		BYTE *d = (BYTE*)dst;
  647  		const BYTE *s = (const BYTE*)src;
  648  	
  649  		if (cnt != 0) {
  650  			do {
  651  				*d++ = *s++;
  652  			} while (--cnt);
  653  		}
  654  	}
  655  	
  656  	
  657 C	/* Fill memory block */
  658  	static void mem_set (void* dst, int val, UINT cnt)
  659  	{
  660  		BYTE *d = (BYTE*)dst;
  661  	
  662  		do {
  663  			*d++ = (BYTE)val;
  664  		} while (--cnt);
  665  	}
  666  	
  667  	
  668 C	/* Compare memory block */
  669  	static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
  670  	{
  671  		const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
  672  		int r = 0;
  673  	
  674  		do {
  675  			r = *d++ - *s++;
  676  		} while (--cnt && r == 0);
  677  	
  678  		return r;
  679  	}
  680  	
  681  	
  682 C	/* Check if chr is contained in the string */
  683  	static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
  684  	{
  685  		while (*str && *str != chr) str++;
  686  		return *str;
  687  	}
  688  	
  689  	
  690 C	/* Test if the character is DBC 1st byte */
  691  	static int dbc_1st (BYTE c)
  692  	{
  693  	#if FF_CODE_PAGE == 0		/* Variable code page */
MacExp: #if 437 == 0		/* Variable code page */
  694 X		if (DbcTbl && c >= DbcTbl[0]) {
  695 X			if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
  696 X			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
  697 X		}
  698  	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
MacExp: #elif 437 >= 900	/* DBCS fixed code page */
  699 X		if (c >= DbcTbl[0]) {
  700 X			if (c <= DbcTbl[1]) return 1;
  701 X			if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
  702 X		}
  703  	#else						/* SBCS fixed code page */
  704  		if (c != 0) return 0;	/* Always false */
  705  	#endif
  706  		return 0;
  707  	}
  708  	
  709  	
  710 C	/* Test if the character is DBC 2nd byte */
  711  	static int dbc_2nd (BYTE c)
  712  	{
  713  	#if FF_CODE_PAGE == 0		/* Variable code page */
MacExp: #if 437 == 0		/* Variable code page */
  714 X		if (DbcTbl && c >= DbcTbl[4]) {
  715 X			if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
  716 X			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
  717 X			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
  718 X		}
  719  	#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
MacExp: #elif 437 >= 900	/* DBCS fixed code page */
  720 X		if (c >= DbcTbl[4]) {
  721 X			if (c <= DbcTbl[5]) return 1;
  722 X			if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
  723 X			if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
  724 X		}
  725  	#else						/* SBCS fixed code page */
  726  		if (c != 0) return 0;	/* Always false */
  727  	#endif
  728  		return 0;
  729  	}
  730  	
  731  	
  732  	#if FF_USE_LFN
MacExp: #if 1
  733  	
  734 C	/* Get a character from TCHAR string in defined API encodeing */
  735  	static DWORD tchar2uni (	/* Returns character in UTF-16 encoding (>=0x10000 on double encoding unit, 0xFFFFFFFF on decode error) */
  736  		const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
  737  	)
  738  	{
  739  		DWORD uc;
  740  		const TCHAR *p = *str;
  741  	
  742  	#if FF_LFN_UNICODE == 1		/* UTF-16 input */
MacExp: #if 0 == 1		/* UTF-16 input */
  743 X		WCHAR wc;
  744 X	
  745 X		uc = *p++;	/* Get a unit */
  746 X		if (IsSurrogate(uc)) {	/* Surrogate? */
  747 X			wc = *p++;		/* Get low surrogate */
  748 X			if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;	/* Wrong surrogate? */
  749 X			uc = uc << 16 | wc;
  750 X		}
  751 X	
  752  	#elif FF_LFN_UNICODE == 2	/* UTF-8 input */
MacExp: #elif 0 == 2	/* UTF-8 input */
  753 X		BYTE b;
  754 X		int nf;
  755 X	
  756 X		uc = (BYTE)*p++;	/* Get a unit */
  757 X		if (uc & 0x80) {	/* Multiple byte code? */
  758 X			if ((uc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
  759 X				uc &= 0x1F; nf = 1;
  760 X			} else {
  761 X				if ((uc & 0xF0) == 0xE0) {	/* 3-byte sequence? */
  762 X					uc &= 0x0F; nf = 2;
  763 X				} else {
  764 X					if ((uc & 0xF8) == 0xF0) {	/* 4-byte sequence? */
  765 X						uc &= 0x07; nf = 3;
  766 X					} else {					/* Wrong sequence */
  767 X						return 0xFFFFFFFF;
  768 X					}
  769 X				}
  770 X			}
  771 X			do {	/* Get trailing bytes */
  772 X				b = (BYTE)*p++;
  773 X				if ((b & 0xC0) != 0x80) return 0xFFFFFFFF;	/* Wrong sequence? */
  774 X				uc = uc << 6 | (b & 0x3F);
  775 X			} while (--nf != 0);
  776 X			if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
  777 X			if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
  778 X		}
  779 X	
  780  	#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
MacExp: #elif 0 == 3	/* UTF-32 input */
  781 X		uc = (TCHAR)*p++;	/* Get a unit */
  782 X		if (uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
  783 X		if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
  784 X	
  785  	#else		/* ANSI/OEM input */
  786  		BYTE b;
  787  		WCHAR wc;
  788  	
  789  		wc = (BYTE)*p++;			/* Get a byte */
  790  		if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1st byte? */
  791  			b = (BYTE)*p++;			/* Get 2nd byte */
  792  			if (!dbc_2nd(b)) return 0xFFFFFFFF;	/* Invalid code? */
  793  			wc = (wc << 8) + b;		/* Make a DBC */
  794  		}
  795  		if (wc != 0) {
  796  			wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
MacExp: 		wc = ff_oem2uni(wc, 437);	/* ANSI/OEM ==> Unicode */
  797  			if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
  798  		}
  799  		uc = wc;
  800  	
  801  	#endif
  802  		*str = p;	/* Next read pointer */
  803  		return uc;
  804  	}
  805  	
  806  	
  807 C	/* Output a TCHAR string in defined API encoding */
  808  	static BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
  809  		DWORD chr,	/* UTF-16 encoded character (Double encoding unit char if >=0x10000) */
  810  		TCHAR* buf,	/* Output buffer */
  811  		UINT szb	/* Size of the buffer */
  812  	)
  813  	{
  814  	#if FF_LFN_UNICODE == 1	/* UTF-16 output */
MacExp: #if 0 == 1	/* UTF-16 output */
  815 X		WCHAR hs, wc;
  816 X	
  817 X		hs = (WCHAR)(chr >> 16);
  818 X		wc = (WCHAR)chr;
  819 X		if (hs == 0) {	/* Single encoding unit? */
  820 X			if (szb < 1 || IsSurrogate(wc)) return 0;	/* Buffer overflow or wrong code? */
  821 X			*buf = wc;
  822 X			return 1;
  823 X		}
  824 X		if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogateL(wc)) return 0;	/* Buffer overflow or wrong surrogate? */
  825 X		*buf++ = hs;
  826 X		*buf++ = wc;
  827 X		return 2;
  828 X	
  829  	#elif FF_LFN_UNICODE == 2	/* UTF-8 output */
MacExp: #elif 0 == 2	/* UTF-8 output */
  830 X		DWORD hc;
  831 X	
  832 X		if (chr < 0x80) {	/* Single byte code? */
  833 X			if (szb < 1) return 0;	/* Buffer overflow? */
  834 X			*buf = (TCHAR)chr;
  835 X			return 1;
  836 X		}
  837 X		if (chr < 0x800) {	/* 2-byte sequence? */
  838 X			if (szb < 2) return 0;	/* Buffer overflow? */
  839 X			*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
  840 X			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
  841 X			return 2;
  842 X		}
  843 X		if (chr < 0x10000) {	/* 3-byte sequence? */
  844 X			if (szb < 3 || IsSurrogate(chr)) return 0;	/* Buffer overflow or wrong code? */
  845 X			*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
  846 X			*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
  847 X			*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
  848 X			return 3;
  849 X		}
  850 X		/* 4-byte sequence */
  851 X		if (szb < 4) return 0;	/* Buffer overflow? */
  852 X		hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
  853 X		chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
  854 X		if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
  855 X		chr = (hc | chr) + 0x10000;
  856 X		*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
  857 X		*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
  858 X		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
  859 X		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
  860 X		return 4;
  861 X	
  862  	#elif FF_LFN_UNICODE == 3	/* UTF-32 output */
MacExp: #elif 0 == 3	/* UTF-32 output */
  863 X		DWORD hc;
  864 X	
  865 X		if (szb < 1) return 0;	/* Buffer overflow? */
  866 X		if (chr >= 0x10000) {	/* Out of BMP? */
  867 X			hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
  868 X			chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
  869 X			if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
  870 X			chr = (hc | chr) + 0x10000;
  871 X		}
  872 X		*buf++ = (TCHAR)chr;
  873 X		return 1;
  874 X	
  875  	#else						/* ANSI/OEM output */
  876  		WCHAR wc;
  877  	
  878  		wc = ff_uni2oem(chr, CODEPAGE);
MacExp: 	wc = ff_uni2oem(chr, 437);
  879  		if (wc >= 0x100) {	/* Is this a DBC? */
  880  			if (szb < 2) return 0;
  881  			*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
  882  			*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
  883  			return 2;
  884  		}
  885  		if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
  886  		*buf++ = (TCHAR)wc;					/* Store the character */
  887  		return 1;
  888  	#endif
  889  	}
  890  	#endif	/* FF_USE_LFN */
  891  	
  892  	
  893  	#if FF_FS_REENTRANT
MacExp: #if 0
  894 X	/*-----------------------------------------------------------------------*/
  895 X	/* Request/Release grant to access the volume                            */
  896 X	/*-----------------------------------------------------------------------*/
  897 X	static int lock_fs (		/* 1:Ok, 0:timeout */
  898 X		FATFS* fs		/* Filesystem object */
  899 X	)
  900 X	{
  901 X		return ff_req_grant(fs->sobj);
  902 X	}
  903 X	
  904 X	
  905 X	static void unlock_fs (
  906 X		FATFS* fs,		/* Filesystem object */
  907 X		FRESULT res		/* Result code to be returned */
  908 X	)
  909 X	{
  910 X		if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
  911 X			ff_rel_grant(fs->sobj);
  912 X		}
  913 X	}
  914 X	
  915  	#endif
  916  	
  917  	
  918  	
  919  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
  920 X	/*-----------------------------------------------------------------------*/
  921 X	/* File lock control functions                                           */
  922 X	/*-----------------------------------------------------------------------*/
  923 X	
  924 X	static FRESULT chk_lock (	/* Check if the file can be accessed */
  925 X		DIR* dp,		/* Directory object pointing the file to be checked */
  926 X		int acc			/* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
  927 X	)
  928 X	{
  929 X		UINT i, be;
  930 X	
  931 X		/* Search open object table for the object */
  932 X		be = 0;
  933 X		for (i = 0; i < FF_FS_LOCK; i++) {
  934 X			if (Files[i].fs) {	/* Existing entry */
  935 X				if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matches with an open object */
  936 X					Files[i].clu == dp->obj.sclust &&
  937 X					Files[i].ofs == dp->dptr) break;
  938 X			} else {			/* Blank entry */
  939 X				be = 1;
  940 X			}
  941 X		}
  942 X		if (i == FF_FS_LOCK) {	/* The object has not been opened */
  943 X			return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new object? */
  944 X		}
  945 X	
  946 X		/* The object was opened. Reject any open against writing file and all write mode open */
  947 X		return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  948 X	}
  949 X	
  950 X	
  951 X	static int enq_lock (void)	/* Check if an entry is available for a new object */
  952 X	{
  953 X		UINT i;
  954 X	
  955 X		for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
  956 X		return (i == FF_FS_LOCK) ? 0 : 1;
  957 X	}
  958 X	
  959 X	
  960 X	static UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
  961 X		DIR* dp,	/* Directory object pointing the file to register or increment */
  962 X		int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
  963 X	)
  964 X	{
  965 X		UINT i;
  966 X	
  967 X	
  968 X		for (i = 0; i < FF_FS_LOCK; i++) {	/* Find the object */
  969 X			if (Files[i].fs == dp->obj.fs &&
  970 X				Files[i].clu == dp->obj.sclust &&
  971 X				Files[i].ofs == dp->dptr) break;
  972 X		}
  973 X	
  974 X		if (i == FF_FS_LOCK) {				/* Not opened. Register it as new. */
  975 X			for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
  976 X			if (i == FF_FS_LOCK) return 0;	/* No free entry to register (int err) */
  977 X			Files[i].fs = dp->obj.fs;
  978 X			Files[i].clu = dp->obj.sclust;
  979 X			Files[i].ofs = dp->dptr;
  980 X			Files[i].ctr = 0;
  981 X		}
  982 X	
  983 X		if (acc >= 1 && Files[i].ctr) return 0;	/* Access violation (int err) */
  984 X	
  985 X		Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  986 X	
  987 X		return i + 1;	/* Index number origin from 1 */
  988 X	}
  989 X	
  990 X	
  991 X	static FRESULT dec_lock (	/* Decrement object open counter */
  992 X		UINT i			/* Semaphore index (1..) */
  993 X	)
  994 X	{
  995 X		WORD n;
  996 X		FRESULT res;
  997 X	
  998 X	
  999 X		if (--i < FF_FS_LOCK) {	/* Index number origin from 0 */
 1000 X			n = Files[i].ctr;
 1001 X			if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 1002 X			if (n > 0) n--;				/* Decrement read mode open count */
 1003 X			Files[i].ctr = n;
 1004 X			if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 1005 X			res = FR_OK;
 1006 X		} else {
 1007 X			res = FR_INT_ERR;			/* Invalid index nunber */
 1008 X		}
 1009 X		return res;
 1010 X	}
 1011 X	
 1012 X	
 1013 X	static void clear_lock (	/* Clear lock entries of the volume */
 1014 X		FATFS *fs
 1015 X	)
 1016 X	{
 1017 X		UINT i;
 1018 X	
 1019 X		for (i = 0; i < FF_FS_LOCK; i++) {
 1020 X			if (Files[i].fs == fs) Files[i].fs = 0;
 1021 X		}
 1022 X	}
 1023 X	
 1024  	#endif	/* FF_FS_LOCK != 0 */
 1025  	
 1026  	
 1027  	
 1028 C	/*-----------------------------------------------------------------------*/
 1029 C	/* Move/Flush disk access window in the filesystem object                */
 1030 C	/*-----------------------------------------------------------------------*/
 1031  	#if !FF_FS_READONLY
MacExp: #if !0
 1032  	static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 1033  		FATFS* fs			/* Filesystem object */
 1034  	)
 1035  	{
 1036  		FRESULT res = FR_OK;
 1037  	
 1038  	
 1039  		if (fs->wflag) {	/* Is the disk access window dirty */
 1040  			if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 1041  				fs->wflag = 0;	/* Clear window dirty flag */
 1042  				if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 1043  					if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 1044  				}
 1045  			} else {
 1046  				res = FR_DISK_ERR;
 1047  			}
 1048  		}
 1049  		return res;
 1050  	}
 1051  	#endif
 1052  	
 1053  	
 1054  	static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 1055  		FATFS* fs,			/* Filesystem object */
 1056  		DWORD sector		/* Sector number to make appearance in the fs->win[] */
 1057  	)
 1058  	{
 1059  		FRESULT res = FR_OK;
 1060  	
 1061  	
 1062  		if (sector != fs->winsect) {	/* Window offset changed? */
 1063  	#if !FF_FS_READONLY
MacExp: #if !0
 1064  			res = sync_window(fs);		/* Write-back changes */
 1065  	#endif
 1066  			if (res == FR_OK) {			/* Fill sector window with new data */
 1067  				if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
 1068  					sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
 1069  					res = FR_DISK_ERR;
 1070  				}
 1071  				fs->winsect = sector;
 1072  			}
 1073  		}
 1074  		return res;
 1075  	}
 1076  	
 1077  	
 1078  	
 1079  	
 1080  	#if !FF_FS_READONLY
MacExp: #if !0
 1081 C	/*-----------------------------------------------------------------------*/
 1082 C	/* Synchronize filesystem and data on the storage                        */
 1083 C	/*-----------------------------------------------------------------------*/
 1084 C	
 1085  	static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
 1086  		FATFS* fs		/* Filesystem object */
 1087  	)
 1088  	{
 1089  		FRESULT res;
 1090  	
 1091  	
 1092  		res = sync_window(fs);
 1093  		if (res == FR_OK) {
 1094  			if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
MacExp: 		if (fs->fs_type == 3 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 1095 C				/* Create FSInfo structure */
 1096  				mem_set(fs->win, 0, SS(fs));
MacExp: 			mem_set(fs->win, 0, ((UINT)512));
 1097  				st_word(fs->win + BS_55AA, 0xAA55);
MacExp: 			st_word(fs->win + 510, 0xAA55);
 1098  				st_dword(fs->win + FSI_LeadSig, 0x41615252);
MacExp: 			st_dword(fs->win + 0, 0x41615252);
 1099  				st_dword(fs->win + FSI_StrucSig, 0x61417272);
MacExp: 			st_dword(fs->win + 484, 0x61417272);
 1100  				st_dword(fs->win + FSI_Free_Count, fs->free_clst);
MacExp: 			st_dword(fs->win + 488, fs->free_clst);
 1101  				st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
MacExp: 			st_dword(fs->win + 492, fs->last_clst);
 1102 C				/* Write it into the FSInfo sector */
 1103  				fs->winsect = fs->volbase + 1;
 1104  				disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 1105  				fs->fsi_flag = 0;
 1106  			}
 1107 C			/* Make sure that no pending write process in the lower layer */
 1108  			if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
MacExp: 		if (disk_ioctl(fs->pdrv, 0, 0) != RES_OK) res = FR_DISK_ERR;
 1109  		}
 1110  	
 1111  		return res;
 1112  	}
 1113  	
 1114  	#endif
 1115  	
 1116  	
 1117  	
 1118 C	/*-----------------------------------------------------------------------*/
 1119 C	/* Get physical sector number from cluster number                        */
 1120 C	/*-----------------------------------------------------------------------*/
 1121 C	
 1122  	static DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
 1123  		FATFS* fs,		/* Filesystem object */
 1124  		DWORD clst		/* Cluster# to be converted */
 1125  	)
 1126  	{
 1127  		clst -= 2;		/* Cluster number is origin from 2 */
 1128  		if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 1129  		return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 1130  	}
 1131  	
 1132  	
 1133  	
 1134  	
 1135 C	/*-----------------------------------------------------------------------*/
 1136 C	/* FAT access - Read value of a FAT entry                                */
 1137 C	/*-----------------------------------------------------------------------*/
 1138 C	
 1139  	static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 1140  		FFOBJID* obj,	/* Corresponding object */
 1141  		DWORD clst		/* Cluster number to get the value */
 1142  	)
 1143  	{
 1144  		UINT wc, bc;
 1145  		DWORD val;
 1146  		FATFS *fs = obj->fs;
 1147  	
 1148  	
 1149  		if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 1150  			val = 1;	/* Internal error */
 1151  	
 1152  		} else {
 1153  			val = 0xFFFFFFFF;	/* Default value falls on disk error */
 1154  	
 1155  			switch (fs->fs_type) {
 1156  			case FS_FAT12 :
MacExp: 		case 1 :
 1157  				bc = (UINT)clst; bc += bc / 2;
 1158  				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
MacExp: 			if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
 1159  				wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
MacExp: 			wc = fs->win[bc++ % ((UINT)512)];		/* Get 1st byte of the entry */
 1160  				if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
MacExp: 			if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
 1161  				wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
MacExp: 			wc |= fs->win[bc % ((UINT)512)] << 8;	/* Merge 2nd byte of the entry */
 1162  				val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 1163  				break;
 1164  	
 1165  			case FS_FAT16 :
MacExp: 		case 2 :
 1166  				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
MacExp: 			if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2))) != FR_OK) break;
 1167  				val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
MacExp: 			val = ld_word(fs->win + clst * 2 % ((UINT)512));		/* Simple WORD array */
 1168  				break;
 1169  	
 1170  			case FS_FAT32 :
MacExp: 		case 3 :
 1171  				if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
MacExp: 			if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4))) != FR_OK) break;
 1172  				val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
MacExp: 			val = ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 1173  				break;
 1174  	#if FF_FS_EXFAT
MacExp: #if 0
 1175 X			case FS_EXFAT :
 1176 X				if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
 1177 X					DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 1178 X					DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 1179 X	
 1180 X					if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 1181 X						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
 1182 X						break;
 1183 X					}
 1184 X					if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 1185 X						val = clst + 1; 	/* Generate the value */
 1186 X						break;
 1187 X					}
 1188 X					if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
 1189 X						if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 1190 X							val = 0x7FFFFFFF;	/* Generate EOC */
 1191 X						} else {
 1192 X							if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 1193 X							val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 1194 X						}
 1195 X						break;
 1196 X					}
 1197 X				}
 1198 X				/* go to default */
 1199  	#endif
 1200  			default:
 1201  				val = 1;	/* Internal error */
 1202  			}
 1203  		}
 1204  	
 1205  		return val;
 1206  	}
 1207  	
 1208  	
 1209  	
 1210  	
 1211  	#if !FF_FS_READONLY
MacExp: #if !0
 1212 C	/*-----------------------------------------------------------------------*/
 1213 C	/* FAT access - Change value of a FAT entry                              */
 1214 C	/*-----------------------------------------------------------------------*/
 1215 C	
 1216  	static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 1217  		FATFS* fs,		/* Corresponding filesystem object */
 1218  		DWORD clst,		/* FAT index number (cluster number) to be changed */
 1219  		DWORD val		/* New value to be set to the entry */
 1220  	)
 1221  	{
 1222  		UINT bc;
 1223  		BYTE *p;
 1224  		FRESULT res = FR_INT_ERR;
 1225  	
 1226  	
 1227  		if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 1228  			switch (fs->fs_type) {
 1229  			case FS_FAT12 :
MacExp: 		case 1 :
 1230  				bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 1231  				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
MacExp: 			res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
 1232  				if (res != FR_OK) break;
 1233  				p = fs->win + bc++ % SS(fs);
MacExp: 			p = fs->win + bc++ % ((UINT)512);
 1234  				*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 1235  				fs->wflag = 1;
 1236  				res = move_window(fs, fs->fatbase + (bc / SS(fs)));
MacExp: 			res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
 1237  				if (res != FR_OK) break;
 1238  				p = fs->win + bc % SS(fs);
MacExp: 			p = fs->win + bc % ((UINT)512);
 1239  				*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 1240  				fs->wflag = 1;
 1241  				break;
 1242  	
 1243  			case FS_FAT16 :
MacExp: 		case 2 :
 1244  				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
MacExp: 			res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)));
 1245  				if (res != FR_OK) break;
 1246  				st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
MacExp: 			st_word(fs->win + clst * 2 % ((UINT)512), (WORD)val);	/* Simple WORD array */
 1247  				fs->wflag = 1;
 1248  				break;
 1249  	
 1250  			case FS_FAT32 :
MacExp: 		case 3 :
 1251  	#if FF_FS_EXFAT
MacExp: #if 0
 1252 X			case FS_EXFAT :
 1253  	#endif
 1254  				res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
MacExp: 			res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)));
 1255  				if (res != FR_OK) break;
 1256  				if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
MacExp: 			if (!0 || fs->fs_type != 4) {
 1257  					val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
MacExp: 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0xF0000000);
 1258  				}
 1259  				st_dword(fs->win + clst * 4 % SS(fs), val);
MacExp: 			st_dword(fs->win + clst * 4 % ((UINT)512), val);
 1260  				fs->wflag = 1;
 1261  				break;
 1262  			}
 1263  		}
 1264  		return res;
 1265  	}
 1266  	
 1267  	#endif /* !FF_FS_READONLY */
 1268  	
 1269  	
 1270  	
 1271  	
 1272  	#if FF_FS_EXFAT && !FF_FS_READONLY
MacExp: #if 0 && !0
 1273 X	/*-----------------------------------------------------------------------*/
 1274 X	/* exFAT: Accessing FAT and Allocation Bitmap                            */
 1275 X	/*-----------------------------------------------------------------------*/
 1276 X	
 1277 X	/*--------------------------------------*/
 1278 X	/* Find a contiguous free cluster block */
 1279 X	/*--------------------------------------*/
 1280 X	
 1281 X	static DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
 1282 X		FATFS* fs,	/* Filesystem object */
 1283 X		DWORD clst,	/* Cluster number to scan from */
 1284 X		DWORD ncl	/* Number of contiguous clusters to find (1..) */
 1285 X	)
 1286 X	{
 1287 X		BYTE bm, bv;
 1288 X		UINT i;
 1289 X		DWORD val, scl, ctr;
 1290 X	
 1291 X	
 1292 X		clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
 1293 X		if (clst >= fs->n_fatent - 2) clst = 0;
 1294 X		scl = val = clst; ctr = 0;
 1295 X		while (1) {
 1296 X			if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
 1297 X			i = val / 8 % SS(fs); bm = 1 << (val % 8);
 1298 X			do {
 1299 X				do {
 1300 X					bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 1301 X					if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 1302 X						val = 0; bm = 0; i = SS(fs);
 1303 X					}
 1304 X					if (bv == 0) {	/* Is it a free cluster? */
 1305 X						if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
 1306 X					} else {
 1307 X						scl = val; ctr = 0;		/* Encountered a cluster in-use, restart to scan */
 1308 X					}
 1309 X					if (val == clst) return 0;	/* All cluster scanned? */
 1310 X				} while (bm != 0);
 1311 X				bm = 1;
 1312 X			} while (++i < SS(fs));
 1313 X		}
 1314 X	}
 1315 X	
 1316 X	
 1317 X	/*----------------------------------------*/
 1318 X	/* Set/Clear a block of allocation bitmap */
 1319 X	/*----------------------------------------*/
 1320 X	
 1321 X	static FRESULT change_bitmap (
 1322 X		FATFS* fs,	/* Filesystem object */
 1323 X		DWORD clst,	/* Cluster number to change from */
 1324 X		DWORD ncl,	/* Number of clusters to be changed */
 1325 X		int bv		/* bit value to be set (0 or 1) */
 1326 X	)
 1327 X	{
 1328 X		BYTE bm;
 1329 X		UINT i;
 1330 X		DWORD sect;
 1331 X	
 1332 X	
 1333 X		clst -= 2;	/* The first bit corresponds to cluster #2 */
 1334 X		sect = fs->database + clst / 8 / SS(fs);	/* Sector address (assuming bitmap is located top of the cluster heap) */
 1335 X		i = clst / 8 % SS(fs);						/* Byte offset in the sector */
 1336 X		bm = 1 << (clst % 8);						/* Bit mask in the byte */
 1337 X		while (1) {
 1338 X			if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 1339 X			do {
 1340 X				do {
 1341 X					if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 1342 X					fs->win[i] ^= bm;	/* Flip the bit */
 1343 X					fs->wflag = 1;
 1344 X					if (--ncl == 0) return FR_OK;	/* All bits processed? */
 1345 X				} while (bm <<= 1);		/* Next bit */
 1346 X				bm = 1;
 1347 X			} while (++i < SS(fs));		/* Next byte */
 1348 X			i = 0;
 1349 X		}
 1350 X	}
 1351 X	
 1352 X	
 1353 X	/*---------------------------------------------*/
 1354 X	/* Fill the first fragment of the FAT chain    */
 1355 X	/*---------------------------------------------*/
 1356 X	
 1357 X	static FRESULT fill_first_frag (
 1358 X		FFOBJID* obj	/* Pointer to the corresponding object */
 1359 X	)
 1360 X	{
 1361 X		FRESULT res;
 1362 X		DWORD cl, n;
 1363 X	
 1364 X	
 1365 X		if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
 1366 X			for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 1367 X				res = put_fat(obj->fs, cl, cl + 1);
 1368 X				if (res != FR_OK) return res;
 1369 X			}
 1370 X			obj->stat = 0;	/* Change status 'FAT chain is valid' */
 1371 X		}
 1372 X		return FR_OK;
 1373 X	}
 1374 X	
 1375 X	
 1376 X	/*---------------------------------------------*/
 1377 X	/* Fill the last fragment of the FAT chain     */
 1378 X	/*---------------------------------------------*/
 1379 X	
 1380 X	static FRESULT fill_last_frag (
 1381 X		FFOBJID* obj,	/* Pointer to the corresponding object */
 1382 X		DWORD lcl,		/* Last cluster of the fragment */
 1383 X		DWORD term		/* Value to set the last FAT entry */
 1384 X	)
 1385 X	{
 1386 X		FRESULT res;
 1387 X	
 1388 X	
 1389 X		while (obj->n_frag > 0) {	/* Create the chain of last fragment */
 1390 X			res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
 1391 X			if (res != FR_OK) return res;
 1392 X			obj->n_frag--;
 1393 X		}
 1394 X		return FR_OK;
 1395 X	}
 1396 X	
 1397  	#endif	/* FF_FS_EXFAT && !FF_FS_READONLY */
 1398  	
 1399  	
 1400  	
 1401  	#if !FF_FS_READONLY
MacExp: #if !0
 1402 C	/*-----------------------------------------------------------------------*/
 1403 C	/* FAT handling - Remove a cluster chain                                 */
 1404 C	/*-----------------------------------------------------------------------*/
 1405 C	
 1406  	static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
 1407  		FFOBJID* obj,		/* Corresponding object */
 1408  		DWORD clst,			/* Cluster to remove a chain from */
 1409  		DWORD pclst			/* Previous cluster of clst (0:entire chain) */
 1410  	)
 1411  	{
 1412  		FRESULT res = FR_OK;
 1413  		DWORD nxt;
 1414  		FATFS *fs = obj->fs;
 1415  	#if FF_FS_EXFAT || FF_USE_TRIM
MacExp: #if 0 || 0
 1416 X		DWORD scl = clst, ecl = clst;
 1417  	#endif
 1418  	#if FF_USE_TRIM
MacExp: #if 0
 1419 X		DWORD rt[2];
 1420  	#endif
 1421  	
 1422  		if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 1423  	
 1424 C		/* Mark the previous cluster 'EOC' on the FAT if it exists */
 1425  		if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
MacExp: 	if (pclst != 0 && (!0 || fs->fs_type != 4 || obj->stat != 2)) {
 1426  			res = put_fat(fs, pclst, 0xFFFFFFFF);
 1427  			if (res != FR_OK) return res;
 1428  		}
 1429  	
 1430 C		/* Remove the chain */
 1431  		do {
 1432  			nxt = get_fat(obj, clst);			/* Get cluster status */
 1433  			if (nxt == 0) break;				/* Empty cluster? */
 1434  			if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 1435  			if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 1436  			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
MacExp: 		if (!0 || fs->fs_type != 4) {
 1437  				res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 1438  				if (res != FR_OK) return res;
 1439  			}
 1440  			if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 1441  				fs->free_clst++;
 1442  				fs->fsi_flag |= 1;
 1443  			}
 1444  	#if FF_FS_EXFAT || FF_USE_TRIM
MacExp: #if 0 || 0
 1445 X			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 1446 X				ecl = nxt;
 1447 X			} else {				/* End of contiguous cluster block */
 1448 X	#if FF_FS_EXFAT
MacExp: #if 0
 1449 X				if (fs->fs_type == FS_EXFAT) {
 1450 X					res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
 1451 X					if (res != FR_OK) return res;
 1452 X				}
 1453 X	#endif
 1454 X	#if FF_USE_TRIM
MacExp: #if 0
 1455 X				rt[0] = clst2sect(fs, scl);					/* Start of data area freed */
 1456 X				rt[1] = clst2sect(fs, ecl) + fs->csize - 1;	/* End of data area freed */
 1457 X				disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform device the data in the block is no longer needed */
 1458 X	#endif
 1459 X				scl = ecl = nxt;
 1460 X			}
 1461  	#endif
 1462  			clst = nxt;					/* Next cluster */
 1463  		} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 1464  	
 1465  	#if FF_FS_EXFAT
MacExp: #if 0
 1466 X		/* Some post processes for chain status */
 1467 X		if (fs->fs_type == FS_EXFAT) {
 1468 X			if (pclst == 0) {	/* Has the entire chain been removed? */
 1469 X				obj->stat = 0;		/* Change the chain status 'initial' */
 1470 X			} else {
 1471 X				if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
 1472 X					clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
 1473 X					while (clst != pclst) {
 1474 X						nxt = get_fat(obj, clst);
 1475 X						if (nxt < 2) return FR_INT_ERR;
 1476 X						if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
 1477 X						if (nxt != clst + 1) break;	/* Not contiguous? */
 1478 X						clst++;
 1479 X					}
 1480 X					if (clst == pclst) {	/* Has the chain got contiguous again? */
 1481 X						obj->stat = 2;		/* Change the chain status 'contiguous' */
 1482 X					}
 1483 X				} else {
 1484 X					if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the chain fragmented in this session and got contiguous again? */
 1485 X						obj->stat = 2;	/* Change the chain status 'contiguous' */
 1486 X					}
 1487 X				}
 1488 X			}
 1489 X		}
 1490  	#endif
 1491  		return FR_OK;
 1492  	}
 1493  	
 1494  	
 1495  	
 1496  	
 1497 C	/*-----------------------------------------------------------------------*/
 1498 C	/* FAT handling - Stretch a chain or Create a new chain                  */
 1499 C	/*-----------------------------------------------------------------------*/
 1500 C	
 1501  	static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
 1502  		FFOBJID* obj,		/* Corresponding object */
 1503  		DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
 1504  	)
 1505  	{
 1506  		DWORD cs, ncl, scl;
 1507  		FRESULT res;
 1508  		FATFS *fs = obj->fs;
 1509  	
 1510  	
 1511  		if (clst == 0) {	/* Create a new chain */
 1512  			scl = fs->last_clst;				/* Suggested cluster to start to find */
 1513  			if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 1514  		}
 1515  		else {				/* Stretch a chain */
 1516  			cs = get_fat(obj, clst);			/* Check the cluster status */
 1517  			if (cs < 2) return 1;				/* Test for insanity */
 1518  			if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 1519  			if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 1520  			scl = clst;							/* Cluster to start to find */
 1521  		}
 1522  		if (fs->free_clst == 0) return 0;		/* No free cluster */
 1523  	
 1524  	#if FF_FS_EXFAT
MacExp: #if 0
 1525 X		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 1526 X			ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
 1527 X			if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
 1528 X			res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
 1529 X			if (res == FR_INT_ERR) return 1;
 1530 X			if (res == FR_DISK_ERR) return 0xFFFFFFFF;
 1531 X			if (clst == 0) {							/* Is it a new chain? */
 1532 X				obj->stat = 2;							/* Set status 'contiguous' */
 1533 X			} else {									/* It is a stretched chain */
 1534 X				if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 1535 X					obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
 1536 X					obj->stat = 3;						/* Change status 'just fragmented' */
 1537 X				}
 1538 X			}
 1539 X			if (obj->stat != 2) {	/* Is the file non-contiguous? */
 1540 X				if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 1541 X					obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 1542 X				} else {				/* New fragment */
 1543 X					if (obj->n_frag == 0) obj->n_frag = 1;
 1544 X					res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
 1545 X					if (res == FR_OK) obj->n_frag = 1;
 1546 X				}
 1547 X			}
 1548 X		} else
 1549  	#endif
 1550  		{	/* On the FAT/FAT32 volume */
 1551  			ncl = 0;
 1552  			if (scl == clst) {						/* Stretching an existing chain? */
 1553  				ncl = scl + 1;						/* Test if next cluster is free */
 1554  				if (ncl >= fs->n_fatent) ncl = 2;
 1555  				cs = get_fat(obj, ncl);				/* Get next cluster status */
 1556  				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 1557  				if (cs != 0) {						/* Not free? */
 1558  					cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 1559  					if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 1560  					ncl = 0;
 1561  				}
 1562  			}
 1563  			if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 1564  				ncl = scl;	/* Start cluster */
 1565  				while (1) {
 1566  					ncl++;							/* Next cluster */
 1567  					if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 1568  						ncl = 2;
 1569  						if (ncl > scl) return 0;	/* No free cluster found? */
 1570  					}
 1571  					cs = get_fat(obj, ncl);			/* Get the cluster status */
 1572  					if (cs == 0) break;				/* Found a free cluster? */
 1573  					if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 1574  					if (ncl == scl) return 0;		/* No free cluster found? */
 1575  				}
 1576  			}
 1577  			res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
 1578  			if (res == FR_OK && clst != 0) {
 1579  				res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 1580  			}
 1581  		}
 1582  	
 1583  		if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 1584  			fs->last_clst = ncl;
 1585  			if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 1586  			fs->fsi_flag |= 1;
 1587  		} else {
 1588  			ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 1589  		}
 1590  	
 1591  		return ncl;		/* Return new cluster number or error status */
 1592  	}
 1593  	
 1594  	#endif /* !FF_FS_READONLY */
 1595  	
 1596  	
 1597  	
 1598  	
 1599  	#if FF_USE_FASTSEEK
MacExp: #if 0
 1600 X	/*-----------------------------------------------------------------------*/
 1601 X	/* FAT handling - Convert offset into cluster with link map table        */
 1602 X	/*-----------------------------------------------------------------------*/
 1603 X	
 1604 X	static DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 1605 X		FIL* fp,		/* Pointer to the file object */
 1606 X		FSIZE_t ofs		/* File offset to be converted to cluster# */
 1607 X	)
 1608 X	{
 1609 X		DWORD cl, ncl, *tbl;
 1610 X		FATFS *fs = fp->obj.fs;
 1611 X	
 1612 X	
 1613 X		tbl = fp->cltbl + 1;	/* Top of CLMT */
 1614 X		cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 1615 X		while (1) {
 1616 X			ncl = *tbl++;			/* Number of cluters in the fragment */
 1617 X			if (ncl == 0) return 0;	/* End of table? (error) */
 1618 X			if (cl < ncl) break;	/* In this fragment? */
 1619 X			cl -= ncl; tbl++;		/* Next fragment */
 1620 X		}
 1621 X		return cl + *tbl;	/* Return the cluster number */
 1622 X	}
 1623 X	
 1624  	#endif	/* FF_USE_FASTSEEK */
 1625  	
 1626  	
 1627  	
 1628  	
 1629 C	/*-----------------------------------------------------------------------*/
 1630 C	/* Directory handling - Fill a cluster with zeros                        */
 1631 C	/*-----------------------------------------------------------------------*/
 1632 C	
 1633  	#if !FF_FS_READONLY
MacExp: #if !0
 1634  	static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
 1635  		FATFS *fs,		/* Filesystem object */
 1636  		DWORD clst		/* Directory table to clear */
 1637  	)
 1638  	{
 1639  		DWORD sect;
 1640  		UINT n, szb;
 1641  		BYTE *ibuf;
 1642  	
 1643  	
 1644  		if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 1645  		sect = clst2sect(fs, clst);		/* Top of the cluster */
 1646  		fs->winsect = sect;				/* Set window to top of the cluster */
 1647  		mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
MacExp: 	mem_set(fs->win, 0, ((UINT)512));	/* Clear window buffer */
 1648  	#if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
MacExp: #if 1 == 3		/* Quick table clear by using multi-secter write */
 1649 X		/* Allocate a temporary buffer */
 1650 X		for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
 1651 X		if (szb > SS(fs)) {		/* Buffer allocated? */
 1652 X			mem_set(ibuf, 0, szb);
 1653 X			szb /= SS(fs);		/* Bytes -> Sectors */
 1654 X			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 1655 X			ff_memfree(ibuf);
 1656 X		} else
 1657  	#endif
 1658  		{
 1659  			ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
 1660  			for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 1661  		}
 1662  		return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 1663  	}
 1664  	#endif	/* !FF_FS_READONLY */
 1665  	
 1666  	
 1667  	
 1668  	
 1669 C	/*-----------------------------------------------------------------------*/
 1670 C	/* Directory handling - Set directory index                              */
 1671 C	/*-----------------------------------------------------------------------*/
 1672 C	
 1673  	static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 1674  		DIR* dp,		/* Pointer to directory object */
 1675  		DWORD ofs		/* Offset of directory table */
 1676  	)
 1677  	{
 1678  		DWORD csz, clst;
 1679  		FATFS *fs = dp->obj.fs;
 1680  	
 1681  	
 1682  		if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
MacExp: 	if (ofs >= (DWORD)((0 && fs->fs_type == 4) ? 0x10000000 : 0x200000) || ofs % 32) {	/* Check range of offset and alignment */
 1683  			return FR_INT_ERR;
 1684  		}
 1685  		dp->dptr = ofs;				/* Set current offset */
 1686  		clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 1687  		if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
MacExp: 	if (clst == 0 && fs->fs_type >= 3) {	/* Replace cluster# 0 with root cluster# */
 1688  			clst = fs->dirbase;
 1689  			if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
MacExp: 		if (0) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 1690  		}
 1691  	
 1692  		if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 1693  			if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
MacExp: 		if (ofs / 32 >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 1694  			dp->sect = fs->dirbase;
 1695  	
 1696  		} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
 1697  			csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
MacExp: 		csz = (DWORD)fs->csize * ((UINT)512);	/* Bytes per cluster */
 1698  			while (ofs >= csz) {				/* Follow cluster chain */
 1699  				clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 1700  				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1701  				if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 1702  				ofs -= csz;
 1703  			}
 1704  			dp->sect = clst2sect(fs, clst);
 1705  		}
 1706  		dp->clust = clst;					/* Current cluster# */
 1707  		if (dp->sect == 0) return FR_INT_ERR;
 1708  		dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
MacExp: 	dp->sect += ofs / ((UINT)512);			/* Sector# of the directory entry */
 1709  		dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
MacExp: 	dp->dir = fs->win + (ofs % ((UINT)512));	/* Pointer to the entry in the win[] */
 1710  	
 1711  		return FR_OK;
 1712  	}
 1713  	
 1714  	
 1715  	
 1716  	
 1717 C	/*-----------------------------------------------------------------------*/
 1718 C	/* Directory handling - Move directory table index next                  */
 1719 C	/*-----------------------------------------------------------------------*/
 1720 C	
 1721  	static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
 1722  		DIR* dp,				/* Pointer to the directory object */
 1723  		int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
 1724  	)
 1725  	{
 1726  		DWORD ofs, clst;
 1727  		FATFS *fs = dp->obj.fs;
 1728  	
 1729  	
 1730  		ofs = dp->dptr + SZDIRE;	/* Next entry */
MacExp: 	ofs = dp->dptr + 32;	/* Next entry */
 1731  		if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
MacExp: 	if (dp->sect == 0 || ofs >= (DWORD)((0 && fs->fs_type == 4) ? 0x10000000 : 0x200000)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 1732  	
 1733  		if (ofs % SS(fs) == 0) {	/* Sector changed? */
MacExp: 	if (ofs % ((UINT)512) == 0) {	/* Sector changed? */
 1734  			dp->sect++;				/* Next sector */
 1735  	
 1736  			if (dp->clust == 0) {	/* Static table */
 1737  				if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
MacExp: 			if (ofs / 32 >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 1738  					dp->sect = 0; return FR_NO_FILE;
 1739  				}
 1740  			}
 1741  			else {					/* Dynamic table */
 1742  				if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
MacExp: 			if ((ofs / ((UINT)512) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 1743  					clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 1744  					if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 1745  					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1746  					if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 1747  	#if !FF_FS_READONLY
MacExp: #if !0
 1748  						if (!stretch) {								/* If no stretch, report EOT */
 1749  							dp->sect = 0; return FR_NO_FILE;
 1750  						}
 1751  						clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 1752  						if (clst == 0) return FR_DENIED;			/* No free cluster */
 1753  						if (clst == 1) return FR_INT_ERR;			/* Internal error */
 1754  						if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1755  						if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 1756  						if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
MacExp: 					if (0) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
 1757  	#else
 1758 X						if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
 1759 X						dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
 1760  	#endif
 1761  					}
 1762  					dp->clust = clst;		/* Initialize data for new cluster */
 1763  					dp->sect = clst2sect(fs, clst);
 1764  				}
 1765  			}
 1766  		}
 1767  		dp->dptr = ofs;						/* Current entry */
 1768  		dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
MacExp: 	dp->dir = fs->win + ofs % ((UINT)512);	/* Pointer to the entry in the win[] */
 1769  	
 1770  		return FR_OK;
 1771  	}
 1772  	
 1773  	
 1774  	
 1775  	
 1776  	#if !FF_FS_READONLY
MacExp: #if !0
 1777 C	/*-----------------------------------------------------------------------*/
 1778 C	/* Directory handling - Reserve a block of directory entries             */
 1779 C	/*-----------------------------------------------------------------------*/
 1780 C	
 1781  	static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
 1782  		DIR* dp,				/* Pointer to the directory object */
 1783  		UINT nent				/* Number of contiguous entries to allocate */
 1784  	)
 1785  	{
 1786  		FRESULT res;
 1787  		UINT n;
 1788  		FATFS *fs = dp->obj.fs;
 1789  	
 1790  	
 1791  		res = dir_sdi(dp, 0);
 1792  		if (res == FR_OK) {
 1793  			n = 0;
 1794  			do {
 1795  				res = move_window(fs, dp->sect);
 1796  				if (res != FR_OK) break;
 1797  	#if FF_FS_EXFAT
MacExp: #if 0
 1798 X				if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
 1799  	#else
 1800  				if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
MacExp: 			if (dp->dir[0] == 0xE5 || dp->dir[0] == 0) {
 1801  	#endif
 1802  					if (++n == nent) break;	/* A block of contiguous free entries is found */
 1803  				} else {
 1804  					n = 0;					/* Not a blank entry. Restart to search */
 1805  				}
 1806  				res = dir_next(dp, 1);
 1807  			} while (res == FR_OK);	/* Next entry with table stretch enabled */
 1808  		}
 1809  	
 1810  		if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 1811  		return res;
 1812  	}
 1813  	
 1814  	#endif	/* !FF_FS_READONLY */
 1815  	
 1816  	
 1817  	
 1818  	
 1819 C	/*-----------------------------------------------------------------------*/
 1820 C	/* FAT: Directory handling - Load/Store start cluster number             */
 1821 C	/*-----------------------------------------------------------------------*/
 1822 C	
 1823  	static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
 1824  		FATFS* fs,			/* Pointer to the fs object */
 1825  		const BYTE* dir		/* Pointer to the key entry */
 1826  	)
 1827  	{
 1828  		DWORD cl;
 1829  	
 1830  		cl = ld_word(dir + DIR_FstClusLO);
MacExp: 	cl = ld_word(dir + 26);
 1831  		if (fs->fs_type == FS_FAT32) {
MacExp: 	if (fs->fs_type == 3) {
 1832  			cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
MacExp: 		cl |= (DWORD)ld_word(dir + 20) << 16;
 1833  		}
 1834  	
 1835  		return cl;
 1836  	}
 1837  	
 1838  	
 1839  	#if !FF_FS_READONLY
MacExp: #if !0
 1840  	static void st_clust (
 1841  		FATFS* fs,	/* Pointer to the fs object */
 1842  		BYTE* dir,	/* Pointer to the key entry */
 1843  		DWORD cl	/* Value to be set */
 1844  	)
 1845  	{
 1846  		st_word(dir + DIR_FstClusLO, (WORD)cl);
MacExp: 	st_word(dir + 26, (WORD)cl);
 1847  		if (fs->fs_type == FS_FAT32) {
MacExp: 	if (fs->fs_type == 3) {
 1848  			st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
MacExp: 		st_word(dir + 20, (WORD)(cl >> 16));
 1849  		}
 1850  	}
 1851  	#endif
 1852  	
 1853  	
 1854  	
 1855  	#if FF_USE_LFN
MacExp: #if 1
 1856 C	/*--------------------------------------------------------*/
 1857 C	/* FAT-LFN: Compare a part of file name with an LFN entry */
 1858 C	/*--------------------------------------------------------*/
 1859 C	
 1860  	static int cmp_lfn (		/* 1:matched, 0:not matched */
 1861  		const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
 1862  		BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
 1863  	)
 1864  	{
 1865  		UINT i, s;
 1866  		WCHAR wc, uc;
 1867  	
 1868  	
 1869  		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
MacExp: 	if (ld_word(dir + 26) != 0) return 0;	/* Check LDIR_FstClusLO */
 1870  	
 1871  		i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
MacExp: 	i = ((dir[0] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 1872  	
 1873  		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 1874  			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 1875  			if (wc != 0) {
 1876  				if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
MacExp: 			if (i >= 255 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 1877  					return 0;					/* Not matched */
 1878  				}
 1879  				wc = uc;
 1880  			} else {
 1881  				if (uc != 0xFFFF) return 0;		/* Check filler */
 1882  			}
 1883  		}
 1884  	
 1885  		if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
MacExp: 	if ((dir[0] & 0x40) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 1886  	
 1887  		return 1;		/* The part of LFN matched */
 1888  	}
 1889  	
 1890  	
 1891  	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
MacExp: #if 0 <= 1 || 1 >= 2 || 0 || 0
 1892 C	/*-----------------------------------------------------*/
 1893 C	/* FAT-LFN: Pick a part of file name from an LFN entry */
 1894 C	/*-----------------------------------------------------*/
 1895 C	
 1896  	static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
 1897  		WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
 1898  		BYTE* dir			/* Pointer to the LFN entry */
 1899  	)
 1900  	{
 1901  		UINT i, s;
 1902  		WCHAR wc, uc;
 1903  	
 1904  	
 1905  		if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
MacExp: 	if (ld_word(dir + 26) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 1906  	
 1907  		i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
MacExp: 	i = ((dir[0] & ~0x40) - 1) * 13;	/* Offset in the LFN buffer */
 1908  	
 1909  		for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 1910  			uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 1911  			if (wc != 0) {
 1912  				if (i >= FF_MAX_LFN) return 0;	/* Buffer overflow? */
MacExp: 			if (i >= 255) return 0;	/* Buffer overflow? */
 1913  				lfnbuf[i++] = wc = uc;			/* Store it */
 1914  			} else {
 1915  				if (uc != 0xFFFF) return 0;		/* Check filler */
 1916  			}
 1917  		}
 1918  	
 1919  		if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
MacExp: 	if (dir[0] & 0x40) {				/* Put terminator if it is the last LFN part */
 1920  			if (i >= FF_MAX_LFN) return 0;		/* Buffer overflow? */
MacExp: 		if (i >= 255) return 0;		/* Buffer overflow? */
 1921  			lfnbuf[i] = 0;
 1922  		}
 1923  	
 1924  		return 1;		/* The part of LFN is valid */
 1925  	}
 1926  	#endif
 1927  	
 1928  	
 1929  	#if !FF_FS_READONLY
MacExp: #if !0
 1930 C	/*-----------------------------------------*/
 1931 C	/* FAT-LFN: Create an entry of LFN entries */
 1932 C	/*-----------------------------------------*/
 1933 C	
 1934  	static void put_lfn (
 1935  		const WCHAR* lfn,	/* Pointer to the LFN */
 1936  		BYTE* dir,			/* Pointer to the LFN entry to be created */
 1937  		BYTE ord,			/* LFN order (1-20) */
 1938  		BYTE sum			/* Checksum of the corresponding SFN */
 1939  	)
 1940  	{
 1941  		UINT i, s;
 1942  		WCHAR wc;
 1943  	
 1944  	
 1945  		dir[LDIR_Chksum] = sum;			/* Set checksum */
MacExp: 	dir[13] = sum;			/* Set checksum */
 1946  		dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
MacExp: 	dir[11] = 0x0F;		/* Set attribute. LFN entry */
 1947  		dir[LDIR_Type] = 0;
MacExp: 	dir[12] = 0;
 1948  		st_word(dir + LDIR_FstClusLO, 0);
MacExp: 	st_word(dir + 26, 0);
 1949  	
 1950  		i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 1951  		s = wc = 0;
 1952  		do {
 1953  			if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 1954  			st_word(dir + LfnOfs[s], wc);		/* Put it */
 1955  			if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 1956  		} while (++s < 13);
 1957  		if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
MacExp: 	if (wc == 0xFFFF || !lfn[i]) ord |= 0x40;	/* Last LFN part is the start of LFN sequence */
 1958  		dir[LDIR_Ord] = ord;			/* Set the LFN order */
MacExp: 	dir[0] = ord;			/* Set the LFN order */
 1959  	}
 1960  	
 1961  	#endif	/* !FF_FS_READONLY */
 1962  	#endif	/* FF_USE_LFN */
 1963  	
 1964  	
 1965  	
 1966  	#if FF_USE_LFN && !FF_FS_READONLY
MacExp: #if 1 && !0
 1967 C	/*-----------------------------------------------------------------------*/
 1968 C	/* FAT-LFN: Create a Numbered SFN                                        */
 1969 C	/*-----------------------------------------------------------------------*/
 1970 C	
 1971  	static void gen_numname (
 1972  		BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
 1973  		const BYTE* src,	/* Pointer to SFN */
 1974  		const WCHAR* lfn,	/* Pointer to LFN */
 1975  		UINT seq			/* Sequence number */
 1976  	)
 1977  	{
 1978  		BYTE ns[8], c;
 1979  		UINT i, j;
 1980  		WCHAR wc;
 1981  		DWORD sr;
 1982  	
 1983  	
 1984  		mem_cpy(dst, src, 11);
 1985  	
 1986  		if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 1987  			sr = seq;
 1988  			while (*lfn) {	/* Create a CRC as hash value */
 1989  				wc = *lfn++;
 1990  				for (i = 0; i < 16; i++) {
 1991  					sr = (sr << 1) + (wc & 1);
 1992  					wc >>= 1;
 1993  					if (sr & 0x10000) sr ^= 0x11021;
 1994  				}
 1995  			}
 1996  			seq = (UINT)sr;
 1997  		}
 1998  	
 1999 C		/* itoa (hexdecimal) */
 2000  		i = 7;
 2001  		do {
 2002  			c = (BYTE)((seq % 16) + '0');
 2003  			if (c > '9') c += 7;
 2004  			ns[i--] = c;
 2005  			seq /= 16;
 2006  		} while (seq);
 2007  		ns[i] = '~';
 2008  	
 2009 C		/* Append the number to the SFN body */
 2010  		for (j = 0; j < i && dst[j] != ' '; j++) {
 2011  			if (dbc_1st(dst[j])) {
 2012  				if (j == i - 1) break;
 2013  				j++;
 2014  			}
 2015  		}
 2016  		do {
 2017  			dst[j++] = (i < 8) ? ns[i++] : ' ';
 2018  		} while (j < 8);
 2019  	}
 2020  	#endif	/* FF_USE_LFN && !FF_FS_READONLY */
 2021  	
 2022  	
 2023  	
 2024  	#if FF_USE_LFN
MacExp: #if 1
 2025 C	/*-----------------------------------------------------------------------*/
 2026 C	/* FAT-LFN: Calculate checksum of an SFN entry                           */
 2027 C	/*-----------------------------------------------------------------------*/
 2028 C	
 2029  	static BYTE sum_sfn (
 2030  		const BYTE* dir		/* Pointer to the SFN entry */
 2031  	)
 2032  	{
 2033  		BYTE sum = 0;
 2034  		UINT n = 11;
 2035  	
 2036  		do {
 2037  			sum = (sum >> 1) + (sum << 7) + *dir++;
 2038  		} while (--n);
 2039  		return sum;
 2040  	}
 2041  	
 2042  	#endif	/* FF_USE_LFN */
 2043  	
 2044  	
 2045  	
 2046  	#if FF_FS_EXFAT
MacExp: #if 0
 2047 X	/*-----------------------------------------------------------------------*/
 2048 X	/* exFAT: Checksum                                                       */
 2049 X	/*-----------------------------------------------------------------------*/
 2050 X	
 2051 X	static WORD xdir_sum (	/* Get checksum of the directoly entry block */
 2052 X		const BYTE* dir		/* Directory entry block to be calculated */
 2053 X	)
 2054 X	{
 2055 X		UINT i, szblk;
 2056 X		WORD sum;
 2057 X	
 2058 X	
 2059 X		szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 2060 X		for (i = sum = 0; i < szblk; i++) {
 2061 X			if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
 2062 X				i++;
 2063 X			} else {
 2064 X				sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 2065 X			}
 2066 X		}
 2067 X		return sum;
 2068 X	}
 2069 X	
 2070 X	
 2071 X	
 2072 X	static WORD xname_sum (	/* Get check sum (to be used as hash) of the file name */
 2073 X		const WCHAR* name	/* File name to be calculated */
 2074 X	)
 2075 X	{
 2076 X		WCHAR chr;
 2077 X		WORD sum = 0;
 2078 X	
 2079 X	
 2080 X		while ((chr = *name++) != 0) {
 2081 X			chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
 2082 X			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 2083 X			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 2084 X		}
 2085 X		return sum;
 2086 X	}
 2087 X	
 2088 X	
 2089 X	#if !FF_FS_READONLY && FF_USE_MKFS
MacExp: #if !0 && 0
 2090 X	static DWORD xsum32 (	/* Returns 32-bit checksum */
 2091 X		BYTE  dat,			/* Byte to be calculated (byte-by-byte processing) */
 2092 X		DWORD sum			/* Previous sum value */
 2093 X	)
 2094 X	{
 2095 X		sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
 2096 X		return sum;
 2097 X	}
 2098 X	#endif
 2099 X	
 2100 X	
 2101 X	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
MacExp: #if 0 <= 1 || 1 >= 2
 2102 X	/*------------------------------------------------------*/
 2103 X	/* exFAT: Get object information from a directory block */
 2104 X	/*------------------------------------------------------*/
 2105 X	
 2106 X	static void get_xfileinfo (
 2107 X		BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
 2108 X		FILINFO* fno		/* Buffer to store the extracted file information */
 2109 X	)
 2110 X	{
 2111 X		WCHAR wc, hs;
 2112 X		UINT di, si, nc;
 2113 X	
 2114 X		/* Get file name from the entry block */
 2115 X		si = SZDIRE * 2;	/* 1st C1 entry */
 2116 X		nc = 0; hs = 0; di = 0;
 2117 X		while (nc < dirb[XDIR_NumName]) {
 2118 X			if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
 2119 X			if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
 2120 X			wc = ld_word(dirb + si); si += 2; nc++;	/* Get a character */
 2121 X			if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
 2122 X				hs = wc; continue;	/* Get low surrogate */
 2123 X			}
 2124 X			wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 2125 X			if (wc == 0) { di = 0; break; }	/* Buffer overflow or wrong encoding? */
 2126 X			di += wc;
 2127 X			hs = 0;
 2128 X		}
 2129 X		if (hs != 0) di = 0;					/* Broken surrogate pair? */
 2130 X		if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
 2131 X		fno->fname[di] = 0;						/* Terminate the name */
 2132 X		fno->altname[0] = 0;					/* exFAT does not support SFN */
 2133 X	
 2134 X		fno->fattrib = dirb[XDIR_Attr];			/* Attribute */
 2135 X		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
 2136 X		fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
 2137 X		fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
 2138 X	}
 2139 X	
 2140 X	#endif	/* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
 2141 X	
 2142 X	
 2143 X	/*-----------------------------------*/
 2144 X	/* exFAT: Get a directry entry block */
 2145 X	/*-----------------------------------*/
 2146 X	
 2147 X	static FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
 2148 X		DIR* dp					/* Reading direcotry object pointing top of the entry block to load */
 2149 X	)
 2150 X	{
 2151 X		FRESULT res;
 2152 X		UINT i, sz_ent;
 2153 X		BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 2154 X	
 2155 X	
 2156 X		/* Load 85 entry */
 2157 X		res = move_window(dp->obj.fs, dp->sect);
 2158 X		if (res != FR_OK) return res;
 2159 X		if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;	/* Invalid order */
 2160 X		mem_cpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
 2161 X		sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 2162 X		if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 2163 X	
 2164 X		/* Load C0 entry */
 2165 X		res = dir_next(dp, 0);
 2166 X		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 2167 X		if (res != FR_OK) return res;
 2168 X		res = move_window(dp->obj.fs, dp->sect);
 2169 X		if (res != FR_OK) return res;
 2170 X		if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;	/* Invalid order */
 2171 X		mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
 2172 X		if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 2173 X	
 2174 X		/* Load C1 entries */
 2175 X		i = 2 * SZDIRE;	/* C1 offset to load */
 2176 X		do {
 2177 X			res = dir_next(dp, 0);
 2178 X			if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 2179 X			if (res != FR_OK) return res;
 2180 X			res = move_window(dp->obj.fs, dp->sect);
 2181 X			if (res != FR_OK) return res;
 2182 X			if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;	/* Invalid order */
 2183 X			if (i < MAXDIRB(FF_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
 2184 X		} while ((i += SZDIRE) < sz_ent);
 2185 X	
 2186 X		/* Sanity check (do it for only accessible object) */
 2187 X		if (i <= MAXDIRB(FF_MAX_LFN)) {
 2188 X			if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
 2189 X		}
 2190 X		return FR_OK;
 2191 X	}
 2192 X	
 2193 X	
 2194 X	/*------------------------------------------------------------------*/
 2195 X	/* exFAT: Initialize object allocation info with loaded entry block */
 2196 X	/*------------------------------------------------------------------*/
 2197 X	
 2198 X	static void init_alloc_info (
 2199 X		FATFS* fs,		/* Filesystem object */
 2200 X		FFOBJID* obj	/* Object allocation information to be initialized */
 2201 X	)
 2202 X	{
 2203 X		obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
 2204 X		obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 2205 X		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
 2206 X		obj->n_frag = 0;										/* No last fragment info */
 2207 X	}
 2208 X	
 2209 X	
 2210 X	
 2211 X	#if !FF_FS_READONLY || FF_FS_RPATH != 0
MacExp: #if !0 || 1 != 0
 2212 X	/*------------------------------------------------*/
 2213 X	/* exFAT: Load the object's directory entry block */
 2214 X	/*------------------------------------------------*/
 2215 X	
 2216 X	static FRESULT load_obj_xdir (
 2217 X		DIR* dp,			/* Blank directory object to be used to access containing direcotry */
 2218 X		const FFOBJID* obj	/* Object with its containing directory information */
 2219 X	)
 2220 X	{
 2221 X		FRESULT res;
 2222 X	
 2223 X		/* Open object containing directory */
 2224 X		dp->obj.fs = obj->fs;
 2225 X		dp->obj.sclust = obj->c_scl;
 2226 X		dp->obj.stat = (BYTE)obj->c_size;
 2227 X		dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 2228 X		dp->obj.n_frag = 0;
 2229 X		dp->blk_ofs = obj->c_ofs;
 2230 X	
 2231 X		res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 2232 X		if (res == FR_OK) {
 2233 X			res = load_xdir(dp);		/* Load the object's entry block */
 2234 X		}
 2235 X		return res;
 2236 X	}
 2237 X	#endif
 2238 X	
 2239 X	
 2240 X	#if !FF_FS_READONLY
MacExp: #if !0
 2241 X	/*----------------------------------------*/
 2242 X	/* exFAT: Store the directory entry block */
 2243 X	/*----------------------------------------*/
 2244 X	
 2245 X	static FRESULT store_xdir (
 2246 X		DIR* dp				/* Pointer to the direcotry object */
 2247 X	)
 2248 X	{
 2249 X		FRESULT res;
 2250 X		UINT nent;
 2251 X		BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 2252 X	
 2253 X		/* Create set sum */
 2254 X		st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 2255 X		nent = dirb[XDIR_NumSec] + 1;
 2256 X	
 2257 X		/* Store the direcotry entry block to the directory */
 2258 X		res = dir_sdi(dp, dp->blk_ofs);
 2259 X		while (res == FR_OK) {
 2260 X			res = move_window(dp->obj.fs, dp->sect);
 2261 X			if (res != FR_OK) break;
 2262 X			mem_cpy(dp->dir, dirb, SZDIRE);
 2263 X			dp->obj.fs->wflag = 1;
 2264 X			if (--nent == 0) break;
 2265 X			dirb += SZDIRE;
 2266 X			res = dir_next(dp, 0);
 2267 X		}
 2268 X		return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
 2269 X	}
 2270 X	
 2271 X	
 2272 X	
 2273 X	/*-------------------------------------------*/
 2274 X	/* exFAT: Create a new directory enrty block */
 2275 X	/*-------------------------------------------*/
 2276 X	
 2277 X	static void create_xdir (
 2278 X		BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
 2279 X		const WCHAR* lfn	/* Pointer to the object name */
 2280 X	)
 2281 X	{
 2282 X		UINT i;
 2283 X		BYTE nc1, nlen;
 2284 X		WCHAR wc;
 2285 X	
 2286 X	
 2287 X		/* Create 85,C0 entry */
 2288 X		mem_set(dirb, 0, 2 * SZDIRE);
 2289 X		dirb[0 * SZDIRE + XDIR_Type] = 0x85;	/* 85 entry */
 2290 X		dirb[1 * SZDIRE + XDIR_Type] = 0xC0;	/* C0 entry */
 2291 X	
 2292 X		/* Create C1 entries */
 2293 X		i = SZDIRE * 2;	/* Top of C1 entries */
 2294 X		nlen = nc1 = 0; wc = 1;
 2295 X		do {
 2296 X			dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
 2297 X			do {	/* Fill name field */
 2298 X				if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
 2299 X				st_word(dirb + i, wc); 		/* Store it */
 2300 X				i += 2;
 2301 X			} while (i % SZDIRE != 0);
 2302 X			nc1++;
 2303 X		} while (lfn[nlen]);	/* Fill next entry if any char follows */
 2304 X	
 2305 X		dirb[XDIR_NumName] = nlen;		/* Set name length */
 2306 X		dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
 2307 X		st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
 2308 X	}
 2309 X	
 2310 X	#endif	/* !FF_FS_READONLY */
 2311  	#endif	/* FF_FS_EXFAT */
 2312  	
 2313  	
 2314  	
 2315  	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
MacExp: #if 0 <= 1 || 1 >= 2 || 0 || 0
 2316 C	/*-----------------------------------------------------------------------*/
 2317 C	/* Read an object from the directory                                     */
 2318 C	/*-----------------------------------------------------------------------*/
 2319 C	
 2320  	#define dir_read_file(dp) dir_read(dp, 0)
 2321  	#define dir_read_label(dp) dir_read(dp, 1)
 2322  	
 2323  	static FRESULT dir_read (
 2324  		DIR* dp,		/* Pointer to the directory object */
 2325  		int vol			/* Filtered by 0:file/directory or 1:volume label */
 2326  	)
 2327  	{
 2328  		FRESULT res = FR_NO_FILE;
 2329  		FATFS *fs = dp->obj.fs;
 2330  		BYTE a, c;
 2331  	#if FF_USE_LFN
MacExp: #if 1
 2332  		BYTE ord = 0xFF, sum = 0xFF;
 2333  	#endif
 2334  	
 2335  		while (dp->sect) {
 2336  			res = move_window(fs, dp->sect);
 2337  			if (res != FR_OK) break;
 2338  			c = dp->dir[DIR_Name];	/* Test for the entry type */
MacExp: 		c = dp->dir[0];	/* Test for the entry type */
 2339  			if (c == 0) {
 2340  				res = FR_NO_FILE; break; /* Reached to end of the directory */
 2341  			}
 2342  	#if FF_FS_EXFAT
MacExp: #if 0
 2343 X			if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 2344 X				if (FF_USE_LABEL && vol) {
 2345 X					if (c == 0x83) break;	/* Volume label entry? */
 2346 X				} else {
 2347 X					if (c == 0x85) {		/* Start of the file entry block? */
 2348 X						dp->blk_ofs = dp->dptr;	/* Get location of the block */
 2349 X						res = load_xdir(dp);	/* Load the entry block */
 2350 X						if (res == FR_OK) {
 2351 X							dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 2352 X						}
 2353 X						break;
 2354 X					}
 2355 X				}
 2356 X			} else
 2357  	#endif
 2358  			{	/* On the FAT/FAT32 volume */
 2359  				dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
MacExp: 			dp->obj.attr = a = dp->dir[11] & 0x3F;	/* Get attribute */
 2360  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2361  				if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
MacExp: 			if (c == 0xE5 || c == '.' || (int)((a & ~0x20) == 0x08) != vol) {	/* An entry without valid data */
 2362  					ord = 0xFF;
 2363  				} else {
 2364  					if (a == AM_LFN) {			/* An LFN entry is found */
MacExp: 				if (a == 0x0F) {			/* An LFN entry is found */
 2365  						if (c & LLEF) {			/* Is it start of an LFN sequence? */
MacExp: 					if (c & 0x40) {			/* Is it start of an LFN sequence? */
 2366  							sum = dp->dir[LDIR_Chksum];
MacExp: 						sum = dp->dir[13];
 2367  							c &= (BYTE)~LLEF; ord = c;
MacExp: 						c &= (BYTE)~0x40; ord = c;
 2368  							dp->blk_ofs = dp->dptr;
 2369  						}
 2370 C						/* Check LFN validity and capture it */
 2371  						ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
MacExp: 					ord = (c == ord && sum == dp->dir[13] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 2372  					} else {					/* An SFN entry is found */
 2373  						if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 2374  							dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 2375  						}
 2376  						break;
 2377  					}
 2378  				}
 2379  	#else		/* Non LFN configuration */
 2380 X				if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 2381 X					break;
 2382 X				}
 2383  	#endif
 2384  			}
 2385  			res = dir_next(dp, 0);		/* Next entry */
 2386  			if (res != FR_OK) break;
 2387  		}
 2388  	
 2389  		if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 2390  		return res;
 2391  	}
 2392  	
 2393  	#endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
 2394  	
 2395  	
 2396  	
 2397 C	/*-----------------------------------------------------------------------*/
 2398 C	/* Directory handling - Find an object in the directory                  */
 2399 C	/*-----------------------------------------------------------------------*/
 2400 C	
 2401  	static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
 2402  		DIR* dp					/* Pointer to the directory object with the file name */
 2403  	)
 2404  	{
 2405  		FRESULT res;
 2406  		FATFS *fs = dp->obj.fs;
 2407  		BYTE c;
 2408  	#if FF_USE_LFN
MacExp: #if 1
 2409  		BYTE a, ord, sum;
 2410  	#endif
 2411  	
 2412  		res = dir_sdi(dp, 0);			/* Rewind directory object */
 2413  		if (res != FR_OK) return res;
 2414  	#if FF_FS_EXFAT
MacExp: #if 0
 2415 X		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 2416 X			BYTE nc;
 2417 X			UINT di, ni;
 2418 X			WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
 2419 X	
 2420 X			while ((res = dir_read_file(dp)) == FR_OK) {	/* Read an item */
 2421 X	#if FF_MAX_LFN < 255
MacExp: #if 255 < 255
 2422 X				if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;			/* Skip comparison if inaccessible object name */
 2423 X	#endif
 2424 X				if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 2425 X				for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 2426 X					if ((di % SZDIRE) == 0) di += 2;
 2427 X					if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 2428 X				}
 2429 X				if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 2430 X			}
 2431 X			return res;
 2432 X		}
 2433  	#endif
 2434 C		/* On the FAT/FAT32 volume */
 2435  	#if FF_USE_LFN
MacExp: #if 1
 2436  		ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 2437  	#endif
 2438  		do {
 2439  			res = move_window(fs, dp->sect);
 2440  			if (res != FR_OK) break;
 2441  			c = dp->dir[DIR_Name];
MacExp: 		c = dp->dir[0];
 2442  			if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 2443  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2444  			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
MacExp: 		dp->obj.attr = a = dp->dir[11] & 0x3F;
 2445  			if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
MacExp: 		if (c == 0xE5 || ((a & 0x08) && a != 0x0F)) {	/* An entry without valid data */
 2446  				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 2447  			} else {
 2448  				if (a == AM_LFN) {			/* An LFN entry is found */
MacExp: 			if (a == 0x0F) {			/* An LFN entry is found */
 2449  					if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
MacExp: 				if (!(dp->fn[11] & 0x40)) {
 2450  						if (c & LLEF) {		/* Is it start of LFN sequence? */
MacExp: 					if (c & 0x40) {		/* Is it start of LFN sequence? */
 2451  							sum = dp->dir[LDIR_Chksum];
MacExp: 						sum = dp->dir[13];
 2452  							c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
MacExp: 						c &= (BYTE)~0x40; ord = c;	/* LFN start order */
 2453  							dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 2454  						}
 2455 C						/* Check validity of the LFN entry and compare it with given name */
 2456  						ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
MacExp: 					ord = (c == ord && sum == dp->dir[13] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 2457  					}
 2458  				} else {					/* An SFN entry is found */
 2459  					if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 2460  					if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
MacExp: 				if (!(dp->fn[11] & 0x01) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 2461  					ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 2462  				}
 2463  			}
 2464  	#else		/* Non LFN configuration */
 2465 X			dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 2466 X			if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 2467  	#endif
 2468  			res = dir_next(dp, 0);	/* Next entry */
 2469  		} while (res == FR_OK);
 2470  	
 2471  		return res;
 2472  	}
 2473  	
 2474  	
 2475  	
 2476  	
 2477  	#if !FF_FS_READONLY
MacExp: #if !0
 2478 C	/*-----------------------------------------------------------------------*/
 2479 C	/* Register an object to the directory                                   */
 2480 C	/*-----------------------------------------------------------------------*/
 2481 C	
 2482  	static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
 2483  		DIR* dp						/* Target directory with object name to be created */
 2484  	)
 2485  	{
 2486  		FRESULT res = FR_OK;
 2487  		FATFS *fs = dp->obj.fs;
 2488  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2489  		UINT n, nlen, nent;
 2490  		BYTE sn[12], sum;
 2491  	
 2492  	
 2493  		if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
MacExp: 	if (dp->fn[11] & (0x20 | 0x80)) return FR_INVALID_NAME;	/* Check name validity */
 2494  		for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 2495  	
 2496  	#if FF_FS_EXFAT
MacExp: #if 0
 2497 X		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 2498 X			nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 2499 X			res = dir_alloc(dp, nent);		/* Allocate entries */
 2500 X			if (res != FR_OK) return res;
 2501 X			dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
 2502 X	
 2503 X			if (dp->obj.stat & 4) {			/* Has the directory been stretched? */
 2504 X				dp->obj.stat &= ~4;
 2505 X				res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
 2506 X				if (res != FR_OK) return res;
 2507 X				res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
 2508 X				if (res != FR_OK) return res;
 2509 X				if (dp->obj.sclust != 0) {		/* Is it a sub directory? */
 2510 X					DIR dj;
 2511 X	
 2512 X					res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
 2513 X					if (res != FR_OK) return res;
 2514 X					dp->obj.objsize += (DWORD)fs->csize * SS(fs);			/* Increase the directory size by cluster size */
 2515 X					st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);	/* Update the allocation status */
 2516 X					st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
 2517 X					fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
 2518 X					res = store_xdir(&dj);				/* Store the object status */
 2519 X					if (res != FR_OK) return res;
 2520 X				}
 2521 X			}
 2522 X	
 2523 X			create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
 2524 X			return FR_OK;
 2525 X		}
 2526  	#endif
 2527 C		/* On the FAT/FAT32 volume */
 2528  		mem_cpy(sn, dp->fn, 12);
 2529  		if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
MacExp: 	if (sn[11] & 0x01) {			/* When LFN is out of 8.3 format, generate a numbered name */
 2530  			dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
MacExp: 		dp->fn[11] = 0x40;		/* Find only SFN */
 2531  			for (n = 1; n < 100; n++) {
 2532  				gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 2533  				res = dir_find(dp);				/* Check if the name collides with existing SFN */
 2534  				if (res != FR_OK) break;
 2535  			}
 2536  			if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 2537  			if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 2538  			dp->fn[NSFLAG] = sn[NSFLAG];
MacExp: 		dp->fn[11] = sn[11];
 2539  		}
 2540  	
 2541 C		/* Create an SFN with/without LFNs. */
 2542  		nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
MacExp: 	nent = (sn[11] & 0x02) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 2543  		res = dir_alloc(dp, nent);		/* Allocate entries */
 2544  		if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 2545  			res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
MacExp: 		res = dir_sdi(dp, dp->dptr - nent * 32);
 2546  			if (res == FR_OK) {
 2547  				sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 2548  				do {					/* Store LFN entries in bottom first */
 2549  					res = move_window(fs, dp->sect);
 2550  					if (res != FR_OK) break;
 2551  					put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 2552  					fs->wflag = 1;
 2553  					res = dir_next(dp, 0);	/* Next entry */
 2554  				} while (res == FR_OK && --nent);
 2555  			}
 2556  		}
 2557  	
 2558  	#else	/* Non LFN configuration */
 2559 X		res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
 2560 X	
 2561  	#endif
 2562  	
 2563 C		/* Set SFN entry */
 2564  		if (res == FR_OK) {
 2565  			res = move_window(fs, dp->sect);
 2566  			if (res == FR_OK) {
 2567  				mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
MacExp: 			mem_set(dp->dir, 0, 32);	/* Clean the entry */
 2568  				mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
MacExp: 			mem_cpy(dp->dir + 0, dp->fn, 11);	/* Put SFN */
 2569  	#if FF_USE_LFN
MacExp: #if 1
 2570  				dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
MacExp: 			dp->dir[12] = dp->fn[11] & (0x08 | 0x10);	/* Put NT flag */
 2571  	#endif
 2572  				fs->wflag = 1;
 2573  			}
 2574  		}
 2575  	
 2576  		return res;
 2577  	}
 2578  	
 2579  	#endif /* !FF_FS_READONLY */
 2580  	
 2581  	
 2582  	
 2583  	#if !FF_FS_READONLY && FF_FS_MINIMIZE == 0
MacExp: #if !0 && 0 == 0
 2584 C	/*-----------------------------------------------------------------------*/
 2585 C	/* Remove an object from the directory                                   */
 2586 C	/*-----------------------------------------------------------------------*/
 2587 C	
 2588  	static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
 2589  		DIR* dp					/* Directory object pointing the entry to be removed */
 2590  	)
 2591  	{
 2592  		FRESULT res;
 2593  		FATFS *fs = dp->obj.fs;
 2594  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2595  		DWORD last = dp->dptr;
 2596  	
 2597  		res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 2598  		if (res == FR_OK) {
 2599  			do {
 2600  				res = move_window(fs, dp->sect);
 2601  				if (res != FR_OK) break;
 2602  				if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
MacExp: 			if (0 && fs->fs_type == 4) {	/* On the exFAT volume */
 2603  					dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
MacExp: 				dp->dir[0] &= 0x7F;	/* Clear the entry InUse flag. */
 2604  				} else {									/* On the FAT/FAT32 volume */
 2605  					dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'. */
MacExp: 				dp->dir[0] = 0xE5;	/* Mark the entry 'deleted'. */
 2606  				}
 2607  				fs->wflag = 1;
 2608  				if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 2609  				res = dir_next(dp, 0);	/* Next entry */
 2610  			} while (res == FR_OK);
 2611  			if (res == FR_NO_FILE) res = FR_INT_ERR;
 2612  		}
 2613  	#else			/* Non LFN configuration */
 2614 X	
 2615 X		res = move_window(fs, dp->sect);
 2616 X		if (res == FR_OK) {
 2617 X			dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 2618 X			fs->wflag = 1;
 2619 X		}
 2620  	#endif
 2621  	
 2622  		return res;
 2623  	}
 2624  	
 2625  	#endif /* !FF_FS_READONLY && FF_FS_MINIMIZE == 0 */
 2626  	
 2627  	
 2628  	
 2629  	#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
MacExp: #if 0 <= 1 || 1 >= 2
 2630 C	/*-----------------------------------------------------------------------*/
 2631 C	/* Get file information from directory entry                             */
 2632 C	/*-----------------------------------------------------------------------*/
 2633 C	
 2634  	static void get_fileinfo (
 2635  		DIR* dp,			/* Pointer to the directory object */
 2636  		FILINFO* fno		/* Pointer to the file information to be filled */
 2637  	)
 2638  	{
 2639  		UINT si, di;
 2640  	#if FF_USE_LFN
MacExp: #if 1
 2641  		WCHAR wc, hs;
 2642  		FATFS *fs = dp->obj.fs;
 2643  	#else
 2644 X		TCHAR c;
 2645  	#endif
 2646  	
 2647  	
 2648  		fno->fname[0] = 0;			/* Invaidate file info */
 2649  		if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 2650  	
 2651  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2652  	#if FF_FS_EXFAT
MacExp: #if 0
 2653 X		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 2654 X			get_xfileinfo(fs->dirbuf, fno);
 2655 X			return;
 2656 X		} else
 2657  	#endif
 2658  		{	/* On the FAT/FAT32 volume */
 2659  			if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 2660  				si = di = hs = 0;
 2661  				while (fs->lfnbuf[si] != 0) {
 2662  					wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
 2663  					if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
MacExp: 				if (hs == 0 && ((wc) >= 0xD800 && (wc) <= 0xDFFF)) {	/* Is it a surrogate? */
 2664  						hs = wc; continue;		/* Get low surrogate */
 2665  					}
 2666  					wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or UTF-8 encoding */
MacExp: 				wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], 255 - di);	/* Store it in UTF-16 or UTF-8 encoding */
 2667  					if (wc == 0) { di = 0; break; }	/* Invalid char or buffer overflow? */
 2668  					di += wc;
 2669  					hs = 0;
 2670  				}
 2671  				if (hs != 0) di = 0;	/* Broken surrogate pair? */
 2672  				fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
 2673  			}
 2674  		}
 2675  	
 2676  		si = di = 0;
 2677  		while (si < 11) {		/* Get SFN from SFN entry */
 2678  			wc = dp->dir[si++];			/* Get a char */
 2679  			if (wc == ' ') continue;	/* Skip padding spaces */
 2680  			if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
MacExp: 		if (wc == 0x05) wc = 0xE5;	/* Restore replaced DDEM character */
 2681  			if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
MacExp: 		if (si == 9 && di < 12) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
 2682  	#if FF_LFN_UNICODE >= 1	/* Unicode output */
MacExp: #if 0 >= 1	/* Unicode output */
 2683 X			if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) {	/* Make a DBC if needed */
 2684 X				wc = wc << 8 | dp->dir[si++];
 2685 X			}
 2686 X			wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
 2687 X			if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
 2688 X			wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
 2689 X			if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
 2690 X			di += wc;
 2691  	#else					/* ANSI/OEM output */
 2692  			fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
 2693  	#endif
 2694  		}
 2695  		fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
 2696  	
 2697  		if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
 2698  			if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
 2699  				fno->fname[di++] = '?';
 2700  			} else {
 2701  				for (si = di = 0; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 2702  					wc = (WCHAR)fno->altname[si];
 2703  					if (IsUpper(wc) && (dp->dir[DIR_NTres] & ((si >= 9) ? NS_EXT : NS_BODY))) wc += 0x20;
MacExp: 				if (((wc) >= 'A' && (wc) <= 'Z') && (dp->dir[12] & ((si >= 9) ? 0x10 : 0x08))) wc += 0x20;
 2704  					fno->fname[di] = (TCHAR)wc;
 2705  				}
 2706  			}
 2707  			fno->fname[di] = 0;	/* Terminate the LFN */
 2708  			if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
MacExp: 		if (!dp->dir[12]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
 2709  		}
 2710  	
 2711  	#else	/* Non-LFN configuration */
 2712 X		si = di = 0;
 2713 X		while (si < 11) {		/* Copy name body and extension */
 2714 X			c = (TCHAR)dp->dir[si++];
 2715 X			if (c == ' ') continue;		/* Skip padding spaces */
 2716 X			if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 2717 X			if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 2718 X			fno->fname[di++] = c;
 2719 X		}
 2720 X		fno->fname[di] = 0;
 2721  	#endif
 2722  	
 2723  		fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
MacExp: 	fno->fattrib = dp->dir[11];					/* Attribute */
 2724  		fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
MacExp: 	fno->fsize = ld_dword(dp->dir + 28);		/* Size */
 2725  		fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
MacExp: 	fno->ftime = ld_word(dp->dir + 22 + 0);	/* Time */
 2726  		fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
MacExp: 	fno->fdate = ld_word(dp->dir + 22 + 2);	/* Date */
 2727  	}
 2728  	
 2729  	#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
 2730  	
 2731  	
 2732  	
 2733  	#if FF_USE_FIND && FF_FS_MINIMIZE <= 1
MacExp: #if 0 && 0 <= 1
 2734 X	/*-----------------------------------------------------------------------*/
 2735 X	/* Pattern matching                                                      */
 2736 X	/*-----------------------------------------------------------------------*/
 2737 X	
 2738 X	static DWORD get_achar (	/* Get a character and advances ptr */
 2739 X		const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
 2740 X	)
 2741 X	{
 2742 X		DWORD chr;
 2743 X	
 2744 X	
 2745 X	#if FF_USE_LFN && FF_LFN_UNICODE >= 1	/* Unicode input */
MacExp: #if 1 && 0 >= 1	/* Unicode input */
 2746 X		chr = tchar2uni(ptr);
 2747 X		if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
 2748 X		chr = ff_wtoupper(chr);
 2749 X	
 2750 X	#else									/* ANSI/OEM input */
 2751 X		chr = (BYTE)*(*ptr)++;				/* Get a byte */
 2752 X		if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
 2753 X	#if FF_CODE_PAGE == 0
MacExp: #if 437 == 0
 2754 X		if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 2755 X	#elif FF_CODE_PAGE < 900
 2756 X		if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 2757 X	#endif
 2758 X	#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
MacExp: #if 437 == 0 || 437 >= 900
 2759 X		if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd byte if needed */
 2760 X			chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
 2761 X		}
 2762 X	#endif
 2763 X	
 2764 X	#endif
 2765 X		return chr;
 2766 X	}
 2767 X	
 2768 X	
 2769 X	static int pattern_matching (	/* 0:not matched, 1:matched */
 2770 X		const TCHAR* pat,	/* Matching pattern */
 2771 X		const TCHAR* nam,	/* String to be tested */
 2772 X		int skip,			/* Number of pre-skip chars (number of ?s) */
 2773 X		int inf				/* Infinite search (* specified) */
 2774 X	)
 2775 X	{
 2776 X		const TCHAR *pp, *np;
 2777 X		DWORD pc, nc;
 2778 X		int nm, nx;
 2779 X	
 2780 X	
 2781 X		while (skip--) {				/* Pre-skip name chars */
 2782 X			if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 2783 X		}
 2784 X		if (*pat == 0 && inf) return 1;	/* (short circuit) */
 2785 X	
 2786 X		do {
 2787 X			pp = pat; np = nam;			/* Top of pattern and name to match */
 2788 X			while (1) {
 2789 X				if (*pp == '?' || *pp == '*') {	/* Wildcard? */
 2790 X					nm = nx = 0;
 2791 X					do {				/* Analyze the wildcard block */
 2792 X						if (*pp++ == '?') nm++; else nx = 1;
 2793 X					} while (*pp == '?' || *pp == '*');
 2794 X					if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
 2795 X					nc = *np; break;	/* Branch mismatched */
 2796 X				}
 2797 X				pc = get_achar(&pp);	/* Get a pattern char */
 2798 X				nc = get_achar(&np);	/* Get a name char */
 2799 X				if (pc != nc) break;	/* Branch mismatched? */
 2800 X				if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 2801 X			}
 2802 X			get_achar(&nam);			/* nam++ */
 2803 X		} while (inf && nc);			/* Retry until end of name if infinite search is specified */
 2804 X	
 2805 X		return 0;
 2806 X	}
 2807 X	
 2808  	#endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
 2809  	
 2810  	
 2811  	
 2812 C	/*-----------------------------------------------------------------------*/
 2813 C	/* Pick a top segment and create the object name in directory form       */
 2814 C	/*-----------------------------------------------------------------------*/
 2815 C	
 2816  	static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
 2817  		DIR* dp,					/* Pointer to the directory object */
 2818  		const TCHAR** path			/* Pointer to pointer to the segment in the path string */
 2819  	)
 2820  	{
 2821  	#if FF_USE_LFN		/* LFN configuration */
MacExp: #if 1		/* LFN configuration */
 2822  		BYTE b, cf;
 2823  		WCHAR wc, *lfn;
 2824  		DWORD uc;
 2825  		UINT i, ni, si, di;
 2826  		const TCHAR *p;
 2827  	
 2828  	
 2829 C		/* Create LFN into LFN working buffer */
 2830  		p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 2831  		while (1) {
 2832  			uc = tchar2uni(&p);			/* Get a character */
 2833  			if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
 2834  			if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
 2835  			wc = (WCHAR)uc;
 2836  			if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is found */
 2837  			if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 2838  			if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
MacExp: 		if (di >= 255) return FR_INVALID_NAME;	/* Reject too long name */
 2839  			lfn[di++] = wc;					/* Store the Unicode character */
 2840  		}
 2841  		while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
 2842  		*path = p;							/* Return pointer to the next segment */
 2843  		cf = (wc < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
MacExp: 	cf = (wc < ' ') ? 0x04 : 0;		/* Set last segment flag if end of the path */
 2844  	
 2845  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 2846  		if ((di == 1 && lfn[di - 1] == '.') ||
 2847  			(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
 2848  			lfn[di] = 0;
 2849  			for (i = 0; i < 11; i++) {		/* Create dot name for SFN entry */
 2850  				dp->fn[i] = (i < di) ? '.' : ' ';
 2851  			}
 2852  			dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
MacExp: 		dp->fn[i] = cf | 0x20;		/* This is a dot entry */
 2853  			return FR_OK;
 2854  		}
 2855  	#endif
 2856  		while (di) {						/* Snip off trailing spaces and dots if exist */
 2857  			wc = lfn[di - 1];
 2858  			if (wc != ' ' && wc != '.') break;
 2859  			di--;
 2860  		}
 2861  		lfn[di] = 0;							/* LFN is created into the working buffer */
 2862  		if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
 2863  	
 2864 C		/* Create SFN in directory form */
 2865  		for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 2866  		if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
MacExp: 	if (si > 0 || lfn[si] == '.') cf |= 0x01 | 0x02;	/* Is there any leading space or dot? */
 2867  		while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 2868  	
 2869  		mem_set(dp->fn, ' ', 11);
 2870  		i = b = 0; ni = 8;
 2871  		while (1) {
 2872  			wc = lfn[si++];					/* Get an LFN character */
 2873  			if (wc == 0) break;				/* Break on end of the LFN */
 2874  			if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 2875  				cf |= NS_LOSS | NS_LFN;
MacExp: 			cf |= 0x01 | 0x02;
 2876  				continue;
 2877  			}
 2878  	
 2879  			if (i >= ni || si == di) {		/* End of field? */
 2880  				if (ni == 11) {				/* Name extension overflow? */
 2881  					cf |= NS_LOSS | NS_LFN;
MacExp: 				cf |= 0x01 | 0x02;
 2882  					break;
 2883  				}
 2884  				if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
MacExp: 			if (si != di) cf |= 0x01 | 0x02;	/* Name body overflow? */
 2885  				if (si > di) break;						/* No name extension? */
 2886  				si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 2887  				continue;
 2888  			}
 2889  	
 2890  			if (wc >= 0x80) {	/* Is this a non-ASCII character? */
 2891  				cf |= NS_LFN;	/* LFN entry needs to be created */
MacExp: 			cf |= 0x02;	/* LFN entry needs to be created */
 2892  	#if FF_CODE_PAGE == 0
MacExp: #if 437 == 0
 2893 X				if (ExCvt) {	/* At SBCS */
 2894 X					wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 2895 X					if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 2896 X				} else {		/* At DBCS */
 2897 X					wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
 2898 X				}
 2899  	#elif FF_CODE_PAGE < 900	/* SBCS cfg */
MacExp: #elif 437 < 900	/* SBCS cfg */
 2900  				wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
MacExp: 			wc = ff_uni2oem(wc, 437);			/* Unicode ==> ANSI/OEM code */
 2901  				if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 2902  	#else						/* DBCS cfg */
 2903 X				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
 2904  	#endif
 2905  			}
 2906  	
 2907  			if (wc >= 0x100) {				/* Is this a DBC? */
 2908  				if (i >= ni - 1) {			/* Field overflow? */
 2909  					cf |= NS_LOSS | NS_LFN;
MacExp: 				cf |= 0x01 | 0x02;
 2910  					i = ni; continue;		/* Next field */
 2911  				}
 2912  				dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
 2913  			} else {						/* SBC */
 2914  				if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
 2915  					wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
MacExp: 				wc = '_'; cf |= 0x01 | 0x02;/* Lossy conversion */
 2916  				} else {
 2917  					if (IsUpper(wc)) {		/* ASCII upper case? */
MacExp: 				if (((wc) >= 'A' && (wc) <= 'Z')) {		/* ASCII upper case? */
 2918  						b |= 2;
 2919  					}
 2920  					if (IsLower(wc)) {		/* ASCII lower case? */
MacExp: 				if (((wc) >= 'a' && (wc) <= 'z')) {		/* ASCII lower case? */
 2921  						b |= 1; wc -= 0x20;
 2922  					}
 2923  				}
 2924  			}
 2925  			dp->fn[i++] = (BYTE)wc;
 2926  		}
 2927  	
 2928  		if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
MacExp: 	if (dp->fn[0] == 0xE5) dp->fn[0] = 0x05;	/* If the first character collides with DDEM, replace it with RDDEM */
 2929  	
 2930  		if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 2931  		if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
MacExp: 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= 0x02;	/* LFN entry needs to be created if composite capitals */
 2932  		if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
MacExp: 	if (!(cf & 0x02)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 2933  			if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
MacExp: 		if (b & 0x01) cf |= 0x10;		/* NT flag (Extension has small capital letters only) */
 2934  			if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
MacExp: 		if (b & 0x04) cf |= 0x08;	/* NT flag (Body has small capital letters only) */
 2935  		}
 2936  	
 2937  		dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
MacExp: 	dp->fn[11] = cf;	/* SFN is created into dp->fn[] */
 2938  	
 2939  		return FR_OK;
 2940  	
 2941  	
 2942  	#else	/* FF_USE_LFN : Non-LFN configuration */
 2943 X		BYTE c, d, *sfn;
 2944 X		UINT ni, si, i;
 2945 X		const char *p;
 2946 X	
 2947 X		/* Create file name in directory form */
 2948 X		p = *path; sfn = dp->fn;
 2949 X		mem_set(sfn, ' ', 11);
 2950 X		si = i = 0; ni = 8;
 2951 X	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 2952 X		if (p[si] == '.') { /* Is this a dot entry? */
 2953 X			while (1) {
 2954 X				c = (BYTE)p[si++];
 2955 X				if (c != '.' || si >= 3) break;
 2956 X				sfn[i++] = c;
 2957 X			}
 2958 X			if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 2959 X			*path = p + si;								/* Return pointer to the next segment */
 2960 X			sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
 2961 X			return FR_OK;
 2962 X		}
 2963 X	#endif
 2964 X		while (1) {
 2965 X			c = (BYTE)p[si++];				/* Get a byte */
 2966 X			if (c <= ' ') break; 			/* Break if end of the path name */
 2967 X			if (c == '/' || c == '\\') {	/* Break if a separator is found */
 2968 X				while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 2969 X				break;
 2970 X			}
 2971 X			if (c == '.' || i >= ni) {		/* End of body or field overflow? */
 2972 X				if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
 2973 X				i = 8; ni = 11;				/* Enter file extension field */
 2974 X				continue;
 2975 X			}
 2976 X	#if FF_CODE_PAGE == 0
MacExp: #if 437 == 0
 2977 X			if (ExCvt && c >= 0x80) {		/* Is SBC extended character? */
 2978 X				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 2979 X			}
 2980 X	#elif FF_CODE_PAGE < 900
 2981 X			if (c >= 0x80) {				/* Is SBC extended character? */
 2982 X				c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 2983 X			}
 2984 X	#endif
 2985 X			if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
 2986 X				d = (BYTE)p[si++];			/* Get 2nd byte */
 2987 X				if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
 2988 X				sfn[i++] = c;
 2989 X				sfn[i++] = d;
 2990 X			} else {						/* SBC */
 2991 X				if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
 2992 X				if (IsLower(c)) c -= 0x20;	/* To upper */
 2993 X				sfn[i++] = c;
 2994 X			}
 2995 X		}
 2996 X		*path = p + si;						/* Return pointer to the next segment */
 2997 X		if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 2998 X	
 2999 X		if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 3000 X		sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 3001 X	
 3002 X		return FR_OK;
 3003  	#endif /* FF_USE_LFN */
 3004  	}
 3005  	
 3006  	
 3007  	
 3008  	
 3009 C	/*-----------------------------------------------------------------------*/
 3010 C	/* Follow a file path                                                    */
 3011 C	/*-----------------------------------------------------------------------*/
 3012 C	
 3013  	static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 3014  		DIR* dp,					/* Directory object to return last directory and found object */
 3015  		const TCHAR* path			/* Full-path string to find a file or directory */
 3016  	)
 3017  	{
 3018  		FRESULT res;
 3019  		BYTE ns;
 3020  		FATFS *fs = dp->obj.fs;
 3021  	
 3022  	
 3023  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 3024  		if (*path != '/' && *path != '\\') {	/* Without heading separator */
 3025  			dp->obj.sclust = fs->cdir;				/* Start from current directory */
 3026  		} else
 3027  	#endif
 3028  		{										/* With heading separator */
 3029  			while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 3030  			dp->obj.sclust = 0;					/* Start from root directory */
 3031  		}
 3032  	#if FF_FS_EXFAT
MacExp: #if 0
 3033 X		dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
 3034 X	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 3035 X		if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {	/* exFAT: Retrieve the sub-directory's status */
 3036 X			DIR dj;
 3037 X	
 3038 X			dp->obj.c_scl = fs->cdc_scl;
 3039 X			dp->obj.c_size = fs->cdc_size;
 3040 X			dp->obj.c_ofs = fs->cdc_ofs;
 3041 X			res = load_obj_xdir(&dj, &dp->obj);
 3042 X			if (res != FR_OK) return res;
 3043 X			dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
 3044 X			dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
 3045 X		}
 3046 X	#endif
 3047  	#endif
 3048  	
 3049  		if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 3050  			dp->fn[NSFLAG] = NS_NONAME;
MacExp: 		dp->fn[11] = 0x80;
 3051  			res = dir_sdi(dp, 0);
 3052  	
 3053  		} else {								/* Follow path */
 3054  			while (1) {
 3055  				res = create_name(dp, &path);	/* Get a segment name of the path */
 3056  				if (res != FR_OK) break;
 3057  				res = dir_find(dp);				/* Find an object with the segment name */
 3058  				ns = dp->fn[NSFLAG];
MacExp: 			ns = dp->fn[11];
 3059  				if (res != FR_OK) {				/* Failed to find the object */
 3060  					if (res == FR_NO_FILE) {	/* Object is not found */
 3061  						if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
MacExp: 					if (1 && (ns & 0x20)) {	/* If dot entry is not exist, stay there */
 3062  							if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
MacExp: 						if (!(ns & 0x04)) continue;	/* Continue to follow if not last segment */
 3063  							dp->fn[NSFLAG] = NS_NONAME;
MacExp: 						dp->fn[11] = 0x80;
 3064  							res = FR_OK;
 3065  						} else {							/* Could not find the object */
 3066  							if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
MacExp: 						if (!(ns & 0x04)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 3067  						}
 3068  					}
 3069  					break;
 3070  				}
 3071  				if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
MacExp: 			if (ns & 0x04) break;			/* Last segment matched. Function completed. */
 3072 C				/* Get into the sub-directory */
 3073  				if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
MacExp: 			if (!(dp->obj.attr & 0x10)) {		/* It is not a sub-directory and cannot follow */
 3074  					res = FR_NO_PATH; break;
 3075  				}
 3076  	#if FF_FS_EXFAT
MacExp: #if 0
 3077 X				if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
 3078 X					dp->obj.c_scl = dp->obj.sclust;
 3079 X					dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 3080 X					dp->obj.c_ofs = dp->blk_ofs;
 3081 X					init_alloc_info(fs, &dp->obj);	/* Open next directory */
 3082 X				} else
 3083  	#endif
 3084  				{
 3085  					dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
MacExp: 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % ((UINT)512));	/* Open next directory */
 3086  				}
 3087  			}
 3088  		}
 3089  	
 3090  		return res;
 3091  	}
 3092  	
 3093  	
 3094  	
 3095  	
 3096 C	/*-----------------------------------------------------------------------*/
 3097 C	/* Get logical drive number from path name                               */
 3098 C	/*-----------------------------------------------------------------------*/
 3099 C	
 3100  	static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
 3101  		const TCHAR** path		/* Pointer to pointer to the path name */
 3102  	)
 3103  	{
 3104  		const TCHAR *tp, *tt;
 3105  		TCHAR tc;
 3106  		int i, vol = -1;
 3107  	#if FF_STR_VOLUME_ID		/* Find string volume ID */
MacExp: #if 0		/* Find string volume ID */
 3108 X		const char *sp;
 3109 X		char c;
 3110  	#endif
 3111  	
 3112  		tt = tp = *path;
 3113  		if (!tp) return vol;	/* Invalid path name? */
 3114  		do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
MacExp: 	do tc = *tt++; while ((UINT)tc >= (1 ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 3115  	
 3116  		if (tc == ':') {	/* DOS/Windows style volume ID? */
 3117  			i = FF_VOLUMES;
MacExp: 		i = 1;
 3118  			if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
MacExp: 		if (((*tp) >= '0' && (*tp) <= '9') && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 3119  				i = (int)*tp - '0';	/* Get the LD number */
 3120  			}
 3121  	#if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
MacExp: #if 0 == 1	/* Arbitrary string is enabled */
 3122 X			else {
 3123 X				i = 0;
 3124 X				do {
 3125 X					sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
 3126 X					do {	/* Compare the volume ID with path name */
 3127 X						c = *sp++; tc = *tp++;
 3128 X						if (IsLower(c)) c -= 0x20;
 3129 X						if (IsLower(tc)) tc -= 0x20;
 3130 X					} while (c && (TCHAR)c == tc);
 3131 X				} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
 3132 X			}
 3133  	#endif
 3134  			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
MacExp: 		if (i < 1) {	/* If a volume ID is found, get the drive number and strip it */
 3135  				vol = i;		/* Drive number */
 3136  				*path = tt;		/* Snip the drive prefix off */
 3137  			}
 3138  			return vol;
 3139  		}
 3140  	#if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
MacExp: #if 0 == 2		/* Unix style volume ID is enabled */
 3141 X		if (*tp == '/') {
 3142 X			i = 0;
 3143 X			do {
 3144 X				sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
 3145 X				do {	/* Compare the volume ID with path name */
 3146 X					c = *sp++; tc = *(++tp);
 3147 X					if (IsLower(c)) c -= 0x20;
 3148 X					if (IsLower(tc)) tc -= 0x20;
 3149 X				} while (c && (TCHAR)c == tc);
 3150 X			} while ((c || (tc != '/' && (UINT)tc >= (FF_USE_LFN ? ' ' : '!'))) && ++i < FF_VOLUMES);	/* Repeat for each ID until pattern match */
 3151 X			if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 3152 X				vol = i;		/* Drive number */
 3153 X				*path = tp;		/* Snip the drive prefix off */
 3154 X				return vol;
 3155 X			}
 3156 X		}
 3157  	#endif
 3158 C		/* No drive prefix is found */
 3159  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 3160  		vol = CurrVol;	/* Default drive is current drive */
 3161  	#else
 3162 X		vol = 0;		/* Default drive is 0 */
 3163  	#endif
 3164  		return vol;		/* Return the default drive */
 3165  	}
 3166  	
 3167  	
 3168  	
 3169  	
 3170 C	/*-----------------------------------------------------------------------*/
 3171 C	/* Load a sector and check if it is an FAT VBR                           */
 3172 C	/*-----------------------------------------------------------------------*/
 3173 C	
 3174  	static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
 3175  		FATFS* fs,			/* Filesystem object */
 3176  		DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
 3177  	)
 3178  	{
 3179  		fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 3180  		if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 3181  	
 3182  		if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
MacExp: 	if (ld_word(fs->win + 510) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 3183  	
 3184  	#if FF_FS_EXFAT
MacExp: #if 0
 3185 X		if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
 3186  	#endif
 3187  		if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
MacExp: 	if (fs->win[0] == 0xE9 || fs->win[0] == 0xEB || fs->win[0] == 0xE8) {	/* Valid JumpBoot code? */
 3188  			if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
MacExp: 		if (!mem_cmp(fs->win + 54, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 3189  			if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
MacExp: 		if (!mem_cmp(fs->win + 82, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
 3190  		}
 3191  		return 2;	/* Valid BS but not FAT */
 3192  	}
 3193  	
 3194  	
 3195  	
 3196  	
 3197 C	/*-----------------------------------------------------------------------*/
 3198 C	/* Determine logical drive number and mount the volume if needed         */
 3199 C	/*-----------------------------------------------------------------------*/
 3200 C	
 3201  	static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
 3202  		const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
 3203  		FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
 3204  		BYTE mode					/* !=0: Check write protection for write access */
 3205  	)
 3206  	{
 3207  		BYTE fmt, *pt;
 3208  		int vol;
 3209  		DSTATUS stat;
 3210  		DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
 3211  		WORD nrsv;
 3212  		FATFS *fs;
 3213  		UINT i;
 3214  	
 3215  	
 3216 C		/* Get logical drive number */
 3217  		*rfs = 0;
 3218  		vol = get_ldnumber(path);
 3219  		if (vol < 0) return FR_INVALID_DRIVE;
 3220  	
 3221 C		/* Check if the filesystem object is valid or not */
 3222  		fs = FatFs[vol];					/* Get pointer to the filesystem object */
 3223  		if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 3224  	#if FF_FS_REENTRANT
MacExp: #if 0
 3225 X		if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
 3226  	#endif
 3227  		*rfs = fs;							/* Return pointer to the filesystem object */
 3228  	
 3229  		mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
MacExp: 	mode &= (BYTE)~0x01;				/* Desired access mode, write access or not */
 3230  		if (fs->fs_type != 0) {				/* If the volume has been mounted */
 3231  			stat = disk_status(fs->pdrv);
 3232  			if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
MacExp: 		if (!(stat & 0x01)) {		/* and the physical drive is kept initialized */
 3233  				if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
MacExp: 			if (!0 && mode && (stat & 0x04)) {	/* Check write protection if needed */
 3234  					return FR_WRITE_PROTECTED;
 3235  				}
 3236  				return FR_OK;				/* The filesystem object is valid */
 3237  			}
 3238  		}
 3239  	
 3240 C		/* The filesystem object is not valid. */
 3241 C		/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */
 3242 C	
 3243  		fs->fs_type = 0;					/* Clear the filesystem object */
 3244  		fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
MacExp: 	fs->pdrv = (BYTE)(vol);				/* Bind the logical drive and a physical drive */
 3245  		stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 3246  		if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
MacExp: 	if (stat & 0x01) { 			/* Check if the initialization succeeded */
 3247  			return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 3248  		}
 3249  		if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
MacExp: 	if (!0 && mode && (stat & 0x04)) { /* Check disk write protection if needed */
 3250  			return FR_WRITE_PROTECTED;
 3251  		}
 3252  	#if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
MacExp: #if 512 != 512				/* Get sector size (multiple sector size cfg only) */
 3253 X		if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
 3254 X		if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
 3255  	#endif
 3256  	
 3257 C		/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
 3258  		bsect = 0;
 3259  		fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 3260  		if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
MacExp: 	if (fmt == 2 || (fmt < 2 && 0 != 0)) {	/* Not an FAT-VBR or forced partition number */
 3261  			for (i = 0; i < 4; i++) {		/* Get partition offset */
 3262  				pt = fs->win + (MBR_Table + i * SZ_PTE);
MacExp: 			pt = fs->win + (446 + i * 16);
 3263  				br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
MacExp: 			br[i] = pt[4] ? ld_dword(pt + 8) : 0;
 3264  			}
 3265  			i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
MacExp: 		i = 0;					/* Partition number: 0:auto, 1-4:forced */
 3266  			if (i != 0) i--;
 3267  			do {							/* Find an FAT volume */
 3268  				bsect = br[i];
 3269  				fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 3270  			} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
MacExp: 		} while (0 == 0 && fmt >= 2 && ++i < 4);
 3271  		}
 3272  		if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 3273  		if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 3274  	
 3275 C		/* An FAT volume is found (bsect). Following code initializes the filesystem object */
 3276 C	
 3277  	#if FF_FS_EXFAT
MacExp: #if 0
 3278 X		if (fmt == 1) {
 3279 X			QWORD maxlba;
 3280 X	
 3281 X			for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 3282 X			if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
 3283 X	
 3284 X			if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
 3285 X	
 3286 X			if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
 3287 X				return FR_NO_FILESYSTEM;
 3288 X			}
 3289 X	
 3290 X			maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
 3291 X			if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
 3292 X	
 3293 X			fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 3294 X	
 3295 X			fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 3296 X			if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 3297 X	
 3298 X			fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
 3299 X			if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
 3300 X	
 3301 X			nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
 3302 X			if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
 3303 X			fs->n_fatent = nclst + 2;
 3304 X	
 3305 X			/* Boundaries and Limits */
 3306 X			fs->volbase = bsect;
 3307 X			fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 3308 X			fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 3309 X			if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 3310 X			fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 3311 X	
 3312 X			/* Check if bitmap location is in assumption (at the first cluster) */
 3313 X			if (move_window(fs, clst2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
 3314 X			for (i = 0; i < SS(fs); i += SZDIRE) {
 3315 X				if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
 3316 X			}
 3317 X			if (i == SS(fs)) return FR_NO_FILESYSTEM;
 3318 X	#if !FF_FS_READONLY
MacExp: #if !0
 3319 X			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 3320 X	#endif
 3321 X			fmt = FS_EXFAT;			/* FAT sub-type */
 3322 X		} else
 3323  	#endif	/* FF_FS_EXFAT */
 3324  		{
 3325  			if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
MacExp: 		if (ld_word(fs->win + 11) != ((UINT)512)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 3326  	
 3327  			fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
MacExp: 		fasize = ld_word(fs->win + 22);		/* Number of sectors per FAT */
 3328  			if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
MacExp: 		if (fasize == 0) fasize = ld_dword(fs->win + 36);
 3329  			fs->fsize = fasize;
 3330  	
 3331  			fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
MacExp: 		fs->n_fats = fs->win[16];				/* Number of FATs */
 3332  			if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 3333  			fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 3334  	
 3335  			fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
MacExp: 		fs->csize = fs->win[13];			/* Cluster size */
 3336  			if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 3337  	
 3338  			fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
MacExp: 		fs->n_rootdir = ld_word(fs->win + 17);	/* Number of root directory entries */
 3339  			if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
MacExp: 		if (fs->n_rootdir % (((UINT)512) / 32)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 3340  	
 3341  			tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
MacExp: 		tsect = ld_word(fs->win + 19);		/* Number of sectors on the volume */
 3342  			if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
MacExp: 		if (tsect == 0) tsect = ld_dword(fs->win + 32);
 3343  	
 3344  			nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
MacExp: 		nrsv = ld_word(fs->win + 14);		/* Number of reserved sectors */
 3345  			if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 3346  	
 3347 C			/* Determine the FAT sub type */
 3348  			sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
MacExp: 		sysect = nrsv + fasize + fs->n_rootdir / (((UINT)512) / 32);	/* RSV + FAT + DIR */
 3349  			if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 3350  			nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 3351  			if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 3352  			fmt = 0;
 3353  			if (nclst <= MAX_FAT32) fmt = FS_FAT32;
MacExp: 		if (nclst <= 0x0FFFFFF5) fmt = 3;
 3354  			if (nclst <= MAX_FAT16) fmt = FS_FAT16;
MacExp: 		if (nclst <= 0xFFF5) fmt = 2;
 3355  			if (nclst <= MAX_FAT12) fmt = FS_FAT12;
MacExp: 		if (nclst <= 0xFF5) fmt = 1;
 3356  			if (fmt == 0) return FR_NO_FILESYSTEM;
 3357  	
 3358 C			/* Boundaries and Limits */
 3359  			fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 3360  			fs->volbase = bsect;							/* Volume start sector */
 3361  			fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 3362  			fs->database = bsect + sysect;					/* Data start sector */
 3363  			if (fmt == FS_FAT32) {
MacExp: 		if (fmt == 3) {
 3364  				if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
MacExp: 			if (ld_word(fs->win + 42) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 3365  				if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 3366  				fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
MacExp: 			fs->dirbase = ld_dword(fs->win + 44);	/* Root directory start cluster */
 3367  				szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 3368  			} else {
 3369  				if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 3370  				fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 3371  				szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
MacExp: 			szbfat = (fmt == 2) ?				/* (Needed FAT size) */
 3372  					fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 3373  			}
 3374  			if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
MacExp: 		if (fs->fsize < (szbfat + (((UINT)512) - 1)) / ((UINT)512)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 3375  	
 3376  	#if !FF_FS_READONLY
MacExp: #if !0
 3377 C			/* Get FSInfo if available */
 3378  			fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 3379  			fs->fsi_flag = 0x80;
 3380  	#if (FF_FS_NOFSINFO & 3) != 3
MacExp: #if (0 & 3) != 3
 3381  			if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
MacExp: 		if (fmt == 3				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 3382  				&& ld_word(fs->win + BPB_FSInfo32) == 1
MacExp: 			&& ld_word(fs->win + 48) == 1
 3383  				&& move_window(fs, bsect + 1) == FR_OK)
 3384  			{
 3385  				fs->fsi_flag = 0;
 3386  				if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
MacExp: 			if (ld_word(fs->win + 510) == 0xAA55	/* Load FSInfo data if available */
 3387  					&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
MacExp: 				&& ld_dword(fs->win + 0) == 0x41615252
 3388  					&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
MacExp: 				&& ld_dword(fs->win + 484) == 0x61417272)
 3389  				{
 3390  	#if (FF_FS_NOFSINFO & 1) == 0
MacExp: #if (0 & 1) == 0
 3391  					fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
MacExp: 				fs->free_clst = ld_dword(fs->win + 488);
 3392  	#endif
 3393  	#if (FF_FS_NOFSINFO & 2) == 0
MacExp: #if (0 & 2) == 0
 3394  					fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
MacExp: 				fs->last_clst = ld_dword(fs->win + 492);
 3395  	#endif
 3396  				}
 3397  			}
 3398  	#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
 3399  	#endif	/* !FF_FS_READONLY */
 3400  		}
 3401  	
 3402  		fs->fs_type = fmt;		/* FAT sub-type */
 3403  		fs->id = ++Fsid;		/* Volume mount ID */
 3404  	#if FF_USE_LFN == 1
MacExp: #if 1 == 1
 3405  		fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 3406  	#if FF_FS_EXFAT
MacExp: #if 0
 3407 X		fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 3408  	#endif
 3409  	#endif
 3410  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 3411  		fs->cdir = 0;			/* Initialize current directory */
 3412  	#endif
 3413  	#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
MacExp: #if 0 != 0			/* Clear file lock semaphores */
 3414 X		clear_lock(fs);
 3415  	#endif
 3416  		return FR_OK;
 3417  	}
 3418  	
 3419  	
 3420  	
 3421  	
 3422 C	/*-----------------------------------------------------------------------*/
 3423 C	/* Check if the file/directory object is valid or not                    */
 3424 C	/*-----------------------------------------------------------------------*/
 3425 C	
 3426  	static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
 3427  		FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
 3428  		FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
 3429  	)
 3430  	{
 3431  		FRESULT res = FR_INVALID_OBJECT;
 3432  	
 3433  	
 3434  		if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 3435  	#if FF_FS_REENTRANT
MacExp: #if 0
 3436 X			if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
 3437 X				if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 3438 X					res = FR_OK;
 3439 X				} else {
 3440 X					unlock_fs(obj->fs, FR_OK);
 3441 X				}
 3442 X			} else {
 3443 X				res = FR_TIMEOUT;
 3444 X			}
 3445  	#else
 3446  			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
MacExp: 		if (!(disk_status(obj->fs->pdrv) & 0x01)) { /* Test if the phsical drive is kept initialized */
 3447  				res = FR_OK;
 3448  			}
 3449  	#endif
 3450  		}
 3451  		*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 3452  		return res;
 3453  	}
 3454  	
 3455  	
 3456  	
 3457  	
 3458 C	/*---------------------------------------------------------------------------
 3459 C	
 3460 C	   Public Functions (FatFs API)
 3461 C	
 3462 C	----------------------------------------------------------------------------*/
 3463 C	
 3464 C	
 3465 C	
 3466 C	/*-----------------------------------------------------------------------*/
 3467 C	/* Mount/Unmount a Logical Drive                                         */
 3468 C	/*-----------------------------------------------------------------------*/
 3469 C	
 3470  	FRESULT f_mount (
 3471  		FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
 3472  		const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
 3473  		BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
 3474  	)
 3475  	{
 3476  		FATFS *cfs;
 3477  		int vol;
 3478  		FRESULT res;
 3479  		const TCHAR *rp = path;
 3480  	
 3481  	
 3482 C		/* Get logical drive number */
 3483  		vol = get_ldnumber(&rp);
 3484  		if (vol < 0) return FR_INVALID_DRIVE;
 3485  		cfs = FatFs[vol];					/* Pointer to fs object */
 3486  	
 3487  		if (cfs) {
 3488  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 3489 X			clear_lock(cfs);
 3490  	#endif
 3491  	#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
MacExp: #if 0						/* Discard sync object of the current volume */
 3492 X			if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
 3493  	#endif
 3494  			cfs->fs_type = 0;				/* Clear old fs object */
 3495  		}
 3496  	
 3497  		if (fs) {
 3498  			fs->fs_type = 0;				/* Clear new fs object */
 3499  	#if FF_FS_REENTRANT						/* Create sync object for the new volume */
MacExp: #if 0						/* Create sync object for the new volume */
 3500 X			if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
 3501  	#endif
 3502  		}
 3503  		FatFs[vol] = fs;					/* Register new fs object */
 3504  	
 3505  		if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 3506  	
 3507  		res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 3508  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 3509  	}
 3510  	
 3511  	
 3512  	
 3513  	
 3514 C	/*-----------------------------------------------------------------------*/
 3515 C	/* Open or Create a File                                                 */
 3516 C	/*-----------------------------------------------------------------------*/
 3517 C	
 3518  	FRESULT f_open (
 3519  		FIL* fp,			/* Pointer to the blank file object */
 3520  		const TCHAR* path,	/* Pointer to the file name */
 3521  		BYTE mode			/* Access mode and file open mode flags */
 3522  	)
 3523  	{
 3524  		FRESULT res;
 3525  		DIR dj;
 3526  		FATFS *fs;
 3527  	#if !FF_FS_READONLY
MacExp: #if !0
 3528  		DWORD dw, cl, bcs, clst, sc;
 3529  		FSIZE_t ofs;
 3530  	#endif
 3531  		DEF_NAMBUF
MacExp: 	
 3532  	
 3533  	
 3534  		if (!fp) return FR_INVALID_OBJECT;
 3535  	
 3536 C		/* Get logical drive number */
 3537  		mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
MacExp: 	mode &= 0 ? 0x01 : 0x01 | 0x02 | 0x08 | 0x04 | 0x10 | 0x30;
 3538  		res = find_volume(&path, &fs, mode);
 3539  		if (res == FR_OK) {
 3540  			dj.obj.fs = fs;
 3541  			INIT_NAMBUF(fs);
MacExp: 		;
 3542  			res = follow_path(&dj, path);	/* Follow the file path */
 3543  	#if !FF_FS_READONLY	/* Read/Write configuration */
MacExp: #if !0	/* Read/Write configuration */
 3544  			if (res == FR_OK) {
 3545  				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
MacExp: 			if (dj.fn[11] & 0x80) {	/* Origin directory itself? */
 3546  					res = FR_INVALID_NAME;
 3547  				}
 3548  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 3549 X				else {
 3550 X					res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
 3551 X				}
 3552  	#endif
 3553  			}
 3554 C			/* Create or Open a file */
 3555  			if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
MacExp: 		if (mode & (0x08 | 0x10 | 0x04)) {
 3556  				if (res != FR_OK) {					/* No file, create new */
 3557  					if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 3558  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 3559 X						res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 3560  	#else
 3561  						res = dir_register(&dj);
 3562  	#endif
 3563  					}
 3564  					mode |= FA_CREATE_ALWAYS;		/* File is created */
MacExp: 				mode |= 0x08;		/* File is created */
 3565  				}
 3566  				else {								/* Any object with the same name is already existing */
 3567  					if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
MacExp: 				if (dj.obj.attr & (0x01 | 0x10)) {	/* Cannot overwrite it (R/O or DIR) */
 3568  						res = FR_DENIED;
 3569  					} else {
 3570  						if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
MacExp: 					if (mode & 0x04) res = FR_EXIST;	/* Cannot create as new file */
 3571  					}
 3572  				}
 3573  				if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
MacExp: 			if (res == FR_OK && (mode & 0x08)) {	/* Truncate the file if overwrite mode */
 3574  	#if FF_FS_EXFAT
MacExp: #if 0
 3575 X					if (fs->fs_type == FS_EXFAT) {
 3576 X						/* Get current allocation info */
 3577 X						fp->obj.fs = fs;
 3578 X						init_alloc_info(fs, &fp->obj);
 3579 X						/* Set directory entry block initial state */
 3580 X						mem_set(fs->dirbuf + 2, 0, 30);		/* Clear 85 entry except for NumSec */
 3581 X						mem_set(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
 3582 X						fs->dirbuf[XDIR_Attr] = AM_ARC;
 3583 X						st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
 3584 X						fs->dirbuf[XDIR_GenFlags] = 1;
 3585 X						res = store_xdir(&dj);
 3586 X						if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
 3587 X							res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 3588 X							fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
 3589 X						}
 3590 X					} else
 3591  	#endif
 3592  					{
 3593 C						/* Set directory entry initial state */
 3594  						cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 3595  						st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
MacExp: 					st_dword(dj.dir + 14, get_fattime());	/* Set created time */
 3596  						dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
MacExp: 					dj.dir[11] = 0x20;			/* Reset attribute */
 3597  						st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 3598  						st_dword(dj.dir + DIR_FileSize, 0);
MacExp: 					st_dword(dj.dir + 28, 0);
 3599  						fs->wflag = 1;
 3600  						if (cl != 0) {						/* Remove the cluster chain if exist */
 3601  							dw = fs->winsect;
 3602  							res = remove_chain(&dj.obj, cl, 0);
 3603  							if (res == FR_OK) {
 3604  								res = move_window(fs, dw);
 3605  								fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 3606  							}
 3607  						}
 3608  					}
 3609  				}
 3610  			}
 3611  			else {	/* Open an existing file */
 3612  				if (res == FR_OK) {					/* Is the object exsiting? */
 3613  					if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
MacExp: 				if (dj.obj.attr & 0x10) {		/* File open against a directory */
 3614  						res = FR_NO_FILE;
 3615  					} else {
 3616  						if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
MacExp: 					if ((mode & 0x02) && (dj.obj.attr & 0x01)) { /* Write mode open against R/O file */
 3617  							res = FR_DENIED;
 3618  						}
 3619  					}
 3620  				}
 3621  			}
 3622  			if (res == FR_OK) {
 3623  				if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
MacExp: 			if (mode & 0x08) mode |= 0x40;	/* Set file change flag if created or overwritten */
 3624  				fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 3625  				fp->dir_ptr = dj.dir;
 3626  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 3627 X				fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
 3628 X				if (fp->obj.lockid == 0) res = FR_INT_ERR;
 3629  	#endif
 3630  			}
 3631  	#else		/* R/O configuration */
 3632 X			if (res == FR_OK) {
 3633 X				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it origin directory itself? */
 3634 X					res = FR_INVALID_NAME;
 3635 X				} else {
 3636 X					if (dj.obj.attr & AM_DIR) {		/* Is it a directory? */
 3637 X						res = FR_NO_FILE;
 3638 X					}
 3639 X				}
 3640 X			}
 3641  	#endif
 3642  	
 3643  			if (res == FR_OK) {
 3644  	#if FF_FS_EXFAT
MacExp: #if 0
 3645 X				if (fs->fs_type == FS_EXFAT) {
 3646 X					fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 3647 X					fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 3648 X					fp->obj.c_ofs = dj.blk_ofs;
 3649 X					init_alloc_info(fs, &fp->obj);
 3650 X				} else
 3651  	#endif
 3652  				{
 3653  					fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 3654  					fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
MacExp: 				fp->obj.objsize = ld_dword(dj.dir + 28);
 3655  				}
 3656  	#if FF_USE_FASTSEEK
MacExp: #if 0
 3657 X				fp->cltbl = 0;			/* Disable fast seek mode */
 3658  	#endif
 3659  				fp->obj.fs = fs;	 	/* Validate the file object */
 3660  				fp->obj.id = fs->id;
 3661  				fp->flag = mode;		/* Set file access mode */
 3662  				fp->err = 0;			/* Clear error flag */
 3663  				fp->sect = 0;			/* Invalidate current data sector */
 3664  				fp->fptr = 0;			/* Set file pointer top of the file */
 3665  	#if !FF_FS_READONLY
MacExp: #if !0
 3666  	#if !FF_FS_TINY
MacExp: #if !1
 3667 X				mem_set(fp->buf, 0, FF_MAX_SS);	/* Clear sector buffer */
 3668  	#endif
 3669  				if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
MacExp: 			if ((mode & 0x20) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 3670  					fp->fptr = fp->obj.objsize;			/* Offset to seek */
 3671  					bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
MacExp: 				bcs = (DWORD)fs->csize * ((UINT)512);	/* Cluster size in byte */
 3672  					clst = fp->obj.sclust;				/* Follow the cluster chain */
 3673  					for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 3674  						clst = get_fat(&fp->obj, clst);
 3675  						if (clst <= 1) res = FR_INT_ERR;
 3676  						if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 3677  					}
 3678  					fp->clust = clst;
 3679  					if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
MacExp: 				if (res == FR_OK && ofs % ((UINT)512)) {	/* Fill sector buffer if not on the sector boundary */
 3680  						if ((sc = clst2sect(fs, clst)) == 0) {
 3681  							res = FR_INT_ERR;
 3682  						} else {
 3683  							fp->sect = sc + (DWORD)(ofs / SS(fs));
MacExp: 						fp->sect = sc + (DWORD)(ofs / ((UINT)512));
 3684  	#if !FF_FS_TINY
MacExp: #if !1
 3685 X							if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 3686  	#endif
 3687  						}
 3688  					}
 3689  				}
 3690  	#endif
 3691  			}
 3692  	
 3693  			FREE_NAMBUF();
MacExp: 		;
 3694  		}
 3695  	
 3696  		if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 3697  	
 3698  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 3699  	}
 3700  	
 3701  	
 3702  	
 3703  	
 3704 C	/*-----------------------------------------------------------------------*/
 3705 C	/* Read File                                                             */
 3706 C	/*-----------------------------------------------------------------------*/
 3707 C	
 3708  	FRESULT f_read (
 3709  		FIL* fp, 	/* Pointer to the file object */
 3710  		void* buff,	/* Pointer to data buffer */
 3711  		UINT btr,	/* Number of bytes to read */
 3712  		UINT* br	/* Pointer to number of bytes read */
 3713  	)
 3714  	{
 3715  		FRESULT res;
 3716  		FATFS *fs;
 3717  		DWORD clst, sect;
 3718  		FSIZE_t remain;
 3719  		UINT rcnt, cc, csect;
 3720  		BYTE *rbuff = (BYTE*)buff;
 3721  	
 3722  	
 3723  		*br = 0;	/* Clear read byte counter */
 3724  		res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 3725  		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
MacExp: 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return  res;	/* Check validity */
 3726  		if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
MacExp: 	if (!(fp->flag & 0x01)) return  FR_DENIED; /* Check access mode */
 3727  		remain = fp->obj.objsize - fp->fptr;
 3728  		if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 3729  	
 3730  		for ( ;  btr;								/* Repeat until btr bytes read */
 3731  			btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 3732  			if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
MacExp: 		if (fp->fptr % ((UINT)512) == 0) {			/* On the sector boundary? */
 3733  				csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
MacExp: 			csect = (UINT)(fp->fptr / ((UINT)512) & (fs->csize - 1));	/* Sector offset in the cluster */
 3734  				if (csect == 0) {					/* On the cluster boundary? */
 3735  					if (fp->fptr == 0) {			/* On the top of the file? */
 3736  						clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 3737  					} else {						/* Middle or end of the file */
 3738  	#if FF_USE_FASTSEEK
MacExp: #if 0
 3739 X						if (fp->cltbl) {
 3740 X							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3741 X						} else
 3742  	#endif
 3743  						{
 3744  							clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 3745  						}
 3746  					}
 3747  					if (clst < 2) ABORT(fs, FR_INT_ERR);
MacExp: 				if (clst < 2) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 3748  					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
MacExp: 				if (clst == 0xFFFFFFFF) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 3749  					fp->clust = clst;				/* Update current cluster */
 3750  				}
 3751  				sect = clst2sect(fs, fp->clust);	/* Get current sector */
 3752  				if (sect == 0) ABORT(fs, FR_INT_ERR);
MacExp: 			if (sect == 0) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 3753  				sect += csect;
 3754  				cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
MacExp: 			cc = btr / ((UINT)512);					/* When remaining bytes >= sector size, */
 3755  				if (cc > 0) {						/* Read maximum contiguous sectors directly */
 3756  					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 3757  						cc = fs->csize - csect;
 3758  					}
 3759  					if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
MacExp: 				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 3760  	#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
MacExp: #if !0 && 0 <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
 3761  	#if FF_FS_TINY
MacExp: #if 1
 3762  					if (fs->wflag && fs->winsect - sect < cc) {
 3763  						mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
MacExp: 					mem_cpy(rbuff + ((fs->winsect - sect) * ((UINT)512)), fs->win, ((UINT)512));
 3764  					}
 3765  	#else
 3766 X					if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 3767 X						mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 3768 X					}
 3769  	#endif
 3770  	#endif
 3771  					rcnt = SS(fs) * cc;				/* Number of bytes transferred */
MacExp: 				rcnt = ((UINT)512) * cc;				/* Number of bytes transferred */
 3772  					continue;
 3773  				}
 3774  	#if !FF_FS_TINY
MacExp: #if !1
 3775 X				if (fp->sect != sect) {			/* Load data sector if not in cache */
 3776 X	#if !FF_FS_READONLY
MacExp: #if !0
 3777 X					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 3778 X						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 3779 X						fp->flag &= (BYTE)~FA_DIRTY;
 3780 X					}
 3781 X	#endif
 3782 X					if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 3783 X				}
 3784  	#endif
 3785  				fp->sect = sect;
 3786  			}
 3787  			rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
MacExp: 		rcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);	/* Number of bytes left in the sector */
 3788  			if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 3789  	#if FF_FS_TINY
MacExp: #if 1
 3790  			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
MacExp: 		if (move_window(fs, fp->sect) != FR_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };	/* Move sector window */
 3791  			mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
MacExp: 		mem_cpy(rbuff, fs->win + fp->fptr % ((UINT)512), rcnt);	/* Extract partial sector */
 3792  	#else
 3793 X			mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 3794  	#endif
 3795  		}
 3796  	
 3797  		LEAVE_FF(fs, FR_OK);
MacExp: 	return  FR_OK;
 3798  	}
 3799  	
 3800  	
 3801  	
 3802  	
 3803  	#if !FF_FS_READONLY
MacExp: #if !0
 3804 C	/*-----------------------------------------------------------------------*/
 3805 C	/* Write File                                                            */
 3806 C	/*-----------------------------------------------------------------------*/
 3807 C	
 3808  	FRESULT f_write (
 3809  		FIL* fp,			/* Pointer to the file object */
 3810  		const void* buff,	/* Pointer to the data to be written */
 3811  		UINT btw,			/* Number of bytes to write */
 3812  		UINT* bw			/* Pointer to number of bytes written */
 3813  	)
 3814  	{
 3815  		FRESULT res;
 3816  		FATFS *fs;
 3817  		DWORD clst, sect;
 3818  		UINT wcnt, cc, csect;
 3819  		const BYTE *wbuff = (const BYTE*)buff;
 3820  	
 3821  	
 3822  		*bw = 0;	/* Clear write byte counter */
 3823  		res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 3824  		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
MacExp: 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return  res;	/* Check validity */
 3825  		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
MacExp: 	if (!(fp->flag & 0x02)) return  FR_DENIED;	/* Check access mode */
 3826  	
 3827 C		/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
 3828  		if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
MacExp: 	if ((!0 || fs->fs_type != 4) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 3829  			btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 3830  		}
 3831  	
 3832  		for ( ;  btw;							/* Repeat until all data written */
 3833  			btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 3834  			if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
MacExp: 		if (fp->fptr % ((UINT)512) == 0) {		/* On the sector boundary? */
 3835  				csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
MacExp: 			csect = (UINT)(fp->fptr / ((UINT)512)) & (fs->csize - 1);	/* Sector offset in the cluster */
 3836  				if (csect == 0) {				/* On the cluster boundary? */
 3837  					if (fp->fptr == 0) {		/* On the top of the file? */
 3838  						clst = fp->obj.sclust;	/* Follow from the origin */
 3839  						if (clst == 0) {		/* If no cluster is allocated, */
 3840  							clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 3841  						}
 3842  					} else {					/* On the middle or end of the file */
 3843  	#if FF_USE_FASTSEEK
MacExp: #if 0
 3844 X						if (fp->cltbl) {
 3845 X							clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 3846 X						} else
 3847  	#endif
 3848  						{
 3849  							clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 3850  						}
 3851  					}
 3852  					if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 3853  					if (clst == 1) ABORT(fs, FR_INT_ERR);
MacExp: 				if (clst == 1) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 3854  					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
MacExp: 				if (clst == 0xFFFFFFFF) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 3855  					fp->clust = clst;			/* Update current cluster */
 3856  					if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 3857  				}
 3858  	#if FF_FS_TINY
MacExp: #if 1
 3859  				if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
MacExp: 			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };	/* Write-back sector cache */
 3860  	#else
 3861 X				if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 3862 X					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 3863 X					fp->flag &= (BYTE)~FA_DIRTY;
 3864 X				}
 3865  	#endif
 3866  				sect = clst2sect(fs, fp->clust);	/* Get current sector */
 3867  				if (sect == 0) ABORT(fs, FR_INT_ERR);
MacExp: 			if (sect == 0) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 3868  				sect += csect;
 3869  				cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
MacExp: 			cc = btw / ((UINT)512);				/* When remaining bytes >= sector size, */
 3870  				if (cc > 0) {					/* Write maximum contiguous sectors directly */
 3871  					if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 3872  						cc = fs->csize - csect;
 3873  					}
 3874  					if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
MacExp: 				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 3875  	#if FF_FS_MINIMIZE <= 2
MacExp: #if 0 <= 2
 3876  	#if FF_FS_TINY
MacExp: #if 1
 3877  					if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
 3878  						mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
MacExp: 					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * ((UINT)512)), ((UINT)512));
 3879  						fs->wflag = 0;
 3880  					}
 3881  	#else
 3882 X					if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 3883 X						mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 3884 X						fp->flag &= (BYTE)~FA_DIRTY;
 3885 X					}
 3886  	#endif
 3887  	#endif
 3888  					wcnt = SS(fs) * cc;		/* Number of bytes transferred */
MacExp: 				wcnt = ((UINT)512) * cc;		/* Number of bytes transferred */
 3889  					continue;
 3890  				}
 3891  	#if FF_FS_TINY
MacExp: #if 1
 3892  				if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
 3893  					if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
MacExp: 				if (sync_window(fs) != FR_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 3894  					fs->winsect = sect;
 3895  				}
 3896  	#else
 3897 X				if (fp->sect != sect && 		/* Fill sector cache with file data */
 3898 X					fp->fptr < fp->obj.objsize &&
 3899 X					disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 3900 X						ABORT(fs, FR_DISK_ERR);
 3901 X				}
 3902  	#endif
 3903  				fp->sect = sect;
 3904  			}
 3905  			wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
MacExp: 		wcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);	/* Number of bytes left in the sector */
 3906  			if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 3907  	#if FF_FS_TINY
MacExp: #if 1
 3908  			if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
MacExp: 		if (move_window(fs, fp->sect) != FR_OK) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };	/* Move sector window */
 3909  			mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
MacExp: 		mem_cpy(fs->win + fp->fptr % ((UINT)512), wbuff, wcnt);	/* Fit data to the sector */
 3910  			fs->wflag = 1;
 3911  	#else
 3912 X			mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 3913 X			fp->flag |= FA_DIRTY;
 3914  	#endif
 3915  		}
 3916  	
 3917  		fp->flag |= FA_MODIFIED;				/* Set file change flag */
MacExp: 	fp->flag |= 0x40;				/* Set file change flag */
 3918  	
 3919  		LEAVE_FF(fs, FR_OK);
MacExp: 	return  FR_OK;
 3920  	}
 3921  	
 3922  	
 3923  	
 3924  	
 3925 C	/*-----------------------------------------------------------------------*/
 3926 C	/* Synchronize the File                                                  */
 3927 C	/*-----------------------------------------------------------------------*/
 3928 C	
 3929  	FRESULT f_sync (
 3930  		FIL* fp		/* Pointer to the file object */
 3931  	)
 3932  	{
 3933  		FRESULT res;
 3934  		FATFS *fs;
 3935  		DWORD tm;
 3936  		BYTE *dir;
 3937  	
 3938  	
 3939  		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 3940  		if (res == FR_OK) {
 3941  			if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
MacExp: 		if (fp->flag & 0x40) {	/* Is there any change to the file? */
 3942  	#if !FF_FS_TINY
MacExp: #if !1
 3943 X				if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 3944 X					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 3945 X					fp->flag &= (BYTE)~FA_DIRTY;
 3946 X				}
 3947  	#endif
 3948 C				/* Update the directory entry */
 3949  				tm = GET_FATTIME();				/* Modified time */
MacExp: 			tm = get_fattime();				/* Modified time */
 3950  	#if FF_FS_EXFAT
MacExp: #if 0
 3951 X				if (fs->fs_type == FS_EXFAT) {
 3952 X					res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
 3953 X					if (res == FR_OK) {
 3954 X						res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 3955 X					}
 3956 X					if (res == FR_OK) {
 3957 X						DIR dj;
 3958 X						DEF_NAMBUF
 3959 X	
 3960 X						INIT_NAMBUF(fs);
 3961 X						res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
 3962 X						if (res == FR_OK) {
 3963 X							fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
 3964 X							fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
 3965 X							st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
 3966 X							st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
 3967 X							st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
 3968 X							st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
 3969 X							fs->dirbuf[XDIR_ModTime10] = 0;
 3970 X							st_dword(fs->dirbuf + XDIR_AccTime, 0);
 3971 X							res = store_xdir(&dj);	/* Restore it to the directory */
 3972 X							if (res == FR_OK) {
 3973 X								res = sync_fs(fs);
 3974 X								fp->flag &= (BYTE)~FA_MODIFIED;
 3975 X							}
 3976 X						}
 3977 X						FREE_NAMBUF();
 3978 X					}
 3979 X				} else
 3980  	#endif
 3981  				{
 3982  					res = move_window(fs, fp->dir_sect);
 3983  					if (res == FR_OK) {
 3984  						dir = fp->dir_ptr;
 3985  						dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
MacExp: 					dir[11] |= 0x20;						/* Set archive attribute to indicate that the file has been changed */
 3986  						st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 3987  						st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
MacExp: 					st_dword(dir + 28, (DWORD)fp->obj.objsize);	/* Update file size */
 3988  						st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
MacExp: 					st_dword(dir + 22, tm);				/* Update modified time */
 3989  						st_word(dir + DIR_LstAccDate, 0);
MacExp: 					st_word(dir + 18, 0);
 3990  						fs->wflag = 1;
 3991  						res = sync_fs(fs);					/* Restore it to the directory */
 3992  						fp->flag &= (BYTE)~FA_MODIFIED;
MacExp: 					fp->flag &= (BYTE)~0x40;
 3993  					}
 3994  				}
 3995  			}
 3996  		}
 3997  	
 3998  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 3999  	}
 4000  	
 4001  	#endif /* !FF_FS_READONLY */
 4002  	
 4003  	
 4004  	
 4005  	
 4006 C	/*-----------------------------------------------------------------------*/
 4007 C	/* Close File                                                            */
 4008 C	/*-----------------------------------------------------------------------*/
 4009 C	
 4010  	FRESULT f_close (
 4011  		FIL* fp		/* Pointer to the file object to be closed */
 4012  	)
 4013  	{
 4014  		FRESULT res;
 4015  		FATFS *fs;
 4016  	
 4017  	#if !FF_FS_READONLY
MacExp: #if !0
 4018  		res = f_sync(fp);					/* Flush cached data */
 4019  		if (res == FR_OK)
 4020  	#endif
 4021  		{
 4022  			res = validate(&fp->obj, &fs);	/* Lock volume */
 4023  			if (res == FR_OK) {
 4024  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 4025 X				res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
 4026 X				if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
 4027  	#else
 4028  				fp->obj.fs = 0;	/* Invalidate file object */
 4029  	#endif
 4030  	#if FF_FS_REENTRANT
MacExp: #if 0
 4031 X				unlock_fs(fs, FR_OK);		/* Unlock volume */
 4032  	#endif
 4033  			}
 4034  		}
 4035  		return res;
 4036  	}
 4037  	
 4038  	
 4039  	
 4040  	
 4041  	#if FF_FS_RPATH >= 1
MacExp: #if 1 >= 1
 4042 C	/*-----------------------------------------------------------------------*/
 4043 C	/* Change Current Directory or Current Drive, Get Current Directory      */
 4044 C	/*-----------------------------------------------------------------------*/
 4045 C	
 4046  	FRESULT f_chdrive (
 4047  		const TCHAR* path		/* Drive number to set */
 4048  	)
 4049  	{
 4050  		int vol;
 4051  	
 4052  	
 4053 C		/* Get logical drive number */
 4054  		vol = get_ldnumber(&path);
 4055  		if (vol < 0) return FR_INVALID_DRIVE;
 4056  		CurrVol = (BYTE)vol;	/* Set it as current volume */
 4057  	
 4058  		return FR_OK;
 4059  	}
 4060  	
 4061  	
 4062  	
 4063  	FRESULT f_chdir (
 4064  		const TCHAR* path	/* Pointer to the directory path */
 4065  	)
 4066  	{
 4067  	#if FF_STR_VOLUME_ID == 2
MacExp: #if 0 == 2
 4068 X		UINT i;
 4069  	#endif
 4070  		FRESULT res;
 4071  		DIR dj;
 4072  		FATFS *fs;
 4073  		DEF_NAMBUF
MacExp: 	
 4074  	
 4075  	
 4076 C		/* Get logical drive */
 4077  		res = find_volume(&path, &fs, 0);
 4078  		if (res == FR_OK) {
 4079  			dj.obj.fs = fs;
 4080  			INIT_NAMBUF(fs);
MacExp: 		;
 4081  			res = follow_path(&dj, path);		/* Follow the path */
 4082  			if (res == FR_OK) {					/* Follow completed */
 4083  				if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
MacExp: 			if (dj.fn[11] & 0x80) {	/* Is it the start directory itself? */
 4084  					fs->cdir = dj.obj.sclust;
 4085  	#if FF_FS_EXFAT
MacExp: #if 0
 4086 X					if (fs->fs_type == FS_EXFAT) {
 4087 X						fs->cdc_scl = dj.obj.c_scl;
 4088 X						fs->cdc_size = dj.obj.c_size;
 4089 X						fs->cdc_ofs = dj.obj.c_ofs;
 4090 X					}
 4091  	#endif
 4092  				} else {
 4093  					if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
MacExp: 				if (dj.obj.attr & 0x10) {	/* It is a sub-directory */
 4094  	#if FF_FS_EXFAT
MacExp: #if 0
 4095 X						if (fs->fs_type == FS_EXFAT) {
 4096 X							fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
 4097 X							fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
 4098 X							fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 4099 X							fs->cdc_ofs = dj.blk_ofs;
 4100 X						} else
 4101  	#endif
 4102  						{
 4103  							fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
 4104  						}
 4105  					} else {
 4106  						res = FR_NO_PATH;		/* Reached but a file */
 4107  					}
 4108  				}
 4109  			}
 4110  			FREE_NAMBUF();
MacExp: 		;
 4111  			if (res == FR_NO_FILE) res = FR_NO_PATH;
 4112  	#if FF_STR_VOLUME_ID == 2	/* Also current drive is changed at Unix style volume ID */
MacExp: #if 0 == 2	/* Also current drive is changed at Unix style volume ID */
 4113 X			if (res == FR_OK) {
 4114 X				for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;	/* Set current drive */
 4115 X				CurrVol = (BYTE)i;
 4116 X			}
 4117  	#endif
 4118  		}
 4119  	
 4120  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4121  	}
 4122  	
 4123  	
 4124  	#if FF_FS_RPATH >= 2
MacExp: #if 1 >= 2
 4125 X	FRESULT f_getcwd (
 4126 X		TCHAR* buff,	/* Pointer to the directory path */
 4127 X		UINT len		/* Size of buff in unit of TCHAR */
 4128 X	)
 4129 X	{
 4130 X		FRESULT res;
 4131 X		DIR dj;
 4132 X		FATFS *fs;
 4133 X		UINT i, n;
 4134 X		DWORD ccl;
 4135 X		TCHAR *tp = buff;
 4136 X	#if FF_VOLUMES >= 2
MacExp: #if 1 >= 2
 4137 X		UINT vl;
 4138 X	#endif
 4139 X	#if FF_STR_VOLUME_ID
MacExp: #if 0
 4140 X		const char *vp;
 4141 X	#endif
 4142 X		FILINFO fno;
 4143 X		DEF_NAMBUF
 4144 X	
 4145 X	
 4146 X		/* Get logical drive */
 4147 X		res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
 4148 X		if (res == FR_OK) {
 4149 X			dj.obj.fs = fs;
 4150 X			INIT_NAMBUF(fs);
 4151 X	
 4152 X			/* Follow parent directories and create the path */
 4153 X			i = len;			/* Bottom of buffer (directory stack base) */
 4154 X			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
 4155 X				dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
 4156 X				while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
 4157 X					res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
 4158 X					if (res != FR_OK) break;
 4159 X					res = move_window(fs, dj.sect);
 4160 X					if (res != FR_OK) break;
 4161 X					dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
 4162 X					res = dir_sdi(&dj, 0);
 4163 X					if (res != FR_OK) break;
 4164 X					do {							/* Find the entry links to the child directory */
 4165 X						res = dir_read_file(&dj);
 4166 X						if (res != FR_OK) break;
 4167 X						if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
 4168 X						res = dir_next(&dj, 0);
 4169 X					} while (res == FR_OK);
 4170 X					if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
 4171 X					if (res != FR_OK) break;
 4172 X					get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
 4173 X					for (n = 0; fno.fname[n]; n++) ;	/* Name length */
 4174 X					if (i < n + 1) {	/* Insufficient space to store the path name? */
 4175 X						res = FR_NOT_ENOUGH_CORE; break;
 4176 X					}
 4177 X					while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
 4178 X					buff[--i] = '/';
 4179 X				}
 4180 X			}
 4181 X			if (res == FR_OK) {
 4182 X				if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
 4183 X	#if FF_VOLUMES >= 2			/* Put drive prefix */
MacExp: #if 1 >= 2			/* Put drive prefix */
 4184 X				vl = 0;
 4185 X	#if FF_STR_VOLUME_ID >= 1	/* String volume ID */
MacExp: #if 0 >= 1	/* String volume ID */
 4186 X				for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;
 4187 X				if (i >= n + 2) {
 4188 X					if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';
 4189 X					for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;
 4190 X					if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';
 4191 X					vl++;
 4192 X				}
 4193 X	#else						/* Numeric volume ID */
 4194 X				if (i >= 3) {
 4195 X					*tp++ = (TCHAR)'0' + CurrVol;
 4196 X					*tp++ = (TCHAR)':';
 4197 X					vl = 2;
 4198 X				}
 4199 X	#endif
 4200 X				if (vl == 0) res = FR_NOT_ENOUGH_CORE;
 4201 X	#endif
 4202 X				/* Add current directory path */
 4203 X				if (res == FR_OK) {
 4204 X					do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
 4205 X				}
 4206 X			}
 4207 X			FREE_NAMBUF();
 4208 X		}
 4209 X	
 4210 X		*tp = 0;
 4211 X		LEAVE_FF(fs, res);
 4212 X	}
 4213 X	
 4214  	#endif /* FF_FS_RPATH >= 2 */
 4215  	#endif /* FF_FS_RPATH >= 1 */
 4216  	
 4217  	
 4218  	
 4219  	#if FF_FS_MINIMIZE <= 2
MacExp: #if 0 <= 2
 4220 C	/*-----------------------------------------------------------------------*/
 4221 C	/* Seek File Read/Write Pointer                                          */
 4222 C	/*-----------------------------------------------------------------------*/
 4223 C	
 4224  	FRESULT f_lseek (
 4225  		FIL* fp,		/* Pointer to the file object */
 4226  		FSIZE_t ofs		/* File pointer from top of file */
 4227  	)
 4228  	{
 4229  		FRESULT res;
 4230  		FATFS *fs;
 4231  		DWORD clst, bcs, nsect;
 4232  		FSIZE_t ifptr;
 4233  	#if FF_USE_FASTSEEK
MacExp: #if 0
 4234 X		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
 4235  	#endif
 4236  	
 4237  		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 4238  		if (res == FR_OK) res = (FRESULT)fp->err;
 4239  	#if FF_FS_EXFAT && !FF_FS_READONLY
MacExp: #if 0 && !0
 4240 X		if (res == FR_OK && fs->fs_type == FS_EXFAT) {
 4241 X			res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 4242 X		}
 4243  	#endif
 4244  		if (res != FR_OK) LEAVE_FF(fs, res);
MacExp: 	if (res != FR_OK) return  res;
 4245  	
 4246  	#if FF_USE_FASTSEEK
MacExp: #if 0
 4247 X		if (fp->cltbl) {	/* Fast seek */
 4248 X			if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 4249 X				tbl = fp->cltbl;
 4250 X				tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 4251 X				cl = fp->obj.sclust;		/* Origin of the chain */
 4252 X				if (cl != 0) {
 4253 X					do {
 4254 X						/* Get a fragment */
 4255 X						tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 4256 X						do {
 4257 X							pcl = cl; ncl++;
 4258 X							cl = get_fat(&fp->obj, cl);
 4259 X							if (cl <= 1) ABORT(fs, FR_INT_ERR);
 4260 X							if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 4261 X						} while (cl == pcl + 1);
 4262 X						if (ulen <= tlen) {		/* Store the length and top of the fragment */
 4263 X							*tbl++ = ncl; *tbl++ = tcl;
 4264 X						}
 4265 X					} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 4266 X				}
 4267 X				*fp->cltbl = ulen;	/* Number of items used */
 4268 X				if (ulen <= tlen) {
 4269 X					*tbl = 0;		/* Terminate table */
 4270 X				} else {
 4271 X					res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 4272 X				}
 4273 X			} else {						/* Fast seek */
 4274 X				if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 4275 X				fp->fptr = ofs;				/* Set file pointer */
 4276 X				if (ofs > 0) {
 4277 X					fp->clust = clmt_clust(fp, ofs - 1);
 4278 X					dsc = clst2sect(fs, fp->clust);
 4279 X					if (dsc == 0) ABORT(fs, FR_INT_ERR);
 4280 X					dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 4281 X					if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 4282 X	#if !FF_FS_TINY
MacExp: #if !1
 4283 X	#if !FF_FS_READONLY
MacExp: #if !0
 4284 X						if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 4285 X							if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 4286 X							fp->flag &= (BYTE)~FA_DIRTY;
 4287 X						}
 4288 X	#endif
 4289 X						if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 4290 X	#endif
 4291 X						fp->sect = dsc;
 4292 X					}
 4293 X				}
 4294 X			}
 4295 X		} else
 4296  	#endif
 4297  	
 4298 C		/* Normal Seek */
 4299  		{
 4300  	#if FF_FS_EXFAT
MacExp: #if 0
 4301 X			if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at FATxx */
 4302  	#endif
 4303  			if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
MacExp: 		if (ofs > fp->obj.objsize && (0 || !(fp->flag & 0x02))) {	/* In read-only mode, clip offset with the file size */
 4304  				ofs = fp->obj.objsize;
 4305  			}
 4306  			ifptr = fp->fptr;
 4307  			fp->fptr = nsect = 0;
 4308  			if (ofs > 0) {
 4309  				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
MacExp: 			bcs = (DWORD)fs->csize * ((UINT)512);	/* Cluster size (byte) */
 4310  				if (ifptr > 0 &&
 4311  					(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 4312  					fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 4313  					ofs -= fp->fptr;
 4314  					clst = fp->clust;
 4315  				} else {									/* When seek to back cluster, */
 4316  					clst = fp->obj.sclust;					/* start from the first cluster */
 4317  	#if !FF_FS_READONLY
MacExp: #if !0
 4318  					if (clst == 0) {						/* If no cluster chain, create a new chain */
 4319  						clst = create_chain(&fp->obj, 0);
 4320  						if (clst == 1) ABORT(fs, FR_INT_ERR);
MacExp: 					if (clst == 1) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 4321  						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
MacExp: 					if (clst == 0xFFFFFFFF) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 4322  						fp->obj.sclust = clst;
 4323  					}
 4324  	#endif
 4325  					fp->clust = clst;
 4326  				}
 4327  				if (clst != 0) {
 4328  					while (ofs > bcs) {						/* Cluster following loop */
 4329  						ofs -= bcs; fp->fptr += bcs;
 4330  	#if !FF_FS_READONLY
MacExp: #if !0
 4331  						if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
MacExp: 					if (fp->flag & 0x02) {			/* Check if in write mode or not */
 4332  							if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
MacExp: 						if (0 && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
 4333  								fp->obj.objsize = fp->fptr;
 4334  								fp->flag |= FA_MODIFIED;
MacExp: 							fp->flag |= 0x40;
 4335  							}
 4336  							clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 4337  							if (clst == 0) {				/* Clip file size in case of disk full */
 4338  								ofs = 0; break;
 4339  							}
 4340  						} else
 4341  	#endif
 4342  						{
 4343  							clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 4344  						}
 4345  						if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
MacExp: 					if (clst == 0xFFFFFFFF) { fp->err = (BYTE)( FR_DISK_ERR); return  FR_DISK_ERR; };
 4346  						if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
MacExp: 					if (clst <= 1 || clst >= fs->n_fatent) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 4347  						fp->clust = clst;
 4348  					}
 4349  					fp->fptr += ofs;
 4350  					if (ofs % SS(fs)) {
MacExp: 				if (ofs % ((UINT)512)) {
 4351  						nsect = clst2sect(fs, clst);	/* Current sector */
 4352  						if (nsect == 0) ABORT(fs, FR_INT_ERR);
MacExp: 					if (nsect == 0) { fp->err = (BYTE)( FR_INT_ERR); return  FR_INT_ERR; };
 4353  						nsect += (DWORD)(ofs / SS(fs));
MacExp: 					nsect += (DWORD)(ofs / ((UINT)512));
 4354  					}
 4355  				}
 4356  			}
 4357  			if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
MacExp: 		if (!0 && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
 4358  				fp->obj.objsize = fp->fptr;
 4359  				fp->flag |= FA_MODIFIED;
MacExp: 			fp->flag |= 0x40;
 4360  			}
 4361  			if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
MacExp: 		if (fp->fptr % ((UINT)512) && nsect != fp->sect) {	/* Fill sector cache if needed */
 4362  	#if !FF_FS_TINY
MacExp: #if !1
 4363 X	#if !FF_FS_READONLY
MacExp: #if !0
 4364 X				if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 4365 X					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 4366 X					fp->flag &= (BYTE)~FA_DIRTY;
 4367 X				}
 4368 X	#endif
 4369 X				if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 4370  	#endif
 4371  				fp->sect = nsect;
 4372  			}
 4373  		}
 4374  	
 4375  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4376  	}
 4377  	
 4378  	
 4379  	
 4380  	#if FF_FS_MINIMIZE <= 1
MacExp: #if 0 <= 1
 4381 C	/*-----------------------------------------------------------------------*/
 4382 C	/* Create a Directory Object                                             */
 4383 C	/*-----------------------------------------------------------------------*/
 4384 C	
 4385  	FRESULT f_opendir (
 4386  		DIR* dp,			/* Pointer to directory object to create */
 4387  		const TCHAR* path	/* Pointer to the directory path */
 4388  	)
 4389  	{
 4390  		FRESULT res;
 4391  		FATFS *fs;
 4392  		DEF_NAMBUF
MacExp: 	
 4393  	
 4394  	
 4395  		if (!dp) return FR_INVALID_OBJECT;
 4396  	
 4397 C		/* Get logical drive */
 4398  		res = find_volume(&path, &fs, 0);
 4399  		if (res == FR_OK) {
 4400  			dp->obj.fs = fs;
 4401  			INIT_NAMBUF(fs);
MacExp: 		;
 4402  			res = follow_path(dp, path);			/* Follow the path to the directory */
 4403  			if (res == FR_OK) {						/* Follow completed */
 4404  				if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
MacExp: 			if (!(dp->fn[11] & 0x80)) {	/* It is not the origin directory itself */
 4405  					if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
MacExp: 				if (dp->obj.attr & 0x10) {		/* This object is a sub-directory */
 4406  	#if FF_FS_EXFAT
MacExp: #if 0
 4407 X						if (fs->fs_type == FS_EXFAT) {
 4408 X							dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
 4409 X							dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 4410 X							dp->obj.c_ofs = dp->blk_ofs;
 4411 X							init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
 4412 X						} else
 4413  	#endif
 4414  						{
 4415  							dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 4416  						}
 4417  					} else {						/* This object is a file */
 4418  						res = FR_NO_PATH;
 4419  					}
 4420  				}
 4421  				if (res == FR_OK) {
 4422  					dp->obj.id = fs->id;
 4423  					res = dir_sdi(dp, 0);			/* Rewind directory */
 4424  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 4425 X					if (res == FR_OK) {
 4426 X						if (dp->obj.sclust != 0) {
 4427 X							dp->obj.lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 4428 X							if (!dp->obj.lockid) res = FR_TOO_MANY_OPEN_FILES;
 4429 X						} else {
 4430 X							dp->obj.lockid = 0;	/* Root directory need not to be locked */
 4431 X						}
 4432 X					}
 4433  	#endif
 4434  				}
 4435  			}
 4436  			FREE_NAMBUF();
MacExp: 		;
 4437  			if (res == FR_NO_FILE) res = FR_NO_PATH;
 4438  		}
 4439  		if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 4440  	
 4441  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4442  	}
 4443  	
 4444  	
 4445  	
 4446  	
 4447 C	/*-----------------------------------------------------------------------*/
 4448 C	/* Close Directory                                                       */
 4449 C	/*-----------------------------------------------------------------------*/
 4450 C	
 4451  	FRESULT f_closedir (
 4452  		DIR *dp		/* Pointer to the directory object to be closed */
 4453  	)
 4454  	{
 4455  		FRESULT res;
 4456  		FATFS *fs;
 4457  	
 4458  	
 4459  		res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 4460  		if (res == FR_OK) {
 4461  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 4462 X			if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
 4463 X			if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
 4464  	#else
 4465  			dp->obj.fs = 0;	/* Invalidate directory object */
 4466  	#endif
 4467  	#if FF_FS_REENTRANT
MacExp: #if 0
 4468 X			unlock_fs(fs, FR_OK);		/* Unlock volume */
 4469  	#endif
 4470  		}
 4471  		return res;
 4472  	}
 4473  	
 4474  	
 4475  	
 4476  	
 4477 C	/*-----------------------------------------------------------------------*/
 4478 C	/* Read Directory Entries in Sequence                                    */
 4479 C	/*-----------------------------------------------------------------------*/
 4480 C	
 4481  	FRESULT f_readdir (
 4482  		DIR* dp,			/* Pointer to the open directory object */
 4483  		FILINFO* fno		/* Pointer to file information to return */
 4484  	)
 4485  	{
 4486  		FRESULT res;
 4487  		FATFS *fs;
 4488  		DEF_NAMBUF
MacExp: 	
 4489  	
 4490  	
 4491  		res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 4492  		if (res == FR_OK) {
 4493  			if (!fno) {
 4494  				res = dir_sdi(dp, 0);			/* Rewind the directory object */
 4495  			} else {
 4496  				INIT_NAMBUF(fs);
MacExp: 			;
 4497  				res = dir_read_file(dp);		/* Read an item */
MacExp: 			res = dir_read(dp, 0);		/* Read an item */
 4498  				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 4499  				if (res == FR_OK) {				/* A valid entry is found */
 4500  					get_fileinfo(dp, fno);		/* Get the object information */
 4501  					res = dir_next(dp, 0);		/* Increment index for next */
 4502  					if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 4503  				}
 4504  				FREE_NAMBUF();
MacExp: 			;
 4505  			}
 4506  		}
 4507  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4508  	}
 4509  	
 4510  	
 4511  	
 4512  	#if FF_USE_FIND
MacExp: #if 0
 4513 X	/*-----------------------------------------------------------------------*/
 4514 X	/* Find Next File                                                        */
 4515 X	/*-----------------------------------------------------------------------*/
 4516 X	
 4517 X	FRESULT f_findnext (
 4518 X		DIR* dp,		/* Pointer to the open directory object */
 4519 X		FILINFO* fno	/* Pointer to the file information structure */
 4520 X	)
 4521 X	{
 4522 X		FRESULT res;
 4523 X	
 4524 X	
 4525 X		while (1) {
 4526 X			res = f_readdir(dp, fno);		/* Get a directory item */
 4527 X			if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 4528 X			if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 4529 X	#if FF_USE_LFN && FF_USE_FIND == 2
MacExp: #if 1 && 0 == 2
 4530 X			if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
 4531 X	#endif
 4532 X		}
 4533 X		return res;
 4534 X	}
 4535 X	
 4536 X	
 4537 X	
 4538 X	/*-----------------------------------------------------------------------*/
 4539 X	/* Find First File                                                       */
 4540 X	/*-----------------------------------------------------------------------*/
 4541 X	
 4542 X	FRESULT f_findfirst (
 4543 X		DIR* dp,				/* Pointer to the blank directory object */
 4544 X		FILINFO* fno,			/* Pointer to the file information structure */
 4545 X		const TCHAR* path,		/* Pointer to the directory to open */
 4546 X		const TCHAR* pattern	/* Pointer to the matching pattern */
 4547 X	)
 4548 X	{
 4549 X		FRESULT res;
 4550 X	
 4551 X	
 4552 X		dp->pat = pattern;		/* Save pointer to pattern string */
 4553 X		res = f_opendir(dp, path);		/* Open the target directory */
 4554 X		if (res == FR_OK) {
 4555 X			res = f_findnext(dp, fno);	/* Find the first item */
 4556 X		}
 4557 X		return res;
 4558 X	}
 4559 X	
 4560  	#endif	/* FF_USE_FIND */
 4561  	
 4562  	
 4563  	
 4564  	#if FF_FS_MINIMIZE == 0
MacExp: #if 0 == 0
 4565 C	/*-----------------------------------------------------------------------*/
 4566 C	/* Get File Status                                                       */
 4567 C	/*-----------------------------------------------------------------------*/
 4568 C	
 4569  	FRESULT f_stat (
 4570  		const TCHAR* path,	/* Pointer to the file path */
 4571  		FILINFO* fno		/* Pointer to file information to return */
 4572  	)
 4573  	{
 4574  		FRESULT res;
 4575  		DIR dj;
 4576  		DEF_NAMBUF
MacExp: 	
 4577  	
 4578  	
 4579 C		/* Get logical drive */
 4580  		res = find_volume(&path, &dj.obj.fs, 0);
 4581  		if (res == FR_OK) {
 4582  			INIT_NAMBUF(dj.obj.fs);
MacExp: 		;
 4583  			res = follow_path(&dj, path);	/* Follow the file path */
 4584  			if (res == FR_OK) {				/* Follow completed */
 4585  				if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
MacExp: 			if (dj.fn[11] & 0x80) {	/* It is origin directory */
 4586  					res = FR_INVALID_NAME;
 4587  				} else {							/* Found an object */
 4588  					if (fno) get_fileinfo(&dj, fno);
 4589  				}
 4590  			}
 4591  			FREE_NAMBUF();
MacExp: 		;
 4592  		}
 4593  	
 4594  		LEAVE_FF(dj.obj.fs, res);
MacExp: 	return  res;
 4595  	}
 4596  	
 4597  	
 4598  	
 4599  	#if !FF_FS_READONLY
MacExp: #if !0
 4600 C	/*-----------------------------------------------------------------------*/
 4601 C	/* Get Number of Free Clusters                                           */
 4602 C	/*-----------------------------------------------------------------------*/
 4603 C	
 4604  	FRESULT f_getfree (
 4605  		const TCHAR* path,	/* Logical drive number */
 4606  		DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
 4607  		FATFS** fatfs		/* Pointer to return pointer to corresponding filesystem object */
 4608  	)
 4609  	{
 4610  		FRESULT res;
 4611  		FATFS *fs;
 4612  		DWORD nfree, clst, sect, stat;
 4613  		UINT i;
 4614  		FFOBJID obj;
 4615  	
 4616  	
 4617 C		/* Get logical drive */
 4618  		res = find_volume(&path, &fs, 0);
 4619  		if (res == FR_OK) {
 4620  			*fatfs = fs;				/* Return ptr to the fs object */
 4621 C			/* If free_clst is valid, return it without full FAT scan */
 4622  			if (fs->free_clst <= fs->n_fatent - 2) {
 4623  				*nclst = fs->free_clst;
 4624  			} else {
 4625 C				/* Scan FAT to obtain number of free clusters */
 4626  				nfree = 0;
 4627  				if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
MacExp: 			if (fs->fs_type == 1) {	/* FAT12: Scan bit field FAT entries */
 4628  					clst = 2; obj.fs = fs;
 4629  					do {
 4630  						stat = get_fat(&obj, clst);
 4631  						if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 4632  						if (stat == 1) { res = FR_INT_ERR; break; }
 4633  						if (stat == 0) nfree++;
 4634  					} while (++clst < fs->n_fatent);
 4635  				} else {
 4636  	#if FF_FS_EXFAT
MacExp: #if 0
 4637 X					if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan allocation bitmap */
 4638 X						BYTE bm;
 4639 X						UINT b;
 4640 X	
 4641 X						clst = fs->n_fatent - 2;	/* Number of clusters */
 4642 X						sect = fs->database;		/* Assuming bitmap starts at cluster 2 */
 4643 X						i = 0;						/* Offset in the sector */
 4644 X						do {	/* Counts numbuer of bits with zero in the bitmap */
 4645 X							if (i == 0) {
 4646 X								res = move_window(fs, sect++);
 4647 X								if (res != FR_OK) break;
 4648 X							}
 4649 X							for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
 4650 X								if (!(bm & 1)) nfree++;
 4651 X								bm >>= 1;
 4652 X							}
 4653 X							i = (i + 1) % SS(fs);
 4654 X						} while (clst);
 4655 X					} else
 4656  	#endif
 4657  					{	/* FAT16/32: Scan WORD/DWORD FAT entries */
 4658  						clst = fs->n_fatent;	/* Number of entries */
 4659  						sect = fs->fatbase;		/* Top of the FAT */
 4660  						i = 0;					/* Offset in the sector */
 4661  						do {	/* Counts numbuer of entries with zero in the FAT */
 4662  							if (i == 0) {
 4663  								res = move_window(fs, sect++);
 4664  								if (res != FR_OK) break;
 4665  							}
 4666  							if (fs->fs_type == FS_FAT16) {
MacExp: 						if (fs->fs_type == 2) {
 4667  								if (ld_word(fs->win + i) == 0) nfree++;
 4668  								i += 2;
 4669  							} else {
 4670  								if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
 4671  								i += 4;
 4672  							}
 4673  							i %= SS(fs);
MacExp: 						i %= ((UINT)512);
 4674  						} while (--clst);
 4675  					}
 4676  				}
 4677  				*nclst = nfree;			/* Return the free clusters */
 4678  				fs->free_clst = nfree;	/* Now free_clst is valid */
 4679  				fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
 4680  			}
 4681  		}
 4682  	
 4683  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4684  	}
 4685  	
 4686  	
 4687  	
 4688  	
 4689 C	/*-----------------------------------------------------------------------*/
 4690 C	/* Truncate File                                                         */
 4691 C	/*-----------------------------------------------------------------------*/
 4692 C	
 4693  	FRESULT f_truncate (
 4694  		FIL* fp		/* Pointer to the file object */
 4695  	)
 4696  	{
 4697  		FRESULT res;
 4698  		FATFS *fs;
 4699  		DWORD ncl;
 4700  	
 4701  	
 4702  		res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 4703  		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
MacExp: 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return  res;
 4704  		if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
MacExp: 	if (!(fp->flag & 0x02)) return  FR_DENIED;	/* Check access mode */
 4705  	
 4706  		if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
 4707  			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 4708  				res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 4709  				fp->obj.sclust = 0;
 4710  			} else {				/* When truncate a part of the file, remove remaining clusters */
 4711  				ncl = get_fat(&fp->obj, fp->clust);
 4712  				res = FR_OK;
 4713  				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 4714  				if (ncl == 1) res = FR_INT_ERR;
 4715  				if (res == FR_OK && ncl < fs->n_fatent) {
 4716  					res = remove_chain(&fp->obj, ncl, fp->clust);
 4717  				}
 4718  			}
 4719  			fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
 4720  			fp->flag |= FA_MODIFIED;
MacExp: 		fp->flag |= 0x40;
 4721  	#if !FF_FS_TINY
MacExp: #if !1
 4722 X			if (res == FR_OK && (fp->flag & FA_DIRTY)) {
 4723 X				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
 4724 X					res = FR_DISK_ERR;
 4725 X				} else {
 4726 X					fp->flag &= (BYTE)~FA_DIRTY;
 4727 X				}
 4728 X			}
 4729  	#endif
 4730  			if (res != FR_OK) ABORT(fs, res);
MacExp: 		if (res != FR_OK) { fp->err = (BYTE)( res); return  res; };
 4731  		}
 4732  	
 4733  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4734  	}
 4735  	
 4736  	
 4737  	
 4738  	
 4739 C	/*-----------------------------------------------------------------------*/
 4740 C	/* Delete a File/Directory                                               */
 4741 C	/*-----------------------------------------------------------------------*/
 4742 C	
 4743  	FRESULT f_unlink (
 4744  		const TCHAR* path		/* Pointer to the file or directory path */
 4745  	)
 4746  	{
 4747  		FRESULT res;
 4748  		DIR dj, sdj;
 4749  		DWORD dclst = 0;
 4750  		FATFS *fs;
 4751  	#if FF_FS_EXFAT
MacExp: #if 0
 4752 X		FFOBJID obj;
 4753  	#endif
 4754  		DEF_NAMBUF
MacExp: 	
 4755  	
 4756  	
 4757 C		/* Get logical drive */
 4758  		res = find_volume(&path, &fs, FA_WRITE);
MacExp: 	res = find_volume(&path, &fs, 0x02);
 4759  		if (res == FR_OK) {
 4760  			dj.obj.fs = fs;
 4761  			INIT_NAMBUF(fs);
MacExp: 		;
 4762  			res = follow_path(&dj, path);		/* Follow the file path */
 4763  			if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
MacExp: 		if (1 && res == FR_OK && (dj.fn[11] & 0x20)) {
 4764  				res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 4765  			}
 4766  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 4767 X			if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 4768  	#endif
 4769  			if (res == FR_OK) {					/* The object is accessible */
 4770  				if (dj.fn[NSFLAG] & NS_NONAME) {
MacExp: 			if (dj.fn[11] & 0x80) {
 4771  					res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 4772  				} else {
 4773  					if (dj.obj.attr & AM_RDO) {
MacExp: 				if (dj.obj.attr & 0x01) {
 4774  						res = FR_DENIED;		/* Cannot remove R/O object */
 4775  					}
 4776  				}
 4777  				if (res == FR_OK) {
 4778  	#if FF_FS_EXFAT
MacExp: #if 0
 4779 X					obj.fs = fs;
 4780 X					if (fs->fs_type == FS_EXFAT) {
 4781 X						init_alloc_info(fs, &obj);
 4782 X						dclst = obj.sclust;
 4783 X					} else
 4784  	#endif
 4785  					{
 4786  						dclst = ld_clust(fs, dj.dir);
 4787  					}
 4788  					if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
MacExp: 				if (dj.obj.attr & 0x10) {			/* Is it a sub-directory? */
 4789  	#if FF_FS_RPATH != 0
MacExp: #if 1 != 0
 4790  						if (dclst == fs->cdir) {		 	/* Is it the current directory? */
 4791  							res = FR_DENIED;
 4792  						} else
 4793  	#endif
 4794  						{
 4795  							sdj.obj.fs = fs;				/* Open the sub-directory */
 4796  							sdj.obj.sclust = dclst;
 4797  	#if FF_FS_EXFAT
MacExp: #if 0
 4798 X							if (fs->fs_type == FS_EXFAT) {
 4799 X								sdj.obj.objsize = obj.objsize;
 4800 X								sdj.obj.stat = obj.stat;
 4801 X							}
 4802  	#endif
 4803  							res = dir_sdi(&sdj, 0);
 4804  							if (res == FR_OK) {
 4805  								res = dir_read_file(&sdj);			/* Test if the directory is empty */
MacExp: 							res = dir_read(&sdj, 0);			/* Test if the directory is empty */
 4806  								if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 4807  								if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 4808  							}
 4809  						}
 4810  					}
 4811  				}
 4812  				if (res == FR_OK) {
 4813  					res = dir_remove(&dj);			/* Remove the directory entry */
 4814  					if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 4815  	#if FF_FS_EXFAT
MacExp: #if 0
 4816 X						res = remove_chain(&obj, dclst, 0);
 4817  	#else
 4818  						res = remove_chain(&dj.obj, dclst, 0);
 4819  	#endif
 4820  					}
 4821  					if (res == FR_OK) res = sync_fs(fs);
 4822  				}
 4823  			}
 4824  			FREE_NAMBUF();
MacExp: 		;
 4825  		}
 4826  	
 4827  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4828  	}
 4829  	
 4830  	
 4831  	
 4832  	
 4833 C	/*-----------------------------------------------------------------------*/
 4834 C	/* Create a Directory                                                    */
 4835 C	/*-----------------------------------------------------------------------*/
 4836 C	
 4837  	FRESULT f_mkdir (
 4838  		const TCHAR* path		/* Pointer to the directory path */
 4839  	)
 4840  	{
 4841  		FRESULT res;
 4842  		DIR dj;
 4843  		FATFS *fs;
 4844  		BYTE *dir;
 4845  		DWORD dcl, pcl, tm;
 4846  		DEF_NAMBUF
MacExp: 	
 4847  	
 4848  	
 4849 C		/* Get logical drive */
 4850  		res = find_volume(&path, &fs, FA_WRITE);
MacExp: 	res = find_volume(&path, &fs, 0x02);
 4851  		if (res == FR_OK) {
 4852  			dj.obj.fs = fs;
 4853  			INIT_NAMBUF(fs);
MacExp: 		;
 4854  			res = follow_path(&dj, path);			/* Follow the file path */
 4855  			if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 4856  			if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
MacExp: 		if (1 && res == FR_NO_FILE && (dj.fn[11] & 0x20)) {
 4857  				res = FR_INVALID_NAME;
 4858  			}
 4859  			if (res == FR_NO_FILE) {				/* Can create a new directory */
 4860  				dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
 4861  				dj.obj.objsize = (DWORD)fs->csize * SS(fs);
MacExp: 			dj.obj.objsize = (DWORD)fs->csize * ((UINT)512);
 4862  				res = FR_OK;
 4863  				if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 4864  				if (dcl == 1) res = FR_INT_ERR;
 4865  				if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 4866  				if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
 4867  				tm = GET_FATTIME();
MacExp: 			tm = get_fattime();
 4868  				if (res == FR_OK) {					/* Initialize the new directory table */
 4869  					res = dir_clear(fs, dcl);		/* Clean up the new table */
 4870  					if (res == FR_OK && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)) {	/* Create dot entries (FAT only) */
MacExp: 				if (res == FR_OK && (!0 || fs->fs_type != 4)) {	/* Create dot entries (FAT only) */
 4871  						dir = fs->win;
 4872  						mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
MacExp: 					mem_set(dir + 0, ' ', 11);	/* Create "." entry */
 4873  						dir[DIR_Name] = '.';
MacExp: 					dir[0] = '.';
 4874  						dir[DIR_Attr] = AM_DIR;
MacExp: 					dir[11] = 0x10;
 4875  						st_dword(dir + DIR_ModTime, tm);
MacExp: 					st_dword(dir + 22, tm);
 4876  						st_clust(fs, dir, dcl);
 4877  						mem_cpy(dir + SZDIRE, dir, SZDIRE); /* Create ".." entry */
MacExp: 					mem_cpy(dir + 32, dir, 32); /* Create ".." entry */
 4878  						dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
MacExp: 					dir[32 + 1] = '.'; pcl = dj.obj.sclust;
 4879  						st_clust(fs, dir + SZDIRE, pcl);
MacExp: 					st_clust(fs, dir + 32, pcl);
 4880  						fs->wflag = 1;
 4881  					}
 4882  				}
 4883  				if (res == FR_OK) {
 4884  					res = dir_register(&dj);	/* Register the object to the directoy */
 4885  				}
 4886  				if (res == FR_OK) {
 4887  	#if FF_FS_EXFAT
MacExp: #if 0
 4888 X					if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
 4889 X						st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
 4890 X						st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
 4891 X						st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
 4892 X						st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
 4893 X						fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
 4894 X						fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
 4895 X						res = store_xdir(&dj);
 4896 X					} else
 4897  	#endif
 4898  					{
 4899  						dir = dj.dir;
 4900  						st_dword(dir + DIR_ModTime, tm);	/* Created time */
MacExp: 					st_dword(dir + 22, tm);	/* Created time */
 4901  						st_clust(fs, dir, dcl);				/* Table start cluster */
 4902  						dir[DIR_Attr] = AM_DIR;				/* Attribute */
MacExp: 					dir[11] = 0x10;				/* Attribute */
 4903  						fs->wflag = 1;
 4904  					}
 4905  					if (res == FR_OK) {
 4906  						res = sync_fs(fs);
 4907  					}
 4908  				} else {
 4909  					remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 4910  				}
 4911  			}
 4912  			FREE_NAMBUF();
MacExp: 		;
 4913  		}
 4914  	
 4915  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 4916  	}
 4917  	
 4918  	
 4919  	
 4920  	
 4921 C	/*-----------------------------------------------------------------------*/
 4922 C	/* Rename a File/Directory                                               */
 4923 C	/*-----------------------------------------------------------------------*/
 4924 C	
 4925  	FRESULT f_rename (
 4926  		const TCHAR* path_old,	/* Pointer to the object name to be renamed */
 4927  		const TCHAR* path_new	/* Pointer to the new name */
 4928  	)
 4929  	{
 4930  		FRESULT res;
 4931  		DIR djo, djn;
 4932  		FATFS *fs;
 4933  		BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
MacExp: 	BYTE buf[0 ? 32 * 2 : 32], *dir;
 4934  		DWORD dw;
 4935  		DEF_NAMBUF
MacExp: 	
 4936  	
 4937  	
 4938  		get_ldnumber(&path_new);						/* Snip the drive number of new name off */
 4939  		res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
MacExp: 	res = find_volume(&path_old, &fs, 0x02);	/* Get logical drive of the old object */
 4940  		if (res == FR_OK) {
 4941  			djo.obj.fs = fs;
 4942  			INIT_NAMBUF(fs);
MacExp: 		;
 4943  			res = follow_path(&djo, path_old);		/* Check old object */
 4944  			if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
MacExp: 		if (res == FR_OK && (djo.fn[11] & (0x20 | 0x80))) res = FR_INVALID_NAME;	/* Check validity of name */
 4945  	#if FF_FS_LOCK != 0
MacExp: #if 0 != 0
 4946 X			if (res == FR_OK) {
 4947 X				res = chk_lock(&djo, 2);
 4948 X			}
 4949  	#endif
 4950  			if (res == FR_OK) {						/* Object to be renamed is found */
 4951  	#if FF_FS_EXFAT
MacExp: #if 0
 4952 X				if (fs->fs_type == FS_EXFAT) {	/* At exFAT volume */
 4953 X					BYTE nf, nn;
 4954 X					WORD nh;
 4955 X	
 4956 X					mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
 4957 X					mem_cpy(&djn, &djo, sizeof djo);
 4958 X					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 4959 X					if (res == FR_OK) {						/* Is new name already in use by any other object? */
 4960 X						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 4961 X					}
 4962 X					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 4963 X						res = dir_register(&djn);			/* Register the new entry */
 4964 X						if (res == FR_OK) {
 4965 X							nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
 4966 X							nh = ld_word(fs->dirbuf + XDIR_NameHash);
 4967 X							mem_cpy(fs->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry */
 4968 X							fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
 4969 X							st_word(fs->dirbuf + XDIR_NameHash, nh);
 4970 X							if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
 4971 X	/* Start of critical section where an interruption can cause a cross-link */
 4972 X							res = store_xdir(&djn);
 4973 X						}
 4974 X					}
 4975 X				} else
 4976  	#endif
 4977  				{	/* At FAT/FAT32 volume */
 4978  					mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
MacExp: 				mem_cpy(buf, djo.dir, 32);			/* Save directory entry of the object */
 4979  					mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
 4980  					res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 4981  					if (res == FR_OK) {						/* Is new name already in use by any other object? */
 4982  						res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 4983  					}
 4984  					if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 4985  						res = dir_register(&djn);			/* Register the new entry */
 4986  						if (res == FR_OK) {
 4987  							dir = djn.dir;					/* Copy directory entry of the object except name */
 4988  							mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
MacExp: 						mem_cpy(dir + 13, buf + 13, 32 - 13);
 4989  							dir[DIR_Attr] = buf[DIR_Attr];
MacExp: 						dir[11] = buf[11];
 4990  							if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
MacExp: 						if (!(dir[11] & 0x10)) dir[11] |= 0x20;	/* Set archive attribute if it is a file */
 4991  							fs->wflag = 1;
 4992  							if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
MacExp: 						if ((dir[11] & 0x10) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
 4993  								dw = clst2sect(fs, ld_clust(fs, dir));
 4994  								if (dw == 0) {
 4995  									res = FR_INT_ERR;
 4996  								} else {
 4997 C	/* Start of critical section where an interruption can cause a cross-link */
 4998  									res = move_window(fs, dw);
 4999  									dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
MacExp: 								dir = fs->win + 32 * 1;	/* Ptr to .. entry */
 5000  									if (res == FR_OK && dir[1] == '.') {
 5001  										st_clust(fs, dir, djn.obj.sclust);
 5002  										fs->wflag = 1;
 5003  									}
 5004  								}
 5005  							}
 5006  						}
 5007  					}
 5008  				}
 5009  				if (res == FR_OK) {
 5010  					res = dir_remove(&djo);		/* Remove old entry */
 5011  					if (res == FR_OK) {
 5012  						res = sync_fs(fs);
 5013  					}
 5014  				}
 5015 C	/* End of the critical section */
 5016  			}
 5017  			FREE_NAMBUF();
MacExp: 		;
 5018  		}
 5019  	
 5020  		LEAVE_FF(fs, res);
MacExp: 	return  res;
 5021  	}
 5022  	
 5023  	#endif /* !FF_FS_READONLY */
 5024  	#endif /* FF_FS_MINIMIZE == 0 */
 5025  	#endif /* FF_FS_MINIMIZE <= 1 */
 5026  	#endif /* FF_FS_MINIMIZE <= 2 */
 5027  	
 5028  	
 5029  	
 5030  	#if FF_USE_CHMOD && !FF_FS_READONLY
MacExp: #if 0 && !0
 5031 X	/*-----------------------------------------------------------------------*/
 5032 X	/* Change Attribute                                                      */
 5033 X	/*-----------------------------------------------------------------------*/
 5034 X	
 5035 X	FRESULT f_chmod (
 5036 X		const TCHAR* path,	/* Pointer to the file path */
 5037 X		BYTE attr,			/* Attribute bits */
 5038 X		BYTE mask			/* Attribute mask to change */
 5039 X	)
 5040 X	{
 5041 X		FRESULT res;
 5042 X		DIR dj;
 5043 X		FATFS *fs;
 5044 X		DEF_NAMBUF
 5045 X	
 5046 X	
 5047 X		res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 5048 X		if (res == FR_OK) {
 5049 X			dj.obj.fs = fs;
 5050 X			INIT_NAMBUF(fs);
 5051 X			res = follow_path(&dj, path);	/* Follow the file path */
 5052 X			if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
 5053 X			if (res == FR_OK) {
 5054 X				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 5055 X	#if FF_FS_EXFAT
MacExp: #if 0
 5056 X				if (fs->fs_type == FS_EXFAT) {
 5057 X					fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 5058 X					res = store_xdir(&dj);
 5059 X				} else
 5060 X	#endif
 5061 X				{
 5062 X					dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 5063 X					fs->wflag = 1;
 5064 X				}
 5065 X				if (res == FR_OK) {
 5066 X					res = sync_fs(fs);
 5067 X				}
 5068 X			}
 5069 X			FREE_NAMBUF();
 5070 X		}
 5071 X	
 5072 X		LEAVE_FF(fs, res);
 5073 X	}
 5074 X	
 5075 X	
 5076 X	
 5077 X	
 5078 X	/*-----------------------------------------------------------------------*/
 5079 X	/* Change Timestamp                                                      */
 5080 X	/*-----------------------------------------------------------------------*/
 5081 X	
 5082 X	FRESULT f_utime (
 5083 X		const TCHAR* path,	/* Pointer to the file/directory name */
 5084 X		const FILINFO* fno	/* Pointer to the timestamp to be set */
 5085 X	)
 5086 X	{
 5087 X		FRESULT res;
 5088 X		DIR dj;
 5089 X		FATFS *fs;
 5090 X		DEF_NAMBUF
 5091 X	
 5092 X	
 5093 X		res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 5094 X		if (res == FR_OK) {
 5095 X			dj.obj.fs = fs;
 5096 X			INIT_NAMBUF(fs);
 5097 X			res = follow_path(&dj, path);	/* Follow the file path */
 5098 X			if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
 5099 X			if (res == FR_OK) {
 5100 X	#if FF_FS_EXFAT
MacExp: #if 0
 5101 X				if (fs->fs_type == FS_EXFAT) {
 5102 X					st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
 5103 X					res = store_xdir(&dj);
 5104 X				} else
 5105 X	#endif
 5106 X				{
 5107 X					st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
 5108 X					fs->wflag = 1;
 5109 X				}
 5110 X				if (res == FR_OK) {
 5111 X					res = sync_fs(fs);
 5112 X				}
 5113 X			}
 5114 X			FREE_NAMBUF();
 5115 X		}
 5116 X	
 5117 X		LEAVE_FF(fs, res);
 5118 X	}
 5119 X	
 5120  	#endif	/* FF_USE_CHMOD && !FF_FS_READONLY */
 5121  	
 5122  	
 5123  	
 5124  	#if FF_USE_LABEL
MacExp: #if 0
 5125 X	/*-----------------------------------------------------------------------*/
 5126 X	/* Get Volume Label                                                      */
 5127 X	/*-----------------------------------------------------------------------*/
 5128 X	
 5129 X	FRESULT f_getlabel (
 5130 X		const TCHAR* path,	/* Logical drive number */
 5131 X		TCHAR* label,		/* Buffer to store the volume label */
 5132 X		DWORD* vsn			/* Variable to store the volume serial number */
 5133 X	)
 5134 X	{
 5135 X		FRESULT res;
 5136 X		DIR dj;
 5137 X		FATFS *fs;
 5138 X		UINT si, di;
 5139 X		WCHAR wc;
 5140 X	
 5141 X		/* Get logical drive */
 5142 X		res = find_volume(&path, &fs, 0);
 5143 X	
 5144 X		/* Get volume label */
 5145 X		if (res == FR_OK && label) {
 5146 X			dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 5147 X			res = dir_sdi(&dj, 0);
 5148 X			if (res == FR_OK) {
 5149 X			 	res = dir_read_label(&dj);		/* Find a volume label entry */
 5150 X			 	if (res == FR_OK) {
 5151 X	#if FF_FS_EXFAT
MacExp: #if 0
 5152 X					if (fs->fs_type == FS_EXFAT) {
 5153 X						WCHAR hs;
 5154 X	
 5155 X						for (si = di = hs = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
 5156 X							wc = ld_word(dj.dir + XDIR_Label + si * 2);
 5157 X							if (hs == 0 && IsSurrogate(wc)) {	/* Is the code a surrogate? */
 5158 X								hs = wc; continue;
 5159 X							}
 5160 X							wc = put_utf((DWORD)hs << 16 | wc, &label[di], 4);
 5161 X							if (wc == 0) { di = 0; break; }
 5162 X							di += wc;
 5163 X							hs = 0;
 5164 X						}
 5165 X						if (hs != 0) di = 0;	/* Broken surrogate pair? */
 5166 X						label[di] = 0;
 5167 X					} else
 5168 X	#endif
 5169 X					{
 5170 X						si = di = 0;		/* Extract volume label from AM_VOL entry */
 5171 X						while (si < 11) {
 5172 X							wc = dj.dir[si++];
 5173 X	#if FF_USE_LFN && FF_LFN_UNICODE >= 1 	/* Unicode output */
MacExp: #if 1 && 0 >= 1 	/* Unicode output */
 5174 X							if (dbc_1st((BYTE)wc) && si < 11) wc = wc << 8 | dj.dir[si++];	/* Is it a DBC? */
 5175 X							wc = ff_oem2uni(wc, CODEPAGE);					/* Convert it into Unicode */
 5176 X							if (wc != 0) wc = put_utf(wc, &label[di], 4);	/* Put it in Unicode */
 5177 X							if (wc == 0) { di = 0; break; }
 5178 X							di += wc;
 5179 X	#else									/* ANSI/OEM output */
 5180 X							label[di++] = (TCHAR)wc;
 5181 X	#endif
 5182 X						}
 5183 X						do {				/* Truncate trailing spaces */
 5184 X							label[di] = 0;
 5185 X							if (di == 0) break;
 5186 X						} while (label[--di] == ' ');
 5187 X					}
 5188 X				}
 5189 X			}
 5190 X			if (res == FR_NO_FILE) {	/* No label entry and return nul string */
 5191 X				label[0] = 0;
 5192 X				res = FR_OK;
 5193 X			}
 5194 X		}
 5195 X	
 5196 X		/* Get volume serial number */
 5197 X		if (res == FR_OK && vsn) {
 5198 X			res = move_window(fs, fs->volbase);
 5199 X			if (res == FR_OK) {
 5200 X				switch (fs->fs_type) {
 5201 X				case FS_EXFAT:
 5202 X					di = BPB_VolIDEx; break;
 5203 X	
 5204 X				case FS_FAT32:
 5205 X					di = BS_VolID32; break;
 5206 X	
 5207 X				default:
 5208 X					di = BS_VolID;
 5209 X				}
 5210 X				*vsn = ld_dword(fs->win + di);
 5211 X			}
 5212 X		}
 5213 X	
 5214 X		LEAVE_FF(fs, res);
 5215 X	}
 5216 X	
 5217 X	
 5218 X	
 5219 X	#if !FF_FS_READONLY
MacExp: #if !0
 5220 X	/*-----------------------------------------------------------------------*/
 5221 X	/* Set Volume Label                                                      */
 5222 X	/*-----------------------------------------------------------------------*/
 5223 X	
 5224 X	FRESULT f_setlabel (
 5225 X		const TCHAR* label	/* Volume label to set with heading logical drive number */
 5226 X	)
 5227 X	{
 5228 X		FRESULT res;
 5229 X		DIR dj;
 5230 X		FATFS *fs;
 5231 X		BYTE dirvn[22];
 5232 X		UINT di;
 5233 X		WCHAR wc;
 5234 X		static const char badchr[] = "+.,;=[]/\\\"*:<>\?|\x7F";	/* [0..] for FAT, [7..] for exFAT */
 5235 X	#if FF_USE_LFN
MacExp: #if 1
 5236 X		DWORD dc;
 5237 X	#endif
 5238 X	
 5239 X		/* Get logical drive */
 5240 X		res = find_volume(&label, &fs, FA_WRITE);
 5241 X		if (res != FR_OK) LEAVE_FF(fs, res);
 5242 X	
 5243 X	#if FF_FS_EXFAT
MacExp: #if 0
 5244 X		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 5245 X			mem_set(dirvn, 0, 22);
 5246 X			di = 0;
 5247 X			while ((UINT)*label >= ' ') {	/* Create volume label */
 5248 X				dc = tchar2uni(&label);	/* Get a Unicode character */
 5249 X				if (dc >= 0x10000) {
 5250 X					if (dc == 0xFFFFFFFF || di >= 10) {	/* Wrong surrogate or buffer overflow */
 5251 X						dc = 0;
 5252 X					} else {
 5253 X						st_word(dirvn + di * 2, (WCHAR)(dc >> 16)); di++;
 5254 X					}
 5255 X				}
 5256 X				if (dc == 0 || chk_chr(badchr + 7, (int)dc) || di >= 11) {	/* Check validity of the volume label */
 5257 X					LEAVE_FF(fs, FR_INVALID_NAME);
 5258 X				}
 5259 X				st_word(dirvn + di * 2, (WCHAR)dc); di++;
 5260 X			}
 5261 X		} else
 5262 X	#endif
 5263 X		{	/* On the FAT/FAT32 volume */
 5264 X			mem_set(dirvn, ' ', 11);
 5265 X			di = 0;
 5266 X			while ((UINT)*label >= ' ') {	/* Create volume label */
 5267 X	#if FF_USE_LFN
MacExp: #if 1
 5268 X				dc = tchar2uni(&label);
 5269 X				wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;
 5270 X	#else									/* ANSI/OEM input */
 5271 X				wc = (BYTE)*label++;
 5272 X				if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
 5273 X				if (IsLower(wc)) wc -= 0x20;		/* To upper ASCII characters */
 5274 X	#if FF_CODE_PAGE == 0
MacExp: #if 437 == 0
 5275 X				if (ExCvt && wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
 5276 X	#elif FF_CODE_PAGE < 900
 5277 X				if (wc >= 0x80) wc = ExCvt[wc - 0x80];	/* To upper extended characters (SBCS cfg) */
 5278 X	#endif
 5279 X	#endif
 5280 X				if (wc == 0 || chk_chr(badchr + 0, (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
 5281 X					LEAVE_FF(fs, FR_INVALID_NAME);
 5282 X				}
 5283 X				if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
 5284 X				dirvn[di++] = (BYTE)wc;
 5285 X			}
 5286 X			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
 5287 X			while (di && dirvn[di - 1] == ' ') di--;				/* Snip trailing spaces */
 5288 X		}
 5289 X	
 5290 X		/* Set volume label */
 5291 X		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 5292 X		res = dir_sdi(&dj, 0);
 5293 X		if (res == FR_OK) {
 5294 X			res = dir_read_label(&dj);	/* Get volume label entry */
 5295 X			if (res == FR_OK) {
 5296 X				if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
 5297 X					dj.dir[XDIR_NumLabel] = (BYTE)di;	/* Change the volume label */
 5298 X					mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
 5299 X				} else {
 5300 X					if (di != 0) {
 5301 X						mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
 5302 X					} else {
 5303 X						dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
 5304 X					}
 5305 X				}
 5306 X				fs->wflag = 1;
 5307 X				res = sync_fs(fs);
 5308 X			} else {			/* No volume label entry or an error */
 5309 X				if (res == FR_NO_FILE) {
 5310 X					res = FR_OK;
 5311 X					if (di != 0) {	/* Create a volume label entry */
 5312 X						res = dir_alloc(&dj, 1);	/* Allocate an entry */
 5313 X						if (res == FR_OK) {
 5314 X							mem_set(dj.dir, 0, SZDIRE);	/* Clean the entry */
 5315 X							if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
 5316 X								dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
 5317 X								dj.dir[XDIR_NumLabel] = (BYTE)di;
 5318 X								mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
 5319 X							} else {
 5320 X								dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
 5321 X								mem_cpy(dj.dir, dirvn, 11);
 5322 X							}
 5323 X							fs->wflag = 1;
 5324 X							res = sync_fs(fs);
 5325 X						}
 5326 X					}
 5327 X				}
 5328 X			}
 5329 X		}
 5330 X	
 5331 X		LEAVE_FF(fs, res);
 5332 X	}
 5333 X	
 5334 X	#endif /* !FF_FS_READONLY */
 5335  	#endif /* FF_USE_LABEL */
 5336  	
 5337  	
 5338  	
 5339  	#if FF_USE_EXPAND && !FF_FS_READONLY
MacExp: #if 0 && !0
 5340 X	/*-----------------------------------------------------------------------*/
 5341 X	/* Allocate a Contiguous Blocks to the File                              */
 5342 X	/*-----------------------------------------------------------------------*/
 5343 X	
 5344 X	FRESULT f_expand (
 5345 X		FIL* fp,		/* Pointer to the file object */
 5346 X		FSIZE_t fsz,	/* File size to be expanded to */
 5347 X		BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
 5348 X	)
 5349 X	{
 5350 X		FRESULT res;
 5351 X		FATFS *fs;
 5352 X		DWORD n, clst, stcl, scl, ncl, tcl, lclst;
 5353 X	
 5354 X	
 5355 X		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 5356 X		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
 5357 X		if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
 5358 X	#if FF_FS_EXFAT
MacExp: #if 0
 5359 X		if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
 5360 X	#endif
 5361 X		n = (DWORD)fs->csize * SS(fs);	/* Cluster size */
 5362 X		tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0);	/* Number of clusters required */
 5363 X		stcl = fs->last_clst; lclst = 0;
 5364 X		if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
 5365 X	
 5366 X	#if FF_FS_EXFAT
MacExp: #if 0
 5367 X		if (fs->fs_type == FS_EXFAT) {
 5368 X			scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
 5369 X			if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
 5370 X			if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
 5371 X			if (res == FR_OK) {	/* A contiguous free area is found */
 5372 X				if (opt) {		/* Allocate it now */
 5373 X					res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
 5374 X					lclst = scl + tcl - 1;
 5375 X				} else {		/* Set it as suggested point for next allocation */
 5376 X					lclst = scl - 1;
 5377 X				}
 5378 X			}
 5379 X		} else
 5380 X	#endif
 5381 X		{
 5382 X			scl = clst = stcl; ncl = 0;
 5383 X			while (1) {	/* Find a contiguous cluster block */
 5384 X				n = get_fat(&fp->obj, clst);
 5385 X				if (++clst >= fs->n_fatent) clst = 2;
 5386 X				if (n == 1) { res = FR_INT_ERR; break; }
 5387 X				if (n == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 5388 X				if (n == 0) {	/* Is it a free cluster? */
 5389 X					if (++ncl == tcl) break;	/* Break if a contiguous cluster block is found */
 5390 X				} else {
 5391 X					scl = clst; ncl = 0;		/* Not a free cluster */
 5392 X				}
 5393 X				if (clst == stcl) { res = FR_DENIED; break; }	/* No contiguous cluster? */
 5394 X			}
 5395 X			if (res == FR_OK) {	/* A contiguous free area is found */
 5396 X				if (opt) {		/* Allocate it now */
 5397 X					for (clst = scl, n = tcl; n; clst++, n--) {	/* Create a cluster chain on the FAT */
 5398 X						res = put_fat(fs, clst, (n == 1) ? 0xFFFFFFFF : clst + 1);
 5399 X						if (res != FR_OK) break;
 5400 X						lclst = clst;
 5401 X					}
 5402 X				} else {		/* Set it as suggested point for next allocation */
 5403 X					lclst = scl - 1;
 5404 X				}
 5405 X			}
 5406 X		}
 5407 X	
 5408 X		if (res == FR_OK) {
 5409 X			fs->last_clst = lclst;		/* Set suggested start cluster to start next */
 5410 X			if (opt) {	/* Is it allocated now? */
 5411 X				fp->obj.sclust = scl;		/* Update object allocation information */
 5412 X				fp->obj.objsize = fsz;
 5413 X				if (FF_FS_EXFAT) fp->obj.stat = 2;	/* Set status 'contiguous chain' */
 5414 X				fp->flag |= FA_MODIFIED;
 5415 X				if (fs->free_clst <= fs->n_fatent - 2) {	/* Update FSINFO */
 5416 X					fs->free_clst -= tcl;
 5417 X					fs->fsi_flag |= 1;
 5418 X				}
 5419 X			}
 5420 X		}
 5421 X	
 5422 X		LEAVE_FF(fs, res);
 5423 X	}
 5424 X	
 5425  	#endif /* FF_USE_EXPAND && !FF_FS_READONLY */
 5426  	
 5427  	
 5428  	
 5429  	#if FF_USE_FORWARD
MacExp: #if 0
 5430 X	/*-----------------------------------------------------------------------*/
 5431 X	/* Forward Data to the Stream Directly                                   */
 5432 X	/*-----------------------------------------------------------------------*/
 5433 X	
 5434 X	FRESULT f_forward (
 5435 X		FIL* fp, 						/* Pointer to the file object */
 5436 X		UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
 5437 X		UINT btf,						/* Number of bytes to forward */
 5438 X		UINT* bf						/* Pointer to number of bytes forwarded */
 5439 X	)
 5440 X	{
 5441 X		FRESULT res;
 5442 X		FATFS *fs;
 5443 X		DWORD clst, sect;
 5444 X		FSIZE_t remain;
 5445 X		UINT rcnt, csect;
 5446 X		BYTE *dbuf;
 5447 X	
 5448 X	
 5449 X		*bf = 0;	/* Clear transfer byte counter */
 5450 X		res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 5451 X		if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
 5452 X		if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 5453 X	
 5454 X		remain = fp->obj.objsize - fp->fptr;
 5455 X		if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
 5456 X	
 5457 X		for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream goes busy */
 5458 X			fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
 5459 X			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 5460 X			if (fp->fptr % SS(fs) == 0) {				/* On the sector boundary? */
 5461 X				if (csect == 0) {						/* On the cluster boundary? */
 5462 X					clst = (fp->fptr == 0) ?			/* On the top of the file? */
 5463 X						fp->obj.sclust : get_fat(&fp->obj, fp->clust);
 5464 X					if (clst <= 1) ABORT(fs, FR_INT_ERR);
 5465 X					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 5466 X					fp->clust = clst;					/* Update current cluster */
 5467 X				}
 5468 X			}
 5469 X			sect = clst2sect(fs, fp->clust);			/* Get current data sector */
 5470 X			if (sect == 0) ABORT(fs, FR_INT_ERR);
 5471 X			sect += csect;
 5472 X	#if FF_FS_TINY
MacExp: #if 1
 5473 X			if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window to the file data */
 5474 X			dbuf = fs->win;
 5475 X	#else
 5476 X			if (fp->sect != sect) {		/* Fill sector cache with file data */
 5477 X	#if !FF_FS_READONLY
MacExp: #if !0
 5478 X				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 5479 X					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 5480 X					fp->flag &= (BYTE)~FA_DIRTY;
 5481 X				}
 5482 X	#endif
 5483 X				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 5484 X			}
 5485 X			dbuf = fp->buf;
 5486 X	#endif
 5487 X			fp->sect = sect;
 5488 X			rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 5489 X			if (rcnt > btf) rcnt = btf;					/* Clip it by btr if needed */
 5490 X			rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);	/* Forward the file data */
 5491 X			if (rcnt == 0) ABORT(fs, FR_INT_ERR);
 5492 X		}
 5493 X	
 5494 X		LEAVE_FF(fs, FR_OK);
 5495 X	}
 5496  	#endif /* FF_USE_FORWARD */
 5497  	
 5498  	
 5499  	
 5500  	#if FF_USE_MKFS && !FF_FS_READONLY
MacExp: #if 0 && !0
 5501 X	/*-----------------------------------------------------------------------*/
 5502 X	/* Create an FAT/exFAT volume                                            */
 5503 X	/*-----------------------------------------------------------------------*/
 5504 X	
 5505 X	FRESULT f_mkfs (
 5506 X		const TCHAR* path,	/* Logical drive number */
 5507 X		BYTE opt,			/* Format option */
 5508 X		DWORD au,			/* Size of allocation unit (cluster) [byte] */
 5509 X		void* work,			/* Pointer to working buffer (null: use heap memory) */
 5510 X		UINT len			/* Size of working buffer [byte] */
 5511 X	)
 5512 X	{
 5513 X		const UINT n_fats = 1;		/* Number of FATs for FAT/FAT32 volume (1 or 2) */
 5514 X		const UINT n_rootdir = 512;	/* Number of root directory entries for FAT volume */
 5515 X		static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};	/* Cluster size boundary for FAT volume (4Ks unit) */
 5516 X		static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};	/* Cluster size boundary for FAT32 volume (128Ks unit) */
 5517 X		BYTE fmt, sys, *buf, *pte, pdrv, part;
 5518 X		WORD ss;	/* Sector size */
 5519 X		DWORD szb_buf, sz_buf, sz_blk, n_clst, pau, sect, nsect, n;
 5520 X		DWORD b_vol, b_fat, b_data;				/* Base LBA for volume, fat, data */
 5521 X		DWORD sz_vol, sz_rsv, sz_fat, sz_dir;	/* Size for volume, fat, dir, data */
 5522 X		UINT i;
 5523 X		int vol;
 5524 X		DSTATUS stat;
 5525 X	#if FF_USE_TRIM || FF_FS_EXFAT
MacExp: #if 0 || 0
 5526 X		DWORD tbl[3];
 5527 X	#endif
 5528 X	
 5529 X	
 5530 X		/* Check mounted drive and clear work area */
 5531 X		vol = get_ldnumber(&path);					/* Get target logical drive */
 5532 X		if (vol < 0) return FR_INVALID_DRIVE;
 5533 X		if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear the volume if mounted */
 5534 X		pdrv = LD2PD(vol);	/* Physical drive */
 5535 X		part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get from partition table) */
 5536 X	
 5537 X		/* Check physical drive status */
 5538 X		stat = disk_initialize(pdrv);
 5539 X		if (stat & STA_NOINIT) return FR_NOT_READY;
 5540 X		if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 5541 X		if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;	/* Erase block to align data area */
 5542 X	#if FF_MAX_SS != FF_MIN_SS		/* Get sector size of the medium if variable sector size cfg. */
MacExp: #if 512 != 512		/* Get sector size of the medium if variable sector size cfg. */
 5543 X		if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
 5544 X		if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
 5545 X	#else
 5546 X		ss = FF_MAX_SS;
 5547 X	#endif
 5548 X		if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
 5549 X		au /= ss;	/* Cluster size in unit of sector */
 5550 X	
 5551 X		/* Get working buffer */
 5552 X	#if FF_USE_LFN == 3
MacExp: #if 1 == 3
 5553 X		if (!work) {	/* Use heap memory for working buffer */
 5554 X			for (szb_buf = MAX_MALLOC, buf = 0; szb_buf >= ss && (buf = ff_memalloc(szb_buf)) == 0; szb_buf /= 2) ;
 5555 X			sz_buf = szb_buf / ss;		/* Size of working buffer (sector) */
 5556 X		} else
 5557 X	#endif
 5558 X		{
 5559 X			buf = (BYTE*)work;		/* Working buffer */
 5560 X			sz_buf = len / ss;		/* Size of working buffer (sector) */
 5561 X			szb_buf = sz_buf * ss;	/* Size of working buffer (byte) */
 5562 X		}
 5563 X		if (!buf || sz_buf == 0) return FR_NOT_ENOUGH_CORE;
 5564 X	
 5565 X		/* Determine where the volume to be located (b_vol, sz_vol) */
 5566 X		if (FF_MULTI_PARTITION && part != 0) {
 5567 X			/* Get partition information from partition table in the MBR */
 5568 X			if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Load MBR */
 5569 X			if (ld_word(buf + BS_55AA) != 0xAA55) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if MBR is valid */
 5570 X			pte = buf + (MBR_Table + (part - 1) * SZ_PTE);
 5571 X			if (pte[PTE_System] == 0) LEAVE_MKFS(FR_MKFS_ABORTED);	/* No partition? */
 5572 X			b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
 5573 X			sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
 5574 X		} else {
 5575 X			/* Create a single-partition in this function */
 5576 X			if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5577 X			b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
 5578 X			if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);
 5579 X			sz_vol -= b_vol;						/* Volume size */
 5580 X		}
 5581 X		if (sz_vol < 128) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Check if volume size is >=128s */
 5582 X	
 5583 X		/* Pre-determine the FAT type */
 5584 X		do {
 5585 X			if (FF_FS_EXFAT && (opt & FM_EXFAT)) {	/* exFAT possible? */
 5586 X				if ((opt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || au > 128) {	/* exFAT only, vol >= 64Ms or au > 128s ? */
 5587 X					fmt = FS_EXFAT; break;
 5588 X				}
 5589 X			}
 5590 X			if (au > 128) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* Too large au for FAT/FAT32 */
 5591 X			if (opt & FM_FAT32) {	/* FAT32 possible? */
 5592 X				if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
 5593 X					fmt = FS_FAT32; break;
 5594 X				}
 5595 X			}
 5596 X			if (!(opt & FM_FAT)) LEAVE_MKFS(FR_INVALID_PARAMETER);	/* no-FAT? */
 5597 X			fmt = FS_FAT16;
 5598 X		} while (0);
 5599 X	
 5600 X	#if FF_FS_EXFAT
MacExp: #if 0
 5601 X		if (fmt == FS_EXFAT) {	/* Create an exFAT volume */
 5602 X			DWORD szb_bit, szb_case, sum, nb, cl;
 5603 X			WCHAR ch, si;
 5604 X			UINT j, st;
 5605 X			BYTE b;
 5606 X	
 5607 X			if (sz_vol < 0x1000) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
 5608 X	#if FF_USE_TRIM
MacExp: #if 0
 5609 X			tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area may be erased */
 5610 X			disk_ioctl(pdrv, CTRL_TRIM, tbl);
 5611 X	#endif
 5612 X			/* Determine FAT location, data location and number of clusters */
 5613 X			if (au == 0) {	/* au auto-selection */
 5614 X				au = 8;
 5615 X				if (sz_vol >= 0x80000) au = 64;		/* >= 512Ks */
 5616 X				if (sz_vol >= 0x4000000) au = 256;	/* >= 64Ms */
 5617 X			}
 5618 X			b_fat = b_vol + 32;										/* FAT start at offset 32 */
 5619 X			sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;			/* Number of FAT sectors */
 5620 X			b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1);	/* Align data area to the erase block boundary */
 5621 X			if (b_data >= sz_vol / 2) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
 5622 X			n_clst = (sz_vol - (b_data - b_vol)) / au;				/* Number of clusters */
 5623 X			if (n_clst <16) LEAVE_MKFS(FR_MKFS_ABORTED);			/* Too few clusters? */
 5624 X			if (n_clst > MAX_EXFAT) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters? */
 5625 X	
 5626 X			szb_bit = (n_clst + 7) / 8;						/* Size of allocation bitmap */
 5627 X			tbl[0] = (szb_bit + au * ss - 1) / (au * ss);	/* Number of allocation bitmap clusters */
 5628 X	
 5629 X			/* Create a compressed up-case table */
 5630 X			sect = b_data + au * tbl[0];	/* Table start sector */
 5631 X			sum = 0;						/* Table checksum to be stored in the 82 entry */
 5632 X			st = 0; si = 0; i = 0; j = 0; szb_case = 0;
 5633 X			do {
 5634 X				switch (st) {
 5635 X				case 0:
 5636 X					ch = (WCHAR)ff_wtoupper(si);	/* Get an up-case char */
 5637 X					if (ch != si) {
 5638 X						si++; break;		/* Store the up-case char if exist */
 5639 X					}
 5640 X					for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;	/* Get run length of no-case block */
 5641 X					if (j >= 128) {
 5642 X						ch = 0xFFFF; st = 2; break;	/* Compress the no-case block if run is >= 128 */
 5643 X					}
 5644 X					st = 1;			/* Do not compress short run */
 5645 X					/* go to next case */
 5646 X				case 1:
 5647 X					ch = si++;		/* Fill the short run */
 5648 X					if (--j == 0) st = 0;
 5649 X					break;
 5650 X	
 5651 X				default:
 5652 X					ch = (WCHAR)j; si += (WCHAR)j;	/* Number of chars to skip */
 5653 X					st = 0;
 5654 X				}
 5655 X				sum = xsum32(buf[i + 0] = (BYTE)ch, sum);		/* Put it into the write buffer */
 5656 X				sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
 5657 X				i += 2; szb_case += 2;
 5658 X				if (si == 0 || i == szb_buf) {		/* Write buffered data when buffer full or end of process */
 5659 X					n = (i + ss - 1) / ss;
 5660 X					if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5661 X					sect += n; i = 0;
 5662 X				}
 5663 X			} while (si);
 5664 X			tbl[1] = (szb_case + au * ss - 1) / (au * ss);	/* Number of up-case table clusters */
 5665 X			tbl[2] = 1;										/* Number of root dir clusters */
 5666 X	
 5667 X			/* Initialize the allocation bitmap */
 5668 X			sect = b_data; nsect = (szb_bit + ss - 1) / ss;	/* Start of bitmap and number of sectors */
 5669 X			nb = tbl[0] + tbl[1] + tbl[2];					/* Number of clusters in-use by system */
 5670 X			do {
 5671 X				mem_set(buf, 0, szb_buf);
 5672 X				for (i = 0; nb >= 8 && i < szb_buf; buf[i++] = 0xFF, nb -= 8) ;
 5673 X				for (b = 1; nb != 0 && i < szb_buf; buf[i] |= b, b <<= 1, nb--) ;
 5674 X				n = (nsect > sz_buf) ? sz_buf : nsect;		/* Write the buffered data */
 5675 X				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5676 X				sect += n; nsect -= n;
 5677 X			} while (nsect);
 5678 X	
 5679 X			/* Initialize the FAT */
 5680 X			sect = b_fat; nsect = sz_fat;	/* Start of FAT and number of FAT sectors */
 5681 X			j = nb = cl = 0;
 5682 X			do {
 5683 X				mem_set(buf, 0, szb_buf); i = 0;	/* Clear work area and reset write index */
 5684 X				if (cl == 0) {	/* Set entry 0 and 1 */
 5685 X					st_dword(buf + i, 0xFFFFFFF8); i += 4; cl++;
 5686 X					st_dword(buf + i, 0xFFFFFFFF); i += 4; cl++;
 5687 X				}
 5688 X				do {			/* Create chains of bitmap, up-case and root dir */
 5689 X					while (nb != 0 && i < szb_buf) {			/* Create a chain */
 5690 X						st_dword(buf + i, (nb > 1) ? cl + 1 : 0xFFFFFFFF);
 5691 X						i += 4; cl++; nb--;
 5692 X					}
 5693 X					if (nb == 0 && j < 3) nb = tbl[j++];	/* Next chain */
 5694 X				} while (nb != 0 && i < szb_buf);
 5695 X				n = (nsect > sz_buf) ? sz_buf : nsect;	/* Write the buffered data */
 5696 X				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5697 X				sect += n; nsect -= n;
 5698 X			} while (nsect);
 5699 X	
 5700 X			/* Initialize the root directory */
 5701 X			mem_set(buf, 0, szb_buf);
 5702 X			buf[SZDIRE * 0 + 0] = 0x83;		/* 83 entry (volume label) */
 5703 X			buf[SZDIRE * 1 + 0] = 0x81;		/* 81 entry (allocation bitmap) */
 5704 X			st_dword(buf + SZDIRE * 1 + 20, 2);				/* cluster */
 5705 X			st_dword(buf + SZDIRE * 1 + 24, szb_bit);		/* size */
 5706 X			buf[SZDIRE * 2 + 0] = 0x82;		/* 82 entry (up-case table) */
 5707 X			st_dword(buf + SZDIRE * 2 + 4, sum);			/* sum */
 5708 X			st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);	/* cluster */
 5709 X			st_dword(buf + SZDIRE * 2 + 24, szb_case);		/* size */
 5710 X			sect = b_data + au * (tbl[0] + tbl[1]);	nsect = au;	/* Start of the root directory and number of sectors */
 5711 X			do {	/* Fill root directory sectors */
 5712 X				n = (nsect > sz_buf) ? sz_buf : nsect;
 5713 X				if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5714 X				mem_set(buf, 0, ss);
 5715 X				sect += n; nsect -= n;
 5716 X			} while (nsect);
 5717 X	
 5718 X			/* Create two set of the exFAT VBR blocks */
 5719 X			sect = b_vol;
 5720 X			for (n = 0; n < 2; n++) {
 5721 X				/* Main record (+0) */
 5722 X				mem_set(buf, 0, ss);
 5723 X				mem_cpy(buf + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11);	/* Boot jump code (x86), OEM name */
 5724 X				st_dword(buf + BPB_VolOfsEx, b_vol);					/* Volume offset in the physical drive [sector] */
 5725 X				st_dword(buf + BPB_TotSecEx, sz_vol);					/* Volume size [sector] */
 5726 X				st_dword(buf + BPB_FatOfsEx, b_fat - b_vol);			/* FAT offset [sector] */
 5727 X				st_dword(buf + BPB_FatSzEx, sz_fat);					/* FAT size [sector] */
 5728 X				st_dword(buf + BPB_DataOfsEx, b_data - b_vol);			/* Data offset [sector] */
 5729 X				st_dword(buf + BPB_NumClusEx, n_clst);					/* Number of clusters */
 5730 X				st_dword(buf + BPB_RootClusEx, 2 + tbl[0] + tbl[1]);	/* Root dir cluster # */
 5731 X				st_dword(buf + BPB_VolIDEx, GET_FATTIME());				/* VSN */
 5732 X				st_word(buf + BPB_FSVerEx, 0x100);						/* Filesystem version (1.00) */
 5733 X				for (buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;	/* Log2 of sector size [byte] */
 5734 X				for (buf[BPB_SecPerClusEx] = 0, i = au; i >>= 1; buf[BPB_SecPerClusEx]++) ;	/* Log2 of cluster size [sector] */
 5735 X				buf[BPB_NumFATsEx] = 1;					/* Number of FATs */
 5736 X				buf[BPB_DrvNumEx] = 0x80;				/* Drive number (for int13) */
 5737 X				st_word(buf + BS_BootCodeEx, 0xFEEB);	/* Boot code (x86) */
 5738 X				st_word(buf + BS_55AA, 0xAA55);			/* Signature (placed here regardless of sector size) */
 5739 X				for (i = sum = 0; i < ss; i++) {		/* VBR checksum */
 5740 X					if (i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);
 5741 X				}
 5742 X				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5743 X				/* Extended bootstrap record (+1..+8) */
 5744 X				mem_set(buf, 0, ss);
 5745 X				st_word(buf + ss - 2, 0xAA55);	/* Signature (placed at end of sector) */
 5746 X				for (j = 1; j < 9; j++) {
 5747 X					for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
 5748 X					if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5749 X				}
 5750 X				/* OEM/Reserved record (+9..+10) */
 5751 X				mem_set(buf, 0, ss);
 5752 X				for ( ; j < 11; j++) {
 5753 X					for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
 5754 X					if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5755 X				}
 5756 X				/* Sum record (+11) */
 5757 X				for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);		/* Fill with checksum value */
 5758 X				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5759 X			}
 5760 X	
 5761 X		} else
 5762 X	#endif	/* FF_FS_EXFAT */
 5763 X		{	/* Create an FAT/FAT32 volume */
 5764 X			do {
 5765 X				pau = au;
 5766 X				/* Pre-determine number of clusters and FAT sub-type */
 5767 X				if (fmt == FS_FAT32) {	/* FAT32 volume */
 5768 X					if (pau == 0) {	/* au auto-selection */
 5769 X						n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
 5770 X						for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 5771 X					}
 5772 X					n_clst = sz_vol / pau;	/* Number of clusters */
 5773 X					sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
 5774 X					sz_rsv = 32;	/* Number of reserved sectors */
 5775 X					sz_dir = 0;		/* No static directory */
 5776 X					if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
 5777 X				} else {				/* FAT volume */
 5778 X					if (pau == 0) {	/* au auto-selection */
 5779 X						n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
 5780 X						for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 5781 X					}
 5782 X					n_clst = sz_vol / pau;
 5783 X					if (n_clst > MAX_FAT12) {
 5784 X						n = n_clst * 2 + 4;		/* FAT size [byte] */
 5785 X					} else {
 5786 X						fmt = FS_FAT12;
 5787 X						n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
 5788 X					}
 5789 X					sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
 5790 X					sz_rsv = 1;						/* Number of reserved sectors */
 5791 X					sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
 5792 X				}
 5793 X				b_fat = b_vol + sz_rsv;						/* FAT base */
 5794 X				b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
 5795 X	
 5796 X				/* Align data base to erase block boundary (for flash memory media) */
 5797 X				n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
 5798 X				if (fmt == FS_FAT32) {		/* FAT32: Move FAT base */
 5799 X					sz_rsv += n; b_fat += n;
 5800 X				} else {					/* FAT: Expand FAT size */
 5801 X					sz_fat += n / n_fats;
 5802 X				}
 5803 X	
 5804 X				/* Determine number of clusters and final check of validity of the FAT sub-type */
 5805 X				if (sz_vol < b_data + pau * 16 - b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume */
 5806 X				n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
 5807 X				if (fmt == FS_FAT32) {
 5808 X					if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32 */
 5809 X						if (au == 0 && (au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
 5810 X						LEAVE_MKFS(FR_MKFS_ABORTED);
 5811 X					}
 5812 X				}
 5813 X				if (fmt == FS_FAT16) {
 5814 X					if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
 5815 X						if (au == 0 && (pau * 2) <= 64) {
 5816 X							au = pau * 2; continue;		/* Adjust cluster size and retry */
 5817 X						}
 5818 X						if ((opt & FM_FAT32)) {
 5819 X							fmt = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
 5820 X						}
 5821 X						if (au == 0 && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
 5822 X						LEAVE_MKFS(FR_MKFS_ABORTED);
 5823 X					}
 5824 X					if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
 5825 X						if (au == 0 && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
 5826 X						LEAVE_MKFS(FR_MKFS_ABORTED);
 5827 X					}
 5828 X				}
 5829 X				if (fmt == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters for FAT12 */
 5830 X	
 5831 X				/* Ok, it is the valid cluster configuration */
 5832 X				break;
 5833 X			} while (1);
 5834 X	
 5835 X	#if FF_USE_TRIM
MacExp: #if 0
 5836 X			tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
 5837 X			disk_ioctl(pdrv, CTRL_TRIM, tbl);
 5838 X	#endif
 5839 X			/* Create FAT VBR */
 5840 X			mem_set(buf, 0, ss);
 5841 X			mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
 5842 X			st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
 5843 X			buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
 5844 X			st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
 5845 X			buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
 5846 X			st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
 5847 X			if (sz_vol < 0x10000) {
 5848 X				st_word(buf + BPB_TotSec16, (WORD)sz_vol);	/* Volume size in 16-bit LBA */
 5849 X			} else {
 5850 X				st_dword(buf + BPB_TotSec32, sz_vol);		/* Volume size in 32-bit LBA */
 5851 X			}
 5852 X			buf[BPB_Media] = 0xF8;							/* Media descriptor byte */
 5853 X			st_word(buf + BPB_SecPerTrk, 63);				/* Number of sectors per track (for int13) */
 5854 X			st_word(buf + BPB_NumHeads, 255);				/* Number of heads (for int13) */
 5855 X			st_dword(buf + BPB_HiddSec, b_vol);				/* Volume offset in the physical drive [sector] */
 5856 X			if (fmt == FS_FAT32) {
 5857 X				st_dword(buf + BS_VolID32, GET_FATTIME());	/* VSN */
 5858 X				st_dword(buf + BPB_FATSz32, sz_fat);		/* FAT size [sector] */
 5859 X				st_dword(buf + BPB_RootClus32, 2);			/* Root directory cluster # (2) */
 5860 X				st_word(buf + BPB_FSInfo32, 1);				/* Offset of FSINFO sector (VBR + 1) */
 5861 X				st_word(buf + BPB_BkBootSec32, 6);			/* Offset of backup VBR (VBR + 6) */
 5862 X				buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
 5863 X				buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
 5864 X				mem_cpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 5865 X			} else {
 5866 X				st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
 5867 X				st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
 5868 X				buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
 5869 X				buf[BS_BootSig] = 0x29;						/* Extended boot signature */
 5870 X				mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 5871 X			}
 5872 X			st_word(buf + BS_55AA, 0xAA55);					/* Signature (offset is fixed here regardless of sector size) */
 5873 X			if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the VBR sector */
 5874 X	
 5875 X			/* Create FSINFO record if needed */
 5876 X			if (fmt == FS_FAT32) {
 5877 X				disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
 5878 X				mem_set(buf, 0, ss);
 5879 X				st_dword(buf + FSI_LeadSig, 0x41615252);
 5880 X				st_dword(buf + FSI_StrucSig, 0x61417272);
 5881 X				st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 5882 X				st_dword(buf + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
 5883 X				st_word(buf + BS_55AA, 0xAA55);
 5884 X				disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
 5885 X				disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
 5886 X			}
 5887 X	
 5888 X			/* Initialize FAT area */
 5889 X			mem_set(buf, 0, (UINT)szb_buf);
 5890 X			sect = b_fat;		/* FAT start sector */
 5891 X			for (i = 0; i < n_fats; i++) {			/* Initialize FATs each */
 5892 X				if (fmt == FS_FAT32) {
 5893 X					st_dword(buf + 0, 0xFFFFFFF8);	/* Entry 0 */
 5894 X					st_dword(buf + 4, 0xFFFFFFFF);	/* Entry 1 */
 5895 X					st_dword(buf + 8, 0x0FFFFFFF);	/* Entry 2 (root directory) */
 5896 X				} else {
 5897 X					st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
 5898 X				}
 5899 X				nsect = sz_fat;		/* Number of FAT sectors */
 5900 X				do {	/* Fill FAT sectors */
 5901 X					n = (nsect > sz_buf) ? sz_buf : nsect;
 5902 X					if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5903 X					mem_set(buf, 0, ss);
 5904 X					sect += n; nsect -= n;
 5905 X				} while (nsect);
 5906 X			}
 5907 X	
 5908 X			/* Initialize root directory (fill with zero) */
 5909 X			nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
 5910 X			do {
 5911 X				n = (nsect > sz_buf) ? sz_buf : nsect;
 5912 X				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5913 X				sect += n; nsect -= n;
 5914 X			} while (nsect);
 5915 X		}
 5916 X	
 5917 X		/* Determine system ID in the partition table */
 5918 X		if (FF_FS_EXFAT && fmt == FS_EXFAT) {
 5919 X			sys = 0x07;			/* HPFS/NTFS/exFAT */
 5920 X		} else {
 5921 X			if (fmt == FS_FAT32) {
 5922 X				sys = 0x0C;		/* FAT32X */
 5923 X			} else {
 5924 X				if (sz_vol >= 0x10000) {
 5925 X					sys = 0x06;	/* FAT12/16 (large) */
 5926 X				} else {
 5927 X					sys = (fmt == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 : FAT12 */
 5928 X				}
 5929 X			}
 5930 X		}
 5931 X	
 5932 X		/* Update partition information */
 5933 X		if (FF_MULTI_PARTITION && part != 0) {	/* Created in the existing partition */
 5934 X			/* Update system ID in the partition table */
 5935 X			if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Read the MBR */
 5936 X			buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;		/* Set system ID */
 5937 X			if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it back to the MBR */
 5938 X		} else {								/* Created as a new single partition */
 5939 X			if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
 5940 X				mem_set(buf, 0, ss);
 5941 X				st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
 5942 X				pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
 5943 X				pte[PTE_Boot] = 0;					/* Boot indicator */
 5944 X				pte[PTE_StHead] = 1;				/* Start head */
 5945 X				pte[PTE_StSec] = 1;					/* Start sector */
 5946 X				pte[PTE_StCyl] = 0;					/* Start cylinder */
 5947 X				pte[PTE_System] = sys;				/* System type */
 5948 X				n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
 5949 X				pte[PTE_EdHead] = 254;				/* End head */
 5950 X				pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);	/* End sector */
 5951 X				pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
 5952 X				st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
 5953 X				st_dword(pte + PTE_SizLba, sz_vol);	/* Size in sectors */
 5954 X				if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the MBR */
 5955 X			}
 5956 X		}
 5957 X	
 5958 X		if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 5959 X	
 5960 X		LEAVE_MKFS(FR_OK);
 5961 X	}
 5962 X	
 5963 X	
 5964 X	
 5965 X	#if FF_MULTI_PARTITION
MacExp: #if 0
 5966 X	/*-----------------------------------------------------------------------*/
 5967 X	/* Create Partition Table on the Physical Drive                          */
 5968 X	/*-----------------------------------------------------------------------*/
 5969 X	
 5970 X	FRESULT f_fdisk (
 5971 X		BYTE pdrv,			/* Physical drive number */
 5972 X		const DWORD* szt,	/* Pointer to the size table for each partitions */
 5973 X		void* work			/* Pointer to the working buffer (null: use heap memory) */
 5974 X	)
 5975 X	{
 5976 X		UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
 5977 X		BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
 5978 X		DSTATUS stat;
 5979 X		DWORD sz_disk, sz_part, s_part;
 5980 X		FRESULT res;
 5981 X	
 5982 X	
 5983 X		stat = disk_initialize(pdrv);
 5984 X		if (stat & STA_NOINIT) return FR_NOT_READY;
 5985 X		if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 5986 X		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
 5987 X	
 5988 X		buf = (BYTE*)work;
 5989 X	#if FF_USE_LFN == 3
MacExp: #if 1 == 3
 5990 X		if (!buf) buf = ff_memalloc(FF_MAX_SS);	/* Use heap memory for working buffer */
 5991 X	#endif
 5992 X		if (!buf) return FR_NOT_ENOUGH_CORE;
 5993 X	
 5994 X		/* Determine the CHS without any consideration of the drive geometry */
 5995 X		for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
 5996 X		if (n == 256) n--;
 5997 X		e_hd = (BYTE)(n - 1);
 5998 X		sz_cyl = 63 * n;
 5999 X		tot_cyl = sz_disk / sz_cyl;
 6000 X	
 6001 X		/* Create partition table */
 6002 X		mem_set(buf, 0, FF_MAX_SS);
 6003 X		p = buf + MBR_Table; b_cyl = 0;
 6004 X		for (i = 0; i < 4; i++, p += SZ_PTE) {
 6005 X			p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;	/* Number of cylinders */
 6006 X			if (p_cyl == 0) continue;
 6007 X			s_part = (DWORD)sz_cyl * b_cyl;
 6008 X			sz_part = (DWORD)sz_cyl * p_cyl;
 6009 X			if (i == 0) {	/* Exclude first track of cylinder 0 */
 6010 X				s_hd = 1;
 6011 X				s_part += 63; sz_part -= 63;
 6012 X			} else {
 6013 X				s_hd = 0;
 6014 X			}
 6015 X			e_cyl = b_cyl + p_cyl - 1;	/* End cylinder */
 6016 X			if (e_cyl >= tot_cyl) LEAVE_MKFS(FR_INVALID_PARAMETER);
 6017 X	
 6018 X			/* Set partition table */
 6019 X			p[1] = s_hd;						/* Start head */
 6020 X			p[2] = (BYTE)(((b_cyl >> 2) & 0xC0) | 1);	/* Start sector */
 6021 X			p[3] = (BYTE)b_cyl;					/* Start cylinder */
 6022 X			p[4] = 0x07;						/* System type (temporary setting) */
 6023 X			p[5] = e_hd;						/* End head */
 6024 X			p[6] = (BYTE)(((e_cyl >> 2) & 0xC0) | 63);	/* End sector */
 6025 X			p[7] = (BYTE)e_cyl;					/* End cylinder */
 6026 X			st_dword(p + 8, s_part);			/* Start sector in LBA */
 6027 X			st_dword(p + 12, sz_part);			/* Number of sectors */
 6028 X	
 6029 X			/* Next partition */
 6030 X			b_cyl += p_cyl;
 6031 X		}
 6032 X		st_word(p, 0xAA55);		/* MBR signature (always at offset 510) */
 6033 X	
 6034 X		/* Write it to the MBR */
 6035 X		res = (disk_write(pdrv, buf, 0, 1) == RES_OK && disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
 6036 X		LEAVE_MKFS(res);
 6037 X	}
 6038 X	
 6039 X	#endif /* FF_MULTI_PARTITION */
 6040  	#endif /* FF_USE_MKFS && !FF_FS_READONLY */
 6041  	
 6042  	
 6043  	
 6044  	
 6045  	#if FF_USE_STRFUNC
MacExp: #if 0
 6046 X	#if FF_USE_LFN && FF_LFN_UNICODE && (FF_STRF_ENCODE < 0 || FF_STRF_ENCODE > 3)
MacExp: #if 1 && 0 && (3 < 0 || 3 > 3)
 6047 X	#error Wrong FF_STRF_ENCODE setting
 6048 X	#endif
 6049 X	/*-----------------------------------------------------------------------*/
 6050 X	/* Get a String from the File                                            */
 6051 X	/*-----------------------------------------------------------------------*/
 6052 X	
 6053 X	TCHAR* f_gets (
 6054 X		TCHAR* buff,	/* Pointer to the string buffer to read */
 6055 X		int len,		/* Size of string buffer (items) */
 6056 X		FIL* fp			/* Pointer to the file object */
 6057 X	)
 6058 X	{
 6059 X		int nc = 0;
 6060 X		TCHAR *p = buff;
 6061 X		BYTE s[4];
 6062 X		UINT rc;
 6063 X		DWORD dc;
 6064 X	#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE <= 2
MacExp: #if 1 && 0 && 3 <= 2
 6065 X		WCHAR wc;
 6066 X	#endif
 6067 X	#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE == 3
MacExp: #if 1 && 0 && 3 == 3
 6068 X		UINT ct;
 6069 X	#endif
 6070 X	
 6071 X	#if FF_USE_LFN && FF_LFN_UNICODE			/* With code conversion (Unicode API) */
MacExp: #if 1 && 0			/* With code conversion (Unicode API) */
 6072 X		/* Make a room for the character and terminator  */
 6073 X		if (FF_LFN_UNICODE == 1) len -= (FF_STRF_ENCODE == 0) ? 1 : 2;
 6074 X		if (FF_LFN_UNICODE == 2) len -= (FF_STRF_ENCODE == 0) ? 3 : 4;
 6075 X		if (FF_LFN_UNICODE == 3) len -= 1;
 6076 X		while (nc < len) {
 6077 X	#if FF_STRF_ENCODE == 0		/* Read a character in ANSI/OEM */
MacExp: #if 3 == 0		/* Read a character in ANSI/OEM */
 6078 X			f_read(fp, s, 1, &rc);
 6079 X			if (rc != 1) break;
 6080 X			wc = s[0];
 6081 X			if (dbc_1st((BYTE)wc)) {
 6082 X				f_read(fp, s, 1, &rc);
 6083 X				if (rc != 1 || !dbc_2nd(s[0])) continue;
 6084 X				wc = wc << 8 | s[0];
 6085 X			}
 6086 X			dc = ff_oem2uni(wc, CODEPAGE);
 6087 X			if (dc == 0) continue;
 6088 X	#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2 	/* Read a character in UTF-16LE/BE */
 6089 X			f_read(fp, s, 2, &rc);
 6090 X			if (rc != 2) break;
 6091 X			dc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
 6092 X			if (IsSurrogateL(dc)) continue;
 6093 X			if (IsSurrogateH(dc)) {
 6094 X				f_read(fp, s, 2, &rc);
 6095 X				if (rc != 2) break;
 6096 X				wc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
 6097 X				if (!IsSurrogateL(wc)) continue;
 6098 X				dc = ((dc & 0x3FF) + 0x40) << 10 | (wc & 0x3FF);
 6099 X			}
 6100 X	#else	/* Read a character in UTF-8 */
 6101 X			f_read(fp, s, 1, &rc);
 6102 X			if (rc != 1) break;
 6103 X			dc = s[0];
 6104 X			if (dc >= 0x80) {	/* Multi-byte character? */
 6105 X				ct = 0;
 6106 X				if ((dc & 0xE0) == 0xC0) { dc &= 0x1F; ct = 1; }	/* 2-byte? */
 6107 X				if ((dc & 0xF0) == 0xE0) { dc &= 0x0F; ct = 2; }	/* 3-byte? */
 6108 X				if ((dc & 0xF8) == 0xF0) { dc &= 0x07; ct = 3; }	/* 4-byte? */
 6109 X				if (ct == 0) continue;
 6110 X				f_read(fp, s, ct, &rc);		/* Get trailing bytes */
 6111 X				if (rc != ct) break;
 6112 X				rc = 0;
 6113 X				do {	/* Merge trailing bytes */
 6114 X					if ((s[rc] & 0xC0) != 0x80) break;
 6115 X					dc = dc << 6 | (s[rc] & 0x3F);
 6116 X				} while (++rc < ct);
 6117 X				if (rc != ct || dc < 0x80 || IsSurrogate(dc) || dc >= 0x110000) continue;	/* Wrong encoding? */
 6118 X			}
 6119 X	#endif
 6120 X			if (FF_USE_STRFUNC == 2 && dc == '\r') continue;	/* Strip \r off if needed */
 6121 X	#if FF_LFN_UNICODE == 1	|| FF_LFN_UNICODE == 3	/* Output it in UTF-16/32 encoding */
MacExp: #if 0 == 1	|| 0 == 3	/* Output it in UTF-16/32 encoding */
 6122 X			if (FF_LFN_UNICODE == 1 && dc >= 0x10000) {	/* Out of BMP at UTF-16? */
 6123 X				*p++ = (TCHAR)(0xD800 | ((dc >> 10) - 0x40)); nc++;	/* Make and output high surrogate */
 6124 X				dc = 0xDC00 | (dc & 0x3FF);		/* Make low surrogate */
 6125 X			}
 6126 X			*p++ = (TCHAR)dc; nc++;
 6127 X			if (dc == '\n') break;	/* End of line? */
 6128 X	#elif FF_LFN_UNICODE == 2		/* Output it in UTF-8 encoding */
 6129 X			if (dc < 0x80) {	/* 1-byte */
 6130 X				*p++ = (TCHAR)dc;
 6131 X				nc++;
 6132 X				if (dc == '\n') break;	/* End of line? */
 6133 X			} else {
 6134 X				if (dc < 0x800) {		/* 2-byte */
 6135 X					*p++ = (TCHAR)(0xC0 | (dc >> 6 & 0x1F));
 6136 X					*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
 6137 X					nc += 2;
 6138 X				} else {
 6139 X					if (dc < 0x10000) {	/* 3-byte */
 6140 X						*p++ = (TCHAR)(0xE0 | (dc >> 12 & 0x0F));
 6141 X						*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
 6142 X						*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
 6143 X						nc += 3;
 6144 X					} else {			/* 4-byte */
 6145 X						*p++ = (TCHAR)(0xF0 | (dc >> 18 & 0x07));
 6146 X						*p++ = (TCHAR)(0x80 | (dc >> 12 & 0x3F));
 6147 X						*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
 6148 X						*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
 6149 X						nc += 4;
 6150 X					}
 6151 X				}
 6152 X			}
 6153 X	#endif
 6154 X		}
 6155 X	
 6156 X	#else			/* Byte-by-byte without any conversion (ANSI/OEM API) */
 6157 X		len -= 1;	/* Make a room for the terminator */
 6158 X		while (nc < len) {
 6159 X			f_read(fp, s, 1, &rc);
 6160 X			if (rc != 1) break;
 6161 X			dc = s[0];
 6162 X			if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
 6163 X			*p++ = (TCHAR)dc; nc++;
 6164 X			if (dc == '\n') break;
 6165 X		}
 6166 X	#endif
 6167 X	
 6168 X		*p = 0;		/* Terminate the string */
 6169 X		return nc ? buff : 0;	/* When no data read due to EOF or error, return with error. */
 6170 X	}
 6171 X	
 6172 X	
 6173 X	
 6174 X	
 6175 X	#if !FF_FS_READONLY
MacExp: #if !0
 6176 X	#include <stdarg.h>
 6177 X	/*-----------------------------------------------------------------------*/
 6178 X	/* Put a Character to the File                                           */
 6179 X	/*-----------------------------------------------------------------------*/
 6180 X	
 6181 X	typedef struct {	/* Putchar output buffer and work area */
 6182 X		FIL *fp;		/* Ptr to the writing file */
 6183 X		int idx, nchr;	/* Write index of buf[] (-1:error), number of encoding units written */
 6184 X	#if FF_USE_LFN && FF_LFN_UNICODE == 1
MacExp: #if 1 && 0 == 1
 6185 X		WCHAR hs;
 6186 X	#elif FF_USE_LFN && FF_LFN_UNICODE == 2
 6187 X		BYTE bs[4];
 6188 X		UINT wi, ct;
 6189 X	#endif
 6190 X		BYTE buf[64];	/* Write buffer */
 6191 X	} putbuff;
 6192 X	
 6193 X	
 6194 X	static
 6195 X	void putc_bfd (		/* Buffered write with code conversion */
 6196 X		putbuff* pb,
 6197 X		TCHAR c
 6198 X	)
 6199 X	{
 6200 X		UINT n;
 6201 X		int i, nc;
 6202 X	#if FF_USE_LFN && FF_LFN_UNICODE
MacExp: #if 1 && 0
 6203 X		WCHAR hs, wc;
 6204 X	#if FF_LFN_UNICODE == 2
MacExp: #if 0 == 2
 6205 X		DWORD dc;
 6206 X		TCHAR *tp;
 6207 X	#endif
 6208 X	#endif
 6209 X	
 6210 X		if (FF_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
 6211 X			putc_bfd(pb, '\r');
 6212 X		}
 6213 X	
 6214 X		i = pb->idx;			/* Write index of pb->buf[] */
 6215 X		if (i < 0) return;
 6216 X		nc = pb->nchr;			/* Write unit counter */
 6217 X	
 6218 X	#if FF_USE_LFN && FF_LFN_UNICODE
MacExp: #if 1 && 0
 6219 X	#if FF_LFN_UNICODE == 1		/* UTF-16 input */
MacExp: #if 0 == 1		/* UTF-16 input */
 6220 X		if (IsSurrogateH(c)) {
 6221 X			pb->hs = c; return;
 6222 X		}
 6223 X		hs = pb->hs; pb->hs = 0;
 6224 X		if (hs != 0) {
 6225 X			if (!IsSurrogateL(c)) hs = 0;
 6226 X		} else {
 6227 X			if (IsSurrogateL(c)) return;
 6228 X		}
 6229 X		wc = c;
 6230 X	#elif FF_LFN_UNICODE == 2	/* UTF-8 input */
 6231 X		while (1) {
 6232 X			if (pb->ct == 0) {	/* Out of multi-byte sequence? */
 6233 X				pb->bs[pb->wi = 0] = (BYTE)c;	/* Save 1st byte */
 6234 X				if ((BYTE)c < 0x80) break;					/* 1-byte? */
 6235 X				if (((BYTE)c & 0xE0) == 0xC0) pb->ct = 1;	/* 2-byte? */
 6236 X				if (((BYTE)c & 0xF0) == 0xE0) pb->ct = 2;	/* 3-byte? */
 6237 X				if (((BYTE)c & 0xF1) == 0xF0) pb->ct = 3;	/* 4-byte? */
 6238 X				return;
 6239 X			} else {				/* In the multi-byte sequence */
 6240 X				if (((BYTE)c & 0xC0) != 0x80) {	/* Broken sequence? */
 6241 X					pb->ct = 0; continue;
 6242 X				}
 6243 X				pb->bs[++pb->wi] = (BYTE)c;	/* Save the trailing byte */
 6244 X				if (--pb->ct == 0) break;	/* End of multi-byte sequence? */
 6245 X				return;
 6246 X			}
 6247 X		}
 6248 X		tp = (TCHAR*)pb->bs;
 6249 X		dc = tchar2uni(&tp);	/* UTF-8 ==> UTF-16 */
 6250 X		if (dc == 0xFFFFFFFF) return;
 6251 X		wc = (WCHAR)dc;
 6252 X		hs = (WCHAR)(dc >> 16);
 6253 X	#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
 6254 X		if (IsSurrogate(c) || c >= 0x110000) return;
 6255 X		if (c >= 0x10000) {
 6256 X			hs = (WCHAR)(0xD800 | ((c >> 10) - 0x40)); 	/* Make high surrogate */
 6257 X			wc = 0xDC00 | (c & 0x3FF);					/* Make low surrogate */
 6258 X		} else {
 6259 X			hs = 0;
 6260 X			wc = (WCHAR)c;
 6261 X		}
 6262 X	#endif
 6263 X	
 6264 X	#if FF_STRF_ENCODE == 1		/* Write a character in UTF-16LE */
MacExp: #if 3 == 1		/* Write a character in UTF-16LE */
 6265 X		if (hs != 0) {
 6266 X			st_word(&pb->buf[i], hs);
 6267 X			i += 2;
 6268 X			nc++;
 6269 X		}
 6270 X		st_word(&pb->buf[i], wc);
 6271 X		i += 2;
 6272 X	#elif FF_STRF_ENCODE == 2	/* Write a character in UTF-16BE */
 6273 X		if (hs != 0) {
 6274 X			pb->buf[i++] = (BYTE)(hs >> 8);
 6275 X			pb->buf[i++] = (BYTE)hs;
 6276 X			nc++;
 6277 X		}
 6278 X		pb->buf[i++] = (BYTE)(wc >> 8);
 6279 X		pb->buf[i++] = (BYTE)wc;
 6280 X	#elif FF_STRF_ENCODE == 3	/* Write it in UTF-8 */
 6281 X		if (hs != 0) {				/* 4-byte */
 6282 X			nc += 3;
 6283 X			hs = (hs & 0x3FF) + 0x40;
 6284 X			pb->buf[i++] = (BYTE)(0xF0 | hs >> 8);
 6285 X			pb->buf[i++] = (BYTE)(0x80 | (hs >> 2 & 0x3F));
 6286 X			pb->buf[i++] = (BYTE)(0x80 | (hs & 3) << 4 | (wc >> 6 & 0x0F));
 6287 X			pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
 6288 X		} else {
 6289 X			if (wc < 0x80) {		/* 1-byte */
 6290 X				pb->buf[i++] = (BYTE)wc;
 6291 X			} else {
 6292 X				if (wc < 0x800) {	/* 2-byte */
 6293 X					nc += 1;
 6294 X					pb->buf[i++] = (BYTE)(0xC0 | wc >> 6);
 6295 X				} else {			/* 3-byte */
 6296 X					nc += 2;
 6297 X					pb->buf[i++] = (BYTE)(0xE0 | wc >> 12);
 6298 X					pb->buf[i++] = (BYTE)(0x80 | (wc >> 6 & 0x3F));
 6299 X				}
 6300 X				pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
 6301 X			}
 6302 X		}
 6303 X	#else						/* Write it in ANSI/OEM */
 6304 X		if (hs != 0) return;
 6305 X		wc = ff_uni2oem(wc, CODEPAGE);	/* UTF-16 ==> ANSI/OEM */
 6306 X		if (wc == 0) return;;
 6307 X		if (wc >= 0x100) {
 6308 X			pb->buf[i++] = (BYTE)(wc >> 8); nc++;
 6309 X		}
 6310 X		pb->buf[i++] = (BYTE)wc;
 6311 X	#endif
 6312 X	
 6313 X	#else									/* ANSI/OEM input (without re-encode) */
 6314 X		pb->buf[i++] = (BYTE)c;
 6315 X	#endif
 6316 X	
 6317 X		if (i >= (int)(sizeof pb->buf) - 4) {	/* Write buffered characters to the file */
 6318 X			f_write(pb->fp, pb->buf, (UINT)i, &n);
 6319 X			i = (n == (UINT)i) ? 0 : -1;
 6320 X		}
 6321 X		pb->idx = i;
 6322 X		pb->nchr = nc + 1;
 6323 X	}
 6324 X	
 6325 X	
 6326 X	static
 6327 X	int putc_flush (		/* Flush left characters in the buffer */
 6328 X		putbuff* pb
 6329 X	)
 6330 X	{
 6331 X		UINT nw;
 6332 X	
 6333 X		if (   pb->idx >= 0	/* Flush buffered characters to the file */
 6334 X			&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
 6335 X			&& (UINT)pb->idx == nw) return pb->nchr;
 6336 X		return EOF;
 6337 X	}
 6338 X	
 6339 X	
 6340 X	static
 6341 X	void putc_init (		/* Initialize write buffer */
 6342 X		putbuff* pb,
 6343 X		FIL* fp
 6344 X	)
 6345 X	{
 6346 X		mem_set(pb, 0, sizeof (putbuff));
 6347 X		pb->fp = fp;
 6348 X	}
 6349 X	
 6350 X	
 6351 X	
 6352 X	int f_putc (
 6353 X		TCHAR c,	/* A character to be output */
 6354 X		FIL* fp		/* Pointer to the file object */
 6355 X	)
 6356 X	{
 6357 X		putbuff pb;
 6358 X	
 6359 X	
 6360 X		putc_init(&pb, fp);
 6361 X		putc_bfd(&pb, c);	/* Put the character */
 6362 X		return putc_flush(&pb);
 6363 X	}
 6364 X	
 6365 X	
 6366 X	
 6367 X	
 6368 X	/*-----------------------------------------------------------------------*/
 6369 X	/* Put a String to the File                                              */
 6370 X	/*-----------------------------------------------------------------------*/
 6371 X	
 6372 X	int f_puts (
 6373 X		const TCHAR* str,	/* Pointer to the string to be output */
 6374 X		FIL* fp				/* Pointer to the file object */
 6375 X	)
 6376 X	{
 6377 X		putbuff pb;
 6378 X	
 6379 X	
 6380 X		putc_init(&pb, fp);
 6381 X		while (*str) putc_bfd(&pb, *str++);		/* Put the string */
 6382 X		return putc_flush(&pb);
 6383 X	}
 6384 X	
 6385 X	
 6386 X	
 6387 X	
 6388 X	/*-----------------------------------------------------------------------*/
 6389 X	/* Put a Formatted String to the File                                    */
 6390 X	/*-----------------------------------------------------------------------*/
 6391 X	
 6392 X	int f_printf (
 6393 X		FIL* fp,			/* Pointer to the file object */
 6394 X		const TCHAR* fmt,	/* Pointer to the format string */
 6395 X		...					/* Optional arguments... */
 6396 X	)
 6397 X	{
 6398 X		va_list arp;
 6399 X		putbuff pb;
 6400 X		BYTE f, r;
 6401 X		UINT i, j, w;
 6402 X		DWORD v;
 6403 X		TCHAR c, d, str[32], *p;
 6404 X	
 6405 X	
 6406 X		putc_init(&pb, fp);
 6407 X	
 6408 X		va_start(arp, fmt);
 6409 X	
 6410 X		while (1) {
 6411 X			c = *fmt++;
 6412 X			if (c == 0) break;			/* End of string */
 6413 X			if (c != '%') {				/* Non escape character */
 6414 X				putc_bfd(&pb, c);
 6415 X				continue;
 6416 X			}
 6417 X			w = f = 0;
 6418 X			c = *fmt++;
 6419 X			if (c == '0') {				/* Flag: '0' padding */
 6420 X				f = 1; c = *fmt++;
 6421 X			} else {
 6422 X				if (c == '-') {			/* Flag: left justified */
 6423 X					f = 2; c = *fmt++;
 6424 X				}
 6425 X			}
 6426 X			if (c == '*') {				/* Minimum width by argument */
 6427 X				w = va_arg(arp, int);
 6428 X				c = *fmt++;
 6429 X			} else {
 6430 X				while (IsDigit(c)) {	/* Minimum width */
 6431 X					w = w * 10 + c - '0';
 6432 X					c = *fmt++;
 6433 X				}
 6434 X			}
 6435 X			if (c == 'l' || c == 'L') {	/* Type prefix: Size is long int */
 6436 X				f |= 4; c = *fmt++;
 6437 X			}
 6438 X			if (c == 0) break;
 6439 X			d = c;
 6440 X			if (IsLower(d)) d -= 0x20;
 6441 X			switch (d) {				/* Atgument type is... */
 6442 X			case 'S' :					/* String */
 6443 X				p = va_arg(arp, TCHAR*);
 6444 X				for (j = 0; p[j]; j++) ;
 6445 X				if (!(f & 2)) {						/* Right padded */
 6446 X					while (j++ < w) putc_bfd(&pb, ' ') ;
 6447 X				}
 6448 X				while (*p) putc_bfd(&pb, *p++) ;		/* String body */
 6449 X				while (j++ < w) putc_bfd(&pb, ' ') ;	/* Left padded */
 6450 X				continue;
 6451 X	
 6452 X			case 'C' :					/* Character */
 6453 X				putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
 6454 X	
 6455 X			case 'B' :					/* Unsigned binary */
 6456 X				r = 2; break;
 6457 X	
 6458 X			case 'O' :					/* Unsigned octal */
 6459 X				r = 8; break;
 6460 X	
 6461 X			case 'D' :					/* Signed decimal */
 6462 X			case 'U' :					/* Unsigned decimal */
 6463 X				r = 10; break;
 6464 X	
 6465 X			case 'X' :					/* Unsigned hexdecimal */
 6466 X				r = 16; break;
 6467 X	
 6468 X			default:					/* Unknown type (pass-through) */
 6469 X				putc_bfd(&pb, c); continue;
 6470 X			}
 6471 X	
 6472 X			/* Get an argument and put it in numeral */
 6473 X			v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
 6474 X			if (d == 'D' && (v & 0x80000000)) {
 6475 X				v = 0 - v;
 6476 X				f |= 8;
 6477 X			}
 6478 X			i = 0;
 6479 X			do {
 6480 X				d = (TCHAR)(v % r); v /= r;
 6481 X				if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 6482 X				str[i++] = d + '0';
 6483 X			} while (v && i < sizeof str / sizeof *str);
 6484 X			if (f & 8) str[i++] = '-';
 6485 X			j = i; d = (f & 1) ? '0' : ' ';
 6486 X			if (!(f & 2)) {
 6487 X				while (j++ < w) putc_bfd(&pb, d);	/* Right pad */
 6488 X			}
 6489 X			do {
 6490 X				putc_bfd(&pb, str[--i]);			/* Number body */
 6491 X			} while (i);
 6492 X			while (j++ < w) putc_bfd(&pb, d);		/* Left pad */
 6493 X		}
 6494 X	
 6495 X		va_end(arp);
 6496 X	
 6497 X		return putc_flush(&pb);
 6498 X	}
 6499 X	
 6500 X	#endif /* !FF_FS_READONLY */
 6501  	#endif /* FF_USE_STRFUNC */
 6502  	
 6503  	
 6504  	
 6505  	#if FF_CODE_PAGE == 0
MacExp: #if 437 == 0
 6506 X	/*-----------------------------------------------------------------------*/
 6507 X	/* Set Active Codepage for the Path Name                                 */
 6508 X	/*-----------------------------------------------------------------------*/
 6509 X	
 6510 X	FRESULT f_setcp (
 6511 X		WORD cp		/* Value to be set as active code page */
 6512 X	)
 6513 X	{
 6514 X		static const WORD       validcp[] = {  437,   720,   737,   771,   775,   850,   852,   857,   860,   861,   862,   863,   864,   865,   866,   869,   932,   936,   949,   950, 0};
 6515 X		static const BYTE* const tables[] = {Ct437, Ct720, Ct737, Ct771, Ct775, Ct850, Ct852, Ct857, Ct860, Ct861, Ct862, Ct863, Ct864, Ct865, Ct866, Ct869, Dc932, Dc936, Dc949, Dc950, 0};
 6516 X		UINT i;
 6517 X	
 6518 X	
 6519 X		for (i = 0; validcp[i] != 0 && validcp[i] != cp; i++) ;	/* Find the code page */
 6520 X		if (validcp[i] != cp) return FR_INVALID_PARAMETER;	/* Not found? */
 6521 X	
 6522 X		CodePage = cp;
 6523 X		if (cp >= 900) {	/* DBCS */
 6524 X			ExCvt = 0;
 6525 X			DbcTbl = tables[i];
 6526 X		} else {			/* SBCS */
 6527 X			ExCvt = tables[i];
 6528 X			DbcTbl = 0;
 6529 X		}
 6530 X		return FR_OK;
 6531 X	}
 6532  	#endif	/* FF_CODE_PAGE == 0 */
 6533  	
