    1 C	/* this file based on mlmhw.c of makerlisp project */
    2  	#include <defines.h>
    3  	#include <ez80.h>
    4  	#include <stdio.h>
    5  	#include <stddef.h>
    6  	#include <string.h>
    7  	
    8  	#include "sdcard.h"
    9  	
   10 C	/* Delays, SPI and SD card retry constants */
   11  	#define WAIT4RESET 4000
   12  	#define WAIT4CARD 4000
   13  	#define SDRETRY 2000
   14  	#define SPIRETRY 1000
   15  	
   16  	#define SD_CS 4
   17  	#define TP_CS 1
   18  	#define SPI_MOSI 7
   19  	#define SPI_MISO 6
   20  	#define SPI_CLK 3
   21  	
   22  	
   23  	
   24  	
   25 C	/* Clear, set bits in registers */
   26  	#define BIT( n ) ( 1 << n )
   27  	#define CLEAR_BIT(reg, n) reg &= ~(1 << n)
   28  	#define SET_BIT(reg, n) reg |= (1 << n)
   29  	
   30 C	/* Reads and writes are SPI full duplex exchanges */
   31  	#define read_spi() _xchg_spi(0xFF)
   32  	#define write_spi(d) _xchg_spi(d)
   33  	
   34 C	/* Select and de-select card with GPIO pin */
   35  	#define select()  PB_DR &= ~BIT( SD_CS )
   36  	#define unselect() PB_DR |= BIT( SD_CS )
   37  	#define deselect() unselect(); read_spi()
   38  	
   39 C	/* SD card commands */
   40  	typedef struct sdcmd {
   41  	    char num;
   42  	    UINT32 arg;
   43  	    char crc;
   44  	} SDCMD;
   45  	static SDCMD cmd0 = { 0x40, 0, 0x95 };
   46  	static SDCMD cmd8 = { 0x48, 0x1AA, 0x87 };
   47  	static SDCMD cmd12 = { 0x4c, 0, 0x87 };
   48  	static SDCMD cmd17 = { 0x51, 0, 0 };
   49  	static SDCMD cmd18 = { 0x52, 0, 0 };
   50  	static SDCMD cmd24 = { 0x58, 0, 0 };
   51  	static SDCMD cmd41 = { 0x69, 0x40000000, 0x77 };
   52  	static SDCMD cmd55 = { 0x77, 0, 0x65 };
   53  	static SDCMD cmd58 = { 0x7a, 0, 0 };
   54  	static SDCMD cmd59 = { 0x7b, 0, 0x91 };
   55  	
   56 C	/* RTC date and time array */
   57  	static unsigned char datetime[7];
   58  	
   59 C	/* Expansion board detected */
   60  	static char ebhere;
   61  	
   62 C	/* Reset system devices */
   63  	void init_hw()
   64  	{
   65  	    long i;
   66  	
   67 C	    /* turn on backlight port C bit 2 */
   68  	    PC_DR |= BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9E) |= ( 1 <<  2  );
   69  	    PC_ALT1 &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0xA0) &= ~( 1 <<  2  );
   70  	    PC_ALT2 &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0xA1) &= ~( 1 <<  2  );
   71  	    PC_DDR &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9F) &= ~( 1 <<  2  );
   72  	
   73 C	    /* SS must remain high for spi to work properly */
   74  	    PB_DR |= BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  2  );
   75  	    PB_ALT1 &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9C) &= ~( 1 <<  2  );
   76  	    PB_ALT2 &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9D) &= ~( 1 <<  2  );
   77  	    PB_DDR &= ~BIT( 2 );
MacExp:     (*(volatile unsigned char __INTIO *)0x9B) &= ~( 1 <<  2  );
   78  	
   79 C	    // Enable the chip select outputs and de-select
   80  	    PB_DR |= ( BIT( SD_CS ) | BIT( TP_CS ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9A) |= ( ( 1 <<  4  ) | ( 1 <<  1  ) );
   81  	    PB_ALT1 &= ~( BIT( SD_CS ) | BIT( TP_CS ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9C) &= ~( ( 1 <<  4  ) | ( 1 <<  1  ) );
   82  	    PB_ALT2 &= ~( BIT( SD_CS ) | BIT( TP_CS ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9D) &= ~( ( 1 <<  4  ) | ( 1 <<  1  ) );
   83  	    PB_DDR &= ~( BIT( SD_CS ) | BIT( TP_CS ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9B) &= ~( ( 1 <<  4  ) | ( 1 <<  1  ) );
   84  	
   85 C	    /* Set port B pins 7 (MOSI), 6 (MISO), 3 (SCK), 2 (/SS) to SPI */
   86  	    PB_ALT1 &= ~( BIT( SPI_MOSI ) | BIT( SPI_MISO ) | BIT( SPI_CLK ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9C) &= ~( ( 1 <<  7  ) | ( 1 <<  6  ) | ( 1 <<  3  ) );
   87  	    PB_ALT2 |= ( BIT( SPI_MOSI ) | BIT( SPI_MISO ) | BIT( SPI_CLK ) );
MacExp:     (*(volatile unsigned char __INTIO *)0x9D) |= ( ( 1 <<  7  ) | ( 1 <<  6  ) | ( 1 <<  3  ) );
   88  	
   89  	    i = 0;
   90  	    while (i < WAIT4RESET) {
MacExp:     while (i < 4000) {
   91  	        ++i;
   92  	    }
   93  	
   94  	}
   95  	
   96  	void mode_spi( d )
   97  	{
   98  	    SPI_CTL = 0;
MacExp:     (*(volatile unsigned char __INTIO *)0xBA) = 0;
   99  	    SPI_BRG_H = d / 256;
MacExp:     (*(volatile unsigned char __INTIO *)0xB9) = d / 256;
  100  	    SPI_BRG_L = d % 256;
MacExp:     (*(volatile unsigned char __INTIO *)0xB8) = d % 256;
  101  	    SPI_CTL = 0x30;
MacExp:     (*(volatile unsigned char __INTIO *)0xBA) = 0x30;
  102  	}
  103  	
  104 C	/* SPI exchange transfer */
  105  	char _xchg_spi(char d)
  106  	{
  107  	    int i;
  108  	    volatile int delay;
  109  	
  110 C	    /* Write the data to exchange */
  111  	    SPI_TSR = d;
MacExp:     (*(volatile unsigned char __INTIO *)0xBC) = d;
  112  	
  113 C	    /* Wait for slave data to arrive */
  114  	    i = 0;
  115  	    while (i < SPIRETRY) {
MacExp:     while (i < 1000) {
  116  	        if (SPI_SR & (1 << 7)) {
MacExp:         if ((*(volatile unsigned char __INTIO *)0xBB) & (1 << 7)) {
  117  	            break;
  118  	        }
  119  	        ++i;
  120  	    }
  121  	
  122 C	    /* Delay, then read data */
  123  	    delay = 0;
  124  	    while (delay < 1) {
  125  	        ++delay;
  126  	    }
  127  	
  128  	    return SPI_RBR;
MacExp:     return (*(volatile unsigned char __INTIO *)0xBC);
  129  	}
  130  	
  131 C	/* Send a command to the SD card and get response, move data */
  132  	static int cmd_sdcard(SDCMD *cmd, BYTE *buf, int tok, int dlen, int ddir)
  133  	{
  134  	    char d, r;
  135  	    int i, l;
  136  	
  137 C	    //printf( "\r\n>00<%04X>", cmd->num );
  138 C	    /* Starting a command ? */
  139  	    r = 0xFF;
  140  	    if (cmd) {
  141  	
  142 C	        /* Select card, wait for ready */
  143  	        select();
MacExp:         (*(volatile unsigned char __INTIO *)0x9A) &= ~( 1 <<  4  );
  144  	        i = 0;
  145  	        while (i < SDRETRY) {
MacExp:         while (i < 2000) {
  146  	            d = read_spi();
MacExp:             d = _xchg_spi(0xFF);
  147  	            if (d == (char)0xFF) {
  148  	                break;
  149  	            }
  150  	            ++i;
  151  	        }
  152  	        if (!(i < SDRETRY)) {
MacExp:         if (!(i < 2000)) {
  153  	            deselect();
MacExp:             (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  4  ); _xchg_spi(0xFF);
  154  	            return -1;
  155  	        }
  156  	
  157 C	        /* Write command */
  158  	        write_spi(cmd->num);
MacExp:         _xchg_spi(cmd->num);
  159  	        write_spi(cmd->arg >> 24);
MacExp:         _xchg_spi(cmd->arg >> 24);
  160  	        write_spi(cmd->arg >> 16);
MacExp:         _xchg_spi(cmd->arg >> 16);
  161  	        write_spi(cmd->arg >> 8);
MacExp:         _xchg_spi(cmd->arg >> 8);
  162  	        write_spi(cmd->arg >> 0);
MacExp:         _xchg_spi(cmd->arg >> 0);
  163  	        write_spi(cmd->crc);
MacExp:         _xchg_spi(cmd->crc);
  164  	
  165 C	        /* Wait for response */
  166  	        if (cmd->num == cmd12.num) {
  167  	
  168 C	            /* CMD12 stuff byte */
  169  	            read_spi();
MacExp:             _xchg_spi(0xFF);
  170  	        }
  171  	        i = 0;
  172  	        while (i < SDRETRY) {
MacExp:         while (i < 2000) {
  173  	            r = read_spi();
MacExp:             r = _xchg_spi(0xFF);
  174  	            if (!(r < 0)) {
  175  	                break;
  176  	            }
  177  	            ++i;
  178  	        }
  179  	        if (!(i < SDRETRY)) {
MacExp:         if (!(i < 2000)) {
  180  	            deselect();
MacExp:             (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  4  ); _xchg_spi(0xFF);
  181 C	            //printf( "\r\n>07<-1>" );
  182  	            return -1;
  183  	        }
  184  	    }
  185  	
  186 C	    /* Wait for or write data token */
  187  	    if (!(tok < 0)) {
  188  	        if (!ddir) {
  189  	            i = 0;
  190  	            while (i < SDRETRY) {
MacExp:             while (i < 2000) {
  191  	                r = read_spi();
MacExp:                 r = _xchg_spi(0xFF);
  192  	                if (r == (char)tok) {
  193  	                    break;
  194  	                }
  195  	                ++i;
  196  	            }
  197  	            if (!(i < SDRETRY)) {
MacExp:             if (!(i < 2000)) {
  198  	                deselect();
MacExp:                 (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  4  ); _xchg_spi(0xFF);
  199 C	                //printf( "\r\n>10<-1>" );
  200  	                return -1;
  201  	            }
  202  	        } else {
  203  	            read_spi();
MacExp:             _xchg_spi(0xFF);
  204  	            write_spi(tok);
MacExp:             _xchg_spi(tok);
  205  	        }
  206  	    }
  207  	
  208 C	    /* Move response or data */
  209  	    i = 0;
  210  	    l = (dlen < 0) ? -dlen : dlen;
  211  	    while (i < l) {
  212  	        if (!ddir) {
  213  	            buf[i] = read_spi();
MacExp:             buf[i] = _xchg_spi(0xFF);
  214  	        } else {
  215  	            write_spi(buf[i]);
MacExp:             _xchg_spi(buf[i]);
  216  	        }
  217  	        ++i;
  218  	    }
  219  	
  220 C	    /* Wait for not busy, then deselect, if this is the end */
  221  	    if (!(dlen < 0)) {
  222  	        i = 0;
  223  	        while (i < SDRETRY) {
MacExp:         while (i < 2000) {
  224  	            d = read_spi();
MacExp:             d = _xchg_spi(0xFF);
  225  	            if (d == (char)0xFF) {
  226  	                break;
  227  	            }
  228  	            ++i;
  229  	        }
  230  	        deselect();
MacExp:         (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  4  ); _xchg_spi(0xFF);
  231  	    }
  232 C	    //printf( "\r\n>15<%04X>", r );
  233 C	
  234  	    return (unsigned char)r;
  235  	}
  236  	
  237 C	/* Set up SD card for reads and writes - expect SD v2, HC */
  238  	int init_sdcard()
  239  	{
  240  	    BYTE response[4];
  241  	    int i;
  242  	
  243 C	    /* Set SPI in master mode, "mode 0" transfers, 200 kHz */
  244  	    mode_spi( 50 );
  245  	
  246 C	    /* Write 80 clock pulses with /CS and DI (MOSI) high */
  247  	    deselect();
MacExp:     (*(volatile unsigned char __INTIO *)0x9A) |= ( 1 <<  4  ); _xchg_spi(0xFF);
  248  	    i = 0;
  249  	    while (i < 10) {
  250  	        write_spi(0xFF);
MacExp:         _xchg_spi(0xFF);
  251  	        ++i;
  252  	    }
  253  	
  254 C	    /* Reset, put card in "SPI" mode */
  255  	    if (cmd_sdcard(&cmd0, NULL, -1, 0, 0) != 0x01) {
MacExp:     if (cmd_sdcard(&cmd0, (void *)0, -1, 0, 0) != 0x01) {
  256  	        return 1;
  257  	    }
  258 C	    /* Check voltage range, SDC version 2 */
  259  	    if (cmd_sdcard(&cmd8, response, -1, 4, 0) != 0x01) {
  260  	        return 1;
  261  	    }
  262  	
  263 C	    /* Turn off CRC checking */
  264  	    if (cmd_sdcard(&cmd59, NULL, -1, 0, 0) != 0x01) {
MacExp:     if (cmd_sdcard(&cmd59, (void *)0, -1, 0, 0) != 0x01) {
  265  	        return 1;
  266  	    }
  267  	
  268 C	    /* Initialize */
  269  	    i = 0;
  270  	    while (i < SDRETRY) {
MacExp:     while (i < 2000) {
  271  	        cmd_sdcard(&cmd55, NULL, -1, 0, 0);
MacExp:         cmd_sdcard(&cmd55, (void *)0, -1, 0, 0);
  272  	        if (cmd_sdcard(&cmd41, NULL, -1, 0, 0) == 0x00) {
MacExp:         if (cmd_sdcard(&cmd41, (void *)0, -1, 0, 0) == 0x00) {
  273  	            break;
  274  	        }
  275  	        ++i;
  276  	    }
  277  	    if (!(i < SDRETRY)) {
MacExp:     if (!(i < 2000)) {
  278  	        return 1;
  279  	    }
  280  	
  281 C	    /* Read OCR register, check for block addressing */
  282  	    if (cmd_sdcard(&cmd58, response, -1, 4, 0) != 0x00) {
  283  	        return 1;
  284  	    }
  285  	    if (!(response[0] & 0x40)) {
  286  	        return 1;
  287  	    }
  288  	
  289 C	    /* Set SPI data rate to 8.33 MHz */
  290  	    mode_spi( 3 );
  291  	
  292  	    return 0;
  293  	}
  294  	
  295 C	/* Read blocks */
  296  	int read_sdcard(BYTE *buf, UINT32 n, UINT blks)
  297  	{
  298  	    BYTE crc[2];
  299  	    int i, r;
  300  	
  301  	    if (blks == 1) {
  302  	
  303 C	        /* Single block ? */
  304  	        cmd17.arg = n;
  305  	        r = cmd_sdcard(&cmd17, buf, 0xFE, -512, 0);
  306  	        if (!(r == 0xFE)) {
  307  	            return 1;
  308  	        }
  309  	        cmd_sdcard(NULL, crc, -1, sizeof(crc), 0);
MacExp:         cmd_sdcard((void *)0, crc, -1, sizeof(crc), 0);
  310  	    } else {
  311  	
  312 C	        /* Multiple blocks */
  313  	        cmd18.arg = n;
  314  	        r = cmd_sdcard(&cmd18, NULL, -1, -1, 0);
MacExp:         r = cmd_sdcard(&cmd18, (void *)0, -1, -1, 0);
  315  	        i = 0;
  316  	        while (i < blks) {
  317  	            r = cmd_sdcard(NULL, buf + i*512, 0xFE, -512, 0);;
MacExp:             r = cmd_sdcard((void *)0, buf + i*512, 0xFE, -512, 0);;
  318  	            if (!(r == 0xFE)) {
  319  	                return 1;
  320  	            }
  321  	            cmd_sdcard(NULL, crc, -1, -sizeof(crc), 0);
MacExp:             cmd_sdcard((void *)0, crc, -1, -sizeof(crc), 0);
  322  	            ++i;
  323  	        }
  324  	        r = cmd_sdcard(&cmd12, NULL, -1, 0, 0);
MacExp:         r = cmd_sdcard(&cmd12, (void *)0, -1, 0, 0);
  325  	        if (r) {
  326  	            return 1;
  327  	        }
  328  	    }
  329  	
  330  	    return 0;
  331  	}
  332  	
  333 C	/* Write a block */
  334  	int write_sdcard(BYTE *buf, UINT32 n)
  335  	{
  336  	    BYTE dr, crc[2];
  337  	    int i, r;
  338  	
  339  	    cmd24.arg = n;
  340  	    r = cmd_sdcard(&cmd24, buf, 0xFE, -512, 1);
  341  	    cmd_sdcard(NULL, crc, -1, -sizeof(crc), 1);
MacExp:     cmd_sdcard((void *)0, crc, -1, -sizeof(crc), 1);
  342  	    cmd_sdcard(NULL, &dr, -1, 1, 0);
MacExp:     cmd_sdcard((void *)0, &dr, -1, 1, 0);
  343  	
  344  	    if (!(r == 0x00)) {
  345  	        return 1;
  346  	    }
  347  	    if (!((dr & 0x1F) == 0x05)) {
  348  	        return 1;
  349  	    }
  350  	
  351  	    return 0;
  352  	}
  353  	
  354 C	/* Read and write registers */
  355  	int _readreg(int regaddr)
  356  	{
  357  	    return *(volatile unsigned char __INTIO *)regaddr;
  358  	}
  359  	void _writereg(int regaddr, int d)
  360  	{
  361  	    *(volatile unsigned char __INTIO *)regaddr = d;
  362  	}
  363  	
  364 C	/* Get time from RTC */
  365  	UINT8 *get_time()
  366  	{
  367 C	    /* Snapshot the time */
  368  	    RTC_CTRL = 0x21;
MacExp:     (*(volatile unsigned char __INTIO *)0xED) = 0x21;
  369  	    datetime[6] = RTC_CEN;
MacExp:     datetime[6] = (*(volatile unsigned char __INTIO *)0xE7);
  370  	    datetime[5] = RTC_YR;
MacExp:     datetime[5] = (*(volatile unsigned char __INTIO *)0xE6);
  371  	    datetime[4] = RTC_MON;
MacExp:     datetime[4] = (*(volatile unsigned char __INTIO *)0xE5);
  372  	    datetime[3] = RTC_DOM;
MacExp:     datetime[3] = (*(volatile unsigned char __INTIO *)0xE4);
  373  	    datetime[2] = RTC_HRS;
MacExp:     datetime[2] = (*(volatile unsigned char __INTIO *)0xE2);
  374  	    datetime[1] = RTC_MIN;
MacExp:     datetime[1] = (*(volatile unsigned char __INTIO *)0xE1);
  375  	    datetime[0] = RTC_SEC;
MacExp:     datetime[0] = (*(volatile unsigned char __INTIO *)0xE0);
  376  	    RTC_CTRL = 0x20;
MacExp:     (*(volatile unsigned char __INTIO *)0xED) = 0x20;
  377  	
  378  	    return &datetime;
  379  	}
  380  	
  381  	
  382  	
